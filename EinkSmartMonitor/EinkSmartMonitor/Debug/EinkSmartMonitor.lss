
EinkSmartMonitor.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040c0  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000018  20000000  000040c0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000017a8  20000018  000040d8  00020018  2**2
                  ALLOC
  3 .stack        00001000  200017c0  00005880  00020018  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020018  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020040  2**0
                  CONTENTS, READONLY
  6 .debug_info   000c2b89  00000000  00000000  00020099  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000051d8  00000000  00000000  000e2c22  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000514c9  00000000  00000000  000e7dfa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00003400  00000000  00000000  001392c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000033a0  00000000  00000000  0013c6c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00007b27  00000000  00000000  0013fa63  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00018765  00000000  00000000  0014758a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0006e1fe  00000000  00000000  0015fcef  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000abe0  00000000  00000000  001cdef0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	c0 27 00 20 09 01 00 00 05 01 00 00 05 01 00 00     .'. ............
	...
      2c:	05 01 00 00 00 00 00 00 00 00 00 00 05 01 00 00     ................
      3c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
      4c:	05 01 00 00 3d 07 00 00 05 01 00 00 05 01 00 00     ....=...........
      5c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
	...
      74:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
      84:	05 01 00 00 05 01 00 00 00 00 00 00 00 00 00 00     ................
      94:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	20000018 	.word	0x20000018
      c4:	00000000 	.word	0x00000000
      c8:	000040c0 	.word	0x000040c0

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      ce:	b510      	push	{r4, lr}
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	2000001c 	.word	0x2000001c
      f8:	000040c0 	.word	0x000040c0
      fc:	000040c0 	.word	0x000040c0
     100:	00000000 	.word	0x00000000

00000104 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     104:	e7fe      	b.n	104 <Dummy_Handler>
	...

00000108 <Reset_Handler>:
{
     108:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     10a:	4a12      	ldr	r2, [pc, #72]	; (154 <Reset_Handler+0x4c>)
     10c:	4b12      	ldr	r3, [pc, #72]	; (158 <Reset_Handler+0x50>)
     10e:	429a      	cmp	r2, r3
     110:	d009      	beq.n	126 <Reset_Handler+0x1e>
     112:	4b11      	ldr	r3, [pc, #68]	; (158 <Reset_Handler+0x50>)
     114:	4a0f      	ldr	r2, [pc, #60]	; (154 <Reset_Handler+0x4c>)
     116:	e003      	b.n	120 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     118:	6811      	ldr	r1, [r2, #0]
     11a:	6019      	str	r1, [r3, #0]
     11c:	3304      	adds	r3, #4
     11e:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     120:	490e      	ldr	r1, [pc, #56]	; (15c <Reset_Handler+0x54>)
     122:	428b      	cmp	r3, r1
     124:	d3f8      	bcc.n	118 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     126:	4b0e      	ldr	r3, [pc, #56]	; (160 <Reset_Handler+0x58>)
     128:	e002      	b.n	130 <Reset_Handler+0x28>
                *pDest++ = 0;
     12a:	2200      	movs	r2, #0
     12c:	601a      	str	r2, [r3, #0]
     12e:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     130:	4a0c      	ldr	r2, [pc, #48]	; (164 <Reset_Handler+0x5c>)
     132:	4293      	cmp	r3, r2
     134:	d3f9      	bcc.n	12a <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     136:	4a0c      	ldr	r2, [pc, #48]	; (168 <Reset_Handler+0x60>)
     138:	21ff      	movs	r1, #255	; 0xff
     13a:	4b0c      	ldr	r3, [pc, #48]	; (16c <Reset_Handler+0x64>)
     13c:	438b      	bics	r3, r1
     13e:	6093      	str	r3, [r2, #8]
        NVMCTRL->CTRLB.bit.MANW = 1;
     140:	4a0b      	ldr	r2, [pc, #44]	; (170 <Reset_Handler+0x68>)
     142:	6851      	ldr	r1, [r2, #4]
     144:	2380      	movs	r3, #128	; 0x80
     146:	430b      	orrs	r3, r1
     148:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     14a:	4b0a      	ldr	r3, [pc, #40]	; (174 <Reset_Handler+0x6c>)
     14c:	4798      	blx	r3
        main();
     14e:	4b0a      	ldr	r3, [pc, #40]	; (178 <Reset_Handler+0x70>)
     150:	4798      	blx	r3
     152:	e7fe      	b.n	152 <Reset_Handler+0x4a>
     154:	000040c0 	.word	0x000040c0
     158:	20000000 	.word	0x20000000
     15c:	20000018 	.word	0x20000018
     160:	20000018 	.word	0x20000018
     164:	200017c0 	.word	0x200017c0
     168:	e000ed00 	.word	0xe000ed00
     16c:	00000000 	.word	0x00000000
     170:	41004000 	.word	0x41004000
     174:	00002c69 	.word	0x00002c69
     178:	00002895 	.word	0x00002895

0000017c <delay_driver_init>:
	i2c_m_sync_init(&I2C_0, SERCOM3);
	I2C_0_PORT_init();
}

void delay_driver_init(void)
{
     17c:	b510      	push	{r4, lr}
	delay_init(SysTick);
     17e:	4802      	ldr	r0, [pc, #8]	; (188 <delay_driver_init+0xc>)
     180:	4b02      	ldr	r3, [pc, #8]	; (18c <delay_driver_init+0x10>)
     182:	4798      	blx	r3
}
     184:	bd10      	pop	{r4, pc}
     186:	46c0      	nop			; (mov r8, r8)
     188:	e000e010 	.word	0xe000e010
     18c:	000001ad 	.word	0x000001ad

00000190 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     190:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     194:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     196:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     198:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
     19c:	4770      	bx	lr

0000019e <atomic_leave_critical>:
     19e:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     1a2:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     1a4:	f383 8810 	msr	PRIMASK, r3
}
     1a8:	4770      	bx	lr
	...

000001ac <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
     1ac:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
     1ae:	4b02      	ldr	r3, [pc, #8]	; (1b8 <delay_init+0xc>)
     1b0:	6018      	str	r0, [r3, #0]
     1b2:	4b02      	ldr	r3, [pc, #8]	; (1bc <delay_init+0x10>)
     1b4:	4798      	blx	r3
}
     1b6:	bd10      	pop	{r4, pc}
     1b8:	20000034 	.word	0x20000034
     1bc:	00001159 	.word	0x00001159

000001c0 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     1c0:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     1c2:	4b04      	ldr	r3, [pc, #16]	; (1d4 <delay_ms+0x14>)
     1c4:	681c      	ldr	r4, [r3, #0]
     1c6:	4b04      	ldr	r3, [pc, #16]	; (1d8 <delay_ms+0x18>)
     1c8:	4798      	blx	r3
     1ca:	0001      	movs	r1, r0
     1cc:	0020      	movs	r0, r4
     1ce:	4b03      	ldr	r3, [pc, #12]	; (1dc <delay_ms+0x1c>)
     1d0:	4798      	blx	r3
}
     1d2:	bd10      	pop	{r4, pc}
     1d4:	20000034 	.word	0x20000034
     1d8:	00000609 	.word	0x00000609
     1dc:	00001165 	.word	0x00001165

000001e0 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
     1e0:	b570      	push	{r4, r5, r6, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
     1e2:	2502      	movs	r5, #2
     1e4:	2400      	movs	r4, #0

	while (upper >= lower) {
     1e6:	e007      	b.n	1f8 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
     1e8:	4a0d      	ldr	r2, [pc, #52]	; (220 <process_ext_irq+0x40>)
     1ea:	58b3      	ldr	r3, [r6, r2]
     1ec:	2b00      	cmp	r3, #0
     1ee:	d000      	beq.n	1f2 <process_ext_irq+0x12>
				ext_irqs[middle].cb();
     1f0:	4798      	blx	r3
			lower = middle + 1;
		} else {
			upper = middle - 1;
		}
	}
}
     1f2:	bd70      	pop	{r4, r5, r6, pc}
			upper = middle - 1;
     1f4:	3a01      	subs	r2, #1
     1f6:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
     1f8:	42ac      	cmp	r4, r5
     1fa:	d8fa      	bhi.n	1f2 <process_ext_irq+0x12>
		middle = (upper + lower) >> 1;
     1fc:	192b      	adds	r3, r5, r4
     1fe:	105b      	asrs	r3, r3, #1
     200:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
     202:	2a01      	cmp	r2, #1
     204:	d8f5      	bhi.n	1f2 <process_ext_irq+0x12>
     206:	21ff      	movs	r1, #255	; 0xff
     208:	400b      	ands	r3, r1
		if (ext_irqs[middle].pin == pin) {
     20a:	00de      	lsls	r6, r3, #3
     20c:	4904      	ldr	r1, [pc, #16]	; (220 <process_ext_irq+0x40>)
     20e:	1989      	adds	r1, r1, r6
     210:	6849      	ldr	r1, [r1, #4]
     212:	4281      	cmp	r1, r0
     214:	d0e8      	beq.n	1e8 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
     216:	d2ed      	bcs.n	1f4 <process_ext_irq+0x14>
			lower = middle + 1;
     218:	3201      	adds	r2, #1
     21a:	b2d4      	uxtb	r4, r2
     21c:	e7ec      	b.n	1f8 <process_ext_irq+0x18>
     21e:	46c0      	nop			; (mov r8, r8)
     220:	20000038 	.word	0x20000038

00000224 <ext_irq_init>:
{
     224:	b510      	push	{r4, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     226:	2300      	movs	r3, #0
     228:	e009      	b.n	23e <ext_irq_init+0x1a>
		ext_irqs[i].pin = 0xFFFFFFFF;
     22a:	4a08      	ldr	r2, [pc, #32]	; (24c <ext_irq_init+0x28>)
     22c:	00d9      	lsls	r1, r3, #3
     22e:	1850      	adds	r0, r2, r1
     230:	2401      	movs	r4, #1
     232:	4264      	negs	r4, r4
     234:	6044      	str	r4, [r0, #4]
		ext_irqs[i].cb  = NULL;
     236:	2000      	movs	r0, #0
     238:	5088      	str	r0, [r1, r2]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     23a:	3301      	adds	r3, #1
     23c:	b29b      	uxth	r3, r3
     23e:	2b01      	cmp	r3, #1
     240:	d9f3      	bls.n	22a <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
     242:	4803      	ldr	r0, [pc, #12]	; (250 <ext_irq_init+0x2c>)
     244:	4b03      	ldr	r3, [pc, #12]	; (254 <ext_irq_init+0x30>)
     246:	4798      	blx	r3
}
     248:	bd10      	pop	{r4, pc}
     24a:	46c0      	nop			; (mov r8, r8)
     24c:	20000038 	.word	0x20000038
     250:	000001e1 	.word	0x000001e1
     254:	0000064d 	.word	0x0000064d

00000258 <ext_irq_register>:
{
     258:	b5f0      	push	{r4, r5, r6, r7, lr}
     25a:	46d6      	mov	lr, sl
     25c:	464f      	mov	r7, r9
     25e:	4646      	mov	r6, r8
     260:	b5c0      	push	{r6, r7, lr}
     262:	b084      	sub	sp, #16
	uint8_t i = 0, j = 0;
     264:	2300      	movs	r3, #0
	for (; i < EXT_IRQ_AMOUNT; i++) {
     266:	2b01      	cmp	r3, #1
     268:	d80c      	bhi.n	284 <ext_irq_register+0x2c>
		if (ext_irqs[i].pin == pin) {
     26a:	00dc      	lsls	r4, r3, #3
     26c:	4a32      	ldr	r2, [pc, #200]	; (338 <ext_irq_register+0xe0>)
     26e:	1912      	adds	r2, r2, r4
     270:	6852      	ldr	r2, [r2, #4]
     272:	4282      	cmp	r2, r0
     274:	d002      	beq.n	27c <ext_irq_register+0x24>
	for (; i < EXT_IRQ_AMOUNT; i++) {
     276:	3301      	adds	r3, #1
     278:	b2db      	uxtb	r3, r3
     27a:	e7f4      	b.n	266 <ext_irq_register+0xe>
			ext_irqs[i].cb = cb;
     27c:	4b2e      	ldr	r3, [pc, #184]	; (338 <ext_irq_register+0xe0>)
     27e:	50e1      	str	r1, [r4, r3]
			found          = true;
     280:	2601      	movs	r6, #1
			break;
     282:	e000      	b.n	286 <ext_irq_register+0x2e>
	bool    found = false;
     284:	2600      	movs	r6, #0
	if (NULL == cb) {
     286:	2900      	cmp	r1, #0
     288:	d00c      	beq.n	2a4 <ext_irq_register+0x4c>
	if (!found) {
     28a:	2e00      	cmp	r6, #0
     28c:	d142      	bne.n	314 <ext_irq_register+0xbc>
     28e:	2300      	movs	r3, #0
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     290:	2b01      	cmp	r3, #1
     292:	d811      	bhi.n	2b8 <ext_irq_register+0x60>
			if (NULL == ext_irqs[i].cb) {
     294:	00da      	lsls	r2, r3, #3
     296:	4d28      	ldr	r5, [pc, #160]	; (338 <ext_irq_register+0xe0>)
     298:	5952      	ldr	r2, [r2, r5]
     29a:	2a00      	cmp	r2, #0
     29c:	d007      	beq.n	2ae <ext_irq_register+0x56>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     29e:	3301      	adds	r3, #1
     2a0:	b2db      	uxtb	r3, r3
     2a2:	e7f5      	b.n	290 <ext_irq_register+0x38>
		if (!found) {
     2a4:	2e00      	cmp	r6, #0
     2a6:	d040      	beq.n	32a <ext_irq_register+0xd2>
		return _ext_irq_enable(pin, false);
     2a8:	4b24      	ldr	r3, [pc, #144]	; (33c <ext_irq_register+0xe4>)
     2aa:	4798      	blx	r3
     2ac:	e037      	b.n	31e <ext_irq_register+0xc6>
				ext_irqs[i].cb  = cb;
     2ae:	00dc      	lsls	r4, r3, #3
     2b0:	5161      	str	r1, [r4, r5]
				ext_irqs[i].pin = pin;
     2b2:	192c      	adds	r4, r5, r4
     2b4:	6060      	str	r0, [r4, #4]
				found           = true;
     2b6:	2601      	movs	r6, #1
     2b8:	2200      	movs	r2, #0
     2ba:	e001      	b.n	2c0 <ext_irq_register+0x68>
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
     2bc:	3201      	adds	r2, #1
     2be:	b2d2      	uxtb	r2, r2
     2c0:	2a01      	cmp	r2, #1
     2c2:	d827      	bhi.n	314 <ext_irq_register+0xbc>
     2c4:	2b01      	cmp	r3, #1
     2c6:	d825      	bhi.n	314 <ext_irq_register+0xbc>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
     2c8:	9301      	str	r3, [sp, #4]
     2ca:	491b      	ldr	r1, [pc, #108]	; (338 <ext_irq_register+0xe0>)
     2cc:	00dc      	lsls	r4, r3, #3
     2ce:	190c      	adds	r4, r1, r4
     2d0:	6867      	ldr	r7, [r4, #4]
     2d2:	00d4      	lsls	r4, r2, #3
     2d4:	1909      	adds	r1, r1, r4
     2d6:	6849      	ldr	r1, [r1, #4]
     2d8:	428f      	cmp	r7, r1
     2da:	d2ef      	bcs.n	2bc <ext_irq_register+0x64>
     2dc:	1c4c      	adds	r4, r1, #1
     2de:	d0ed      	beq.n	2bc <ext_irq_register+0x64>
				struct ext_irq tmp = ext_irqs[j];
     2e0:	a902      	add	r1, sp, #8
     2e2:	468c      	mov	ip, r1
     2e4:	4c14      	ldr	r4, [pc, #80]	; (338 <ext_irq_register+0xe0>)
     2e6:	46a0      	mov	r8, r4
     2e8:	00d4      	lsls	r4, r2, #3
     2ea:	46a1      	mov	r9, r4
     2ec:	4644      	mov	r4, r8
     2ee:	444c      	add	r4, r9
     2f0:	4665      	mov	r5, ip
     2f2:	cc82      	ldmia	r4!, {r1, r7}
     2f4:	c582      	stmia	r5!, {r1, r7}
				ext_irqs[j] = ext_irqs[i];
     2f6:	9901      	ldr	r1, [sp, #4]
     2f8:	00c9      	lsls	r1, r1, #3
     2fa:	468a      	mov	sl, r1
     2fc:	4649      	mov	r1, r9
     2fe:	4441      	add	r1, r8
     300:	4644      	mov	r4, r8
     302:	4454      	add	r4, sl
     304:	cca0      	ldmia	r4!, {r5, r7}
     306:	c1a0      	stmia	r1!, {r5, r7}
				ext_irqs[i] = tmp;
     308:	4645      	mov	r5, r8
     30a:	4455      	add	r5, sl
     30c:	4661      	mov	r1, ip
     30e:	c990      	ldmia	r1!, {r4, r7}
     310:	c590      	stmia	r5!, {r4, r7}
     312:	e7d3      	b.n	2bc <ext_irq_register+0x64>
	if (!found) {
     314:	2e00      	cmp	r6, #0
     316:	d00b      	beq.n	330 <ext_irq_register+0xd8>
	return _ext_irq_enable(pin, true);
     318:	2101      	movs	r1, #1
     31a:	4b08      	ldr	r3, [pc, #32]	; (33c <ext_irq_register+0xe4>)
     31c:	4798      	blx	r3
}
     31e:	b004      	add	sp, #16
     320:	bc1c      	pop	{r2, r3, r4}
     322:	4690      	mov	r8, r2
     324:	4699      	mov	r9, r3
     326:	46a2      	mov	sl, r4
     328:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
     32a:	200d      	movs	r0, #13
     32c:	4240      	negs	r0, r0
     32e:	e7f6      	b.n	31e <ext_irq_register+0xc6>
		return ERR_INVALID_ARG;
     330:	200d      	movs	r0, #13
     332:	4240      	negs	r0, r0
     334:	e7f3      	b.n	31e <ext_irq_register+0xc6>
     336:	46c0      	nop			; (mov r8, r8)
     338:	20000038 	.word	0x20000038
     33c:	000006e9 	.word	0x000006e9

00000340 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
     340:	b510      	push	{r4, lr}
     342:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
     344:	3814      	subs	r0, #20
     346:	8b84      	ldrh	r4, [r0, #28]
     348:	ab01      	add	r3, sp, #4
     34a:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     34c:	0014      	movs	r4, r2
     34e:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
     350:	4a06      	ldr	r2, [pc, #24]	; (36c <i2c_m_sync_write+0x2c>)
     352:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
     354:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     356:	0019      	movs	r1, r3
     358:	4b05      	ldr	r3, [pc, #20]	; (370 <i2c_m_sync_write+0x30>)
     35a:	4798      	blx	r3

	if (ret) {
     35c:	2800      	cmp	r0, #0
     35e:	d102      	bne.n	366 <i2c_m_sync_write+0x26>
		return ret;
	}

	return n;
}
     360:	0020      	movs	r0, r4
     362:	b004      	add	sp, #16
     364:	bd10      	pop	{r4, pc}
		return ret;
     366:	0004      	movs	r4, r0
     368:	e7fa      	b.n	360 <i2c_m_sync_write+0x20>
     36a:	46c0      	nop			; (mov r8, r8)
     36c:	ffff8000 	.word	0xffff8000
     370:	00000ba5 	.word	0x00000ba5

00000374 <i2c_m_sync_read>:
{
     374:	b510      	push	{r4, lr}
     376:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
     378:	3814      	subs	r0, #20
     37a:	8b84      	ldrh	r4, [r0, #28]
     37c:	ab01      	add	r3, sp, #4
     37e:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     380:	0014      	movs	r4, r2
     382:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     384:	4a06      	ldr	r2, [pc, #24]	; (3a0 <i2c_m_sync_read+0x2c>)
     386:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
     388:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     38a:	0019      	movs	r1, r3
     38c:	4b05      	ldr	r3, [pc, #20]	; (3a4 <i2c_m_sync_read+0x30>)
     38e:	4798      	blx	r3
	if (ret) {
     390:	2800      	cmp	r0, #0
     392:	d102      	bne.n	39a <i2c_m_sync_read+0x26>
}
     394:	0020      	movs	r0, r4
     396:	b004      	add	sp, #16
     398:	bd10      	pop	{r4, pc}
		return ret;
     39a:	0004      	movs	r4, r0
     39c:	e7fa      	b.n	394 <i2c_m_sync_read+0x20>
     39e:	46c0      	nop			; (mov r8, r8)
     3a0:	ffff8001 	.word	0xffff8001
     3a4:	00000ba5 	.word	0x00000ba5

000003a8 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
     3a8:	b570      	push	{r4, r5, r6, lr}
     3aa:	0004      	movs	r4, r0
     3ac:	000d      	movs	r5, r1
	int32_t init_status;
	ASSERT(i2c);
     3ae:	1e43      	subs	r3, r0, #1
     3b0:	4198      	sbcs	r0, r3
     3b2:	b2c0      	uxtb	r0, r0
     3b4:	225e      	movs	r2, #94	; 0x5e
     3b6:	4907      	ldr	r1, [pc, #28]	; (3d4 <i2c_m_sync_init+0x2c>)
     3b8:	4b07      	ldr	r3, [pc, #28]	; (3d8 <i2c_m_sync_init+0x30>)
     3ba:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
     3bc:	0029      	movs	r1, r5
     3be:	0020      	movs	r0, r4
     3c0:	4b06      	ldr	r3, [pc, #24]	; (3dc <i2c_m_sync_init+0x34>)
     3c2:	4798      	blx	r3
	if (init_status) {
     3c4:	2800      	cmp	r0, #0
     3c6:	d103      	bne.n	3d0 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
     3c8:	4b05      	ldr	r3, [pc, #20]	; (3e0 <i2c_m_sync_init+0x38>)
     3ca:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
     3cc:	4b05      	ldr	r3, [pc, #20]	; (3e4 <i2c_m_sync_init+0x3c>)
     3ce:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
     3d0:	bd70      	pop	{r4, r5, r6, pc}
     3d2:	46c0      	nop			; (mov r8, r8)
     3d4:	00002cc0 	.word	0x00002cc0
     3d8:	00000601 	.word	0x00000601
     3dc:	00000a81 	.word	0x00000a81
     3e0:	00000375 	.word	0x00000375
     3e4:	00000341 	.word	0x00000341

000003e8 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
     3e8:	b510      	push	{r4, lr}
	return _i2c_m_sync_enable(&i2c->device);
     3ea:	4b01      	ldr	r3, [pc, #4]	; (3f0 <i2c_m_sync_enable+0x8>)
     3ec:	4798      	blx	r3
}
     3ee:	bd10      	pop	{r4, pc}
     3f0:	00000b2d 	.word	0x00000b2d

000003f4 <i2c_m_sync_set_slaveaddr>:
/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
     3f4:	0589      	lsls	r1, r1, #22
     3f6:	0d89      	lsrs	r1, r1, #22
     3f8:	2380      	movs	r3, #128	; 0x80
     3fa:	00db      	lsls	r3, r3, #3
     3fc:	401a      	ands	r2, r3
     3fe:	430a      	orrs	r2, r1
     400:	8382      	strh	r2, [r0, #28]
}
     402:	0010      	movs	r0, r2
     404:	4770      	bx	lr
	...

00000408 <i2c_m_sync_cmd_read>:

/**
 * \brief Sync version of i2c read command
 */
int32_t i2c_m_sync_cmd_read(struct i2c_m_sync_desc *i2c, uint8_t reg, uint8_t *buffer, uint8_t length)
{
     408:	b570      	push	{r4, r5, r6, lr}
     40a:	b086      	sub	sp, #24
     40c:	0004      	movs	r4, r0
     40e:	0016      	movs	r6, r2
     410:	001d      	movs	r5, r3
     412:	466b      	mov	r3, sp
     414:	71d9      	strb	r1, [r3, #7]
     416:	3307      	adds	r3, #7
	struct _i2c_m_msg msg;
	int32_t           ret;

	msg.addr   = i2c->slave_addr;
     418:	8b82      	ldrh	r2, [r0, #28]
     41a:	a903      	add	r1, sp, #12
     41c:	800a      	strh	r2, [r1, #0]
	msg.len    = 1;
     41e:	2201      	movs	r2, #1
     420:	604a      	str	r2, [r1, #4]
	msg.flags  = 0;
     422:	2200      	movs	r2, #0
     424:	804a      	strh	r2, [r1, #2]
	msg.buffer = &reg;
     426:	608b      	str	r3, [r1, #8]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     428:	4b07      	ldr	r3, [pc, #28]	; (448 <i2c_m_sync_cmd_read+0x40>)
     42a:	4798      	blx	r3

	if (ret != 0) {
     42c:	2800      	cmp	r0, #0
     42e:	d001      	beq.n	434 <i2c_m_sync_cmd_read+0x2c>
		/* error occurred */
		return ret;
	}

	return ERR_NONE;
}
     430:	b006      	add	sp, #24
     432:	bd70      	pop	{r4, r5, r6, pc}
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     434:	a903      	add	r1, sp, #12
     436:	4b05      	ldr	r3, [pc, #20]	; (44c <i2c_m_sync_cmd_read+0x44>)
     438:	804b      	strh	r3, [r1, #2]
	msg.buffer = buffer;
     43a:	608e      	str	r6, [r1, #8]
	msg.len    = length;
     43c:	604d      	str	r5, [r1, #4]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     43e:	0020      	movs	r0, r4
     440:	4b01      	ldr	r3, [pc, #4]	; (448 <i2c_m_sync_cmd_read+0x40>)
     442:	4798      	blx	r3
     444:	e7f4      	b.n	430 <i2c_m_sync_cmd_read+0x28>
     446:	46c0      	nop			; (mov r8, r8)
     448:	00000ba5 	.word	0x00000ba5
     44c:	ffff8001 	.word	0xffff8001

00000450 <i2c_m_sync_get_io_descriptor>:
/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
	*io = &i2c->io;
     450:	3014      	adds	r0, #20
     452:	6008      	str	r0, [r1, #0]
	return ERR_NONE;
}
     454:	2000      	movs	r0, #0
     456:	4770      	bx	lr

00000458 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     458:	b570      	push	{r4, r5, r6, lr}
     45a:	0004      	movs	r4, r0
     45c:	000d      	movs	r5, r1
     45e:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
     460:	2800      	cmp	r0, #0
     462:	d00e      	beq.n	482 <io_write+0x2a>
     464:	2900      	cmp	r1, #0
     466:	d00a      	beq.n	47e <io_write+0x26>
     468:	2001      	movs	r0, #1
     46a:	2234      	movs	r2, #52	; 0x34
     46c:	4906      	ldr	r1, [pc, #24]	; (488 <io_write+0x30>)
     46e:	4b07      	ldr	r3, [pc, #28]	; (48c <io_write+0x34>)
     470:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     472:	6823      	ldr	r3, [r4, #0]
     474:	0032      	movs	r2, r6
     476:	0029      	movs	r1, r5
     478:	0020      	movs	r0, r4
     47a:	4798      	blx	r3
}
     47c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
     47e:	2000      	movs	r0, #0
     480:	e7f3      	b.n	46a <io_write+0x12>
     482:	2000      	movs	r0, #0
     484:	e7f1      	b.n	46a <io_write+0x12>
     486:	46c0      	nop			; (mov r8, r8)
     488:	00002cdc 	.word	0x00002cdc
     48c:	00000601 	.word	0x00000601

00000490 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
     490:	b570      	push	{r4, r5, r6, lr}
     492:	0004      	movs	r4, r0
     494:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
     496:	2800      	cmp	r0, #0
     498:	d017      	beq.n	4ca <spi_m_sync_init+0x3a>
     49a:	2900      	cmp	r1, #0
     49c:	d013      	beq.n	4c6 <spi_m_sync_init+0x36>
     49e:	2001      	movs	r0, #1
     4a0:	2240      	movs	r2, #64	; 0x40
     4a2:	490b      	ldr	r1, [pc, #44]	; (4d0 <spi_m_sync_init+0x40>)
     4a4:	4b0b      	ldr	r3, [pc, #44]	; (4d4 <spi_m_sync_init+0x44>)
     4a6:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
     4a8:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
     4aa:	1d20      	adds	r0, r4, #4
     4ac:	0029      	movs	r1, r5
     4ae:	4b0a      	ldr	r3, [pc, #40]	; (4d8 <spi_m_sync_init+0x48>)
     4b0:	4798      	blx	r3

	if (rc < 0) {
     4b2:	2800      	cmp	r0, #0
     4b4:	db06      	blt.n	4c4 <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
     4b6:	4b09      	ldr	r3, [pc, #36]	; (4dc <spi_m_sync_init+0x4c>)
     4b8:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
     4ba:	4b09      	ldr	r3, [pc, #36]	; (4e0 <spi_m_sync_init+0x50>)
     4bc:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
     4be:	4b09      	ldr	r3, [pc, #36]	; (4e4 <spi_m_sync_init+0x54>)
     4c0:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
     4c2:	2000      	movs	r0, #0
}
     4c4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
     4c6:	2000      	movs	r0, #0
     4c8:	e7ea      	b.n	4a0 <spi_m_sync_init+0x10>
     4ca:	2000      	movs	r0, #0
     4cc:	e7e8      	b.n	4a0 <spi_m_sync_init+0x10>
     4ce:	46c0      	nop			; (mov r8, r8)
     4d0:	00002cf0 	.word	0x00002cf0
     4d4:	00000601 	.word	0x00000601
     4d8:	00000dc1 	.word	0x00000dc1
     4dc:	ffff8000 	.word	0xffff8000
     4e0:	00000595 	.word	0x00000595
     4e4:	00000559 	.word	0x00000559

000004e8 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
     4e8:	b510      	push	{r4, lr}
     4ea:	0004      	movs	r4, r0
	ASSERT(spi);
     4ec:	1e43      	subs	r3, r0, #1
     4ee:	4198      	sbcs	r0, r3
     4f0:	b2c0      	uxtb	r0, r0
     4f2:	2257      	movs	r2, #87	; 0x57
     4f4:	4903      	ldr	r1, [pc, #12]	; (504 <spi_m_sync_enable+0x1c>)
     4f6:	4b04      	ldr	r3, [pc, #16]	; (508 <spi_m_sync_enable+0x20>)
     4f8:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
     4fa:	1d20      	adds	r0, r4, #4
     4fc:	4b03      	ldr	r3, [pc, #12]	; (50c <spi_m_sync_enable+0x24>)
     4fe:	4798      	blx	r3
}
     500:	bd10      	pop	{r4, pc}
     502:	46c0      	nop			; (mov r8, r8)
     504:	00002cf0 	.word	0x00002cf0
     508:	00000601 	.word	0x00000601
     50c:	00000f79 	.word	0x00000f79

00000510 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
     510:	b530      	push	{r4, r5, lr}
     512:	b087      	sub	sp, #28
     514:	0004      	movs	r4, r0
     516:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
     518:	2800      	cmp	r0, #0
     51a:	d015      	beq.n	548 <spi_m_sync_transfer+0x38>
     51c:	2900      	cmp	r1, #0
     51e:	d011      	beq.n	544 <spi_m_sync_transfer+0x34>
     520:	2001      	movs	r0, #1
     522:	22b3      	movs	r2, #179	; 0xb3
     524:	4909      	ldr	r1, [pc, #36]	; (54c <spi_m_sync_transfer+0x3c>)
     526:	4b0a      	ldr	r3, [pc, #40]	; (550 <spi_m_sync_transfer+0x40>)
     528:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
     52a:	682b      	ldr	r3, [r5, #0]
     52c:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
     52e:	686b      	ldr	r3, [r5, #4]
     530:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
     532:	68ab      	ldr	r3, [r5, #8]
     534:	9301      	str	r3, [sp, #4]
     536:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
     538:	1d20      	adds	r0, r4, #4
     53a:	a903      	add	r1, sp, #12
     53c:	4b05      	ldr	r3, [pc, #20]	; (554 <spi_m_sync_transfer+0x44>)
     53e:	4798      	blx	r3
}
     540:	b007      	add	sp, #28
     542:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
     544:	2000      	movs	r0, #0
     546:	e7ec      	b.n	522 <spi_m_sync_transfer+0x12>
     548:	2000      	movs	r0, #0
     54a:	e7ea      	b.n	522 <spi_m_sync_transfer+0x12>
     54c:	00002cf0 	.word	0x00002cf0
     550:	00000601 	.word	0x00000601
     554:	00000fb1 	.word	0x00000fb1

00000558 <_spi_m_sync_io_write>:
{
     558:	b570      	push	{r4, r5, r6, lr}
     55a:	b084      	sub	sp, #16
     55c:	0004      	movs	r4, r0
     55e:	000e      	movs	r6, r1
     560:	0015      	movs	r5, r2
	ASSERT(io);
     562:	1e43      	subs	r3, r0, #1
     564:	4198      	sbcs	r0, r3
     566:	b2c0      	uxtb	r0, r0
     568:	22a3      	movs	r2, #163	; 0xa3
     56a:	4907      	ldr	r1, [pc, #28]	; (588 <_spi_m_sync_io_write+0x30>)
     56c:	4b07      	ldr	r3, [pc, #28]	; (58c <_spi_m_sync_io_write+0x34>)
     56e:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     570:	0020      	movs	r0, r4
     572:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
     574:	2300      	movs	r3, #0
     576:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
     578:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
     57a:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     57c:	a901      	add	r1, sp, #4
     57e:	4b04      	ldr	r3, [pc, #16]	; (590 <_spi_m_sync_io_write+0x38>)
     580:	4798      	blx	r3
}
     582:	b004      	add	sp, #16
     584:	bd70      	pop	{r4, r5, r6, pc}
     586:	46c0      	nop			; (mov r8, r8)
     588:	00002cf0 	.word	0x00002cf0
     58c:	00000601 	.word	0x00000601
     590:	00000511 	.word	0x00000511

00000594 <_spi_m_sync_io_read>:
{
     594:	b570      	push	{r4, r5, r6, lr}
     596:	b084      	sub	sp, #16
     598:	0004      	movs	r4, r0
     59a:	000e      	movs	r6, r1
     59c:	0015      	movs	r5, r2
	ASSERT(io);
     59e:	1e43      	subs	r3, r0, #1
     5a0:	4198      	sbcs	r0, r3
     5a2:	b2c0      	uxtb	r0, r0
     5a4:	2287      	movs	r2, #135	; 0x87
     5a6:	4907      	ldr	r1, [pc, #28]	; (5c4 <_spi_m_sync_io_read+0x30>)
     5a8:	4b07      	ldr	r3, [pc, #28]	; (5c8 <_spi_m_sync_io_read+0x34>)
     5aa:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     5ac:	0020      	movs	r0, r4
     5ae:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
     5b0:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
     5b2:	2300      	movs	r3, #0
     5b4:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
     5b6:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     5b8:	a901      	add	r1, sp, #4
     5ba:	4b04      	ldr	r3, [pc, #16]	; (5cc <_spi_m_sync_io_read+0x38>)
     5bc:	4798      	blx	r3
}
     5be:	b004      	add	sp, #16
     5c0:	bd70      	pop	{r4, r5, r6, pc}
     5c2:	46c0      	nop			; (mov r8, r8)
     5c4:	00002cf0 	.word	0x00002cf0
     5c8:	00000601 	.word	0x00000601
     5cc:	00000511 	.word	0x00000511

000005d0 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
     5d0:	b570      	push	{r4, r5, r6, lr}
     5d2:	0004      	movs	r4, r0
     5d4:	000d      	movs	r5, r1
	ASSERT(spi && io);
     5d6:	2800      	cmp	r0, #0
     5d8:	d00c      	beq.n	5f4 <spi_m_sync_get_io_descriptor+0x24>
     5da:	2900      	cmp	r1, #0
     5dc:	d008      	beq.n	5f0 <spi_m_sync_get_io_descriptor+0x20>
     5de:	2001      	movs	r0, #1
     5e0:	22bd      	movs	r2, #189	; 0xbd
     5e2:	4905      	ldr	r1, [pc, #20]	; (5f8 <spi_m_sync_get_io_descriptor+0x28>)
     5e4:	4b05      	ldr	r3, [pc, #20]	; (5fc <spi_m_sync_get_io_descriptor+0x2c>)
     5e6:	4798      	blx	r3
	*io = &spi->io;
     5e8:	340c      	adds	r4, #12
     5ea:	602c      	str	r4, [r5, #0]
	return 0;
}
     5ec:	2000      	movs	r0, #0
     5ee:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && io);
     5f0:	2000      	movs	r0, #0
     5f2:	e7f5      	b.n	5e0 <spi_m_sync_get_io_descriptor+0x10>
     5f4:	2000      	movs	r0, #0
     5f6:	e7f3      	b.n	5e0 <spi_m_sync_get_io_descriptor+0x10>
     5f8:	00002cf0 	.word	0x00002cf0
     5fc:	00000601 	.word	0x00000601

00000600 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     600:	2800      	cmp	r0, #0
     602:	d100      	bne.n	606 <assert+0x6>
		__asm("BKPT #0");
     604:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     606:	4770      	bx	lr

00000608 <_get_cycles_for_ms>:
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
	switch (power) {
	case 8:
		return (ms * (freq / 100000)) * 100;
     608:	0103      	lsls	r3, r0, #4
     60a:	1a1b      	subs	r3, r3, r0
     60c:	015a      	lsls	r2, r3, #5
     60e:	2064      	movs	r0, #100	; 0x64
     610:	4350      	muls	r0, r2
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
     612:	4770      	bx	lr

00000614 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     614:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
     616:	4a08      	ldr	r2, [pc, #32]	; (638 <_init_chip+0x24>)
     618:	6853      	ldr	r3, [r2, #4]
     61a:	2106      	movs	r1, #6
     61c:	430b      	orrs	r3, r1
     61e:	6053      	str	r3, [r2, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
     620:	4b06      	ldr	r3, [pc, #24]	; (63c <_init_chip+0x28>)
     622:	4798      	blx	r3
	_sysctrl_init_sources();
     624:	4b06      	ldr	r3, [pc, #24]	; (640 <_init_chip+0x2c>)
     626:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
     628:	2008      	movs	r0, #8
     62a:	4c06      	ldr	r4, [pc, #24]	; (644 <_init_chip+0x30>)
     62c:	47a0      	blx	r4
#endif
	_sysctrl_init_referenced_generators();
     62e:	4b06      	ldr	r3, [pc, #24]	; (648 <_init_chip+0x34>)
     630:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     632:	20f7      	movs	r0, #247	; 0xf7
     634:	47a0      	blx	r4
}
     636:	bd10      	pop	{r4, pc}
     638:	41004000 	.word	0x41004000
     63c:	00000855 	.word	0x00000855
     640:	00001099 	.word	0x00001099
     644:	000007f9 	.word	0x000007f9
     648:	000010cd 	.word	0x000010cd

0000064c <_ext_irq_init>:
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     64c:	4b23      	ldr	r3, [pc, #140]	; (6dc <_ext_irq_init+0x90>)
     64e:	785b      	ldrb	r3, [r3, #1]
     650:	09db      	lsrs	r3, r3, #7
     652:	d1fb      	bne.n	64c <_ext_irq_init>
     654:	4b21      	ldr	r3, [pc, #132]	; (6dc <_ext_irq_init+0x90>)
     656:	785b      	ldrb	r3, [r3, #1]
     658:	09db      	lsrs	r3, r3, #7
     65a:	d1fb      	bne.n	654 <_ext_irq_init+0x8>

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
	tmp = ((Eic *)hw)->CTRL.reg;
     65c:	4b1f      	ldr	r3, [pc, #124]	; (6dc <_ext_irq_init+0x90>)
     65e:	781b      	ldrb	r3, [r3, #0]
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
	hri_eic_wait_for_sync(EIC);
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
     660:	079b      	lsls	r3, r3, #30
     662:	d50a      	bpl.n	67a <_ext_irq_init+0x2e>
}

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
     664:	2200      	movs	r2, #0
     666:	4b1d      	ldr	r3, [pc, #116]	; (6dc <_ext_irq_init+0x90>)
     668:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     66a:	4b1c      	ldr	r3, [pc, #112]	; (6dc <_ext_irq_init+0x90>)
     66c:	785b      	ldrb	r3, [r3, #1]
     66e:	09db      	lsrs	r3, r3, #7
     670:	d1fb      	bne.n	66a <_ext_irq_init+0x1e>
     672:	4b1a      	ldr	r3, [pc, #104]	; (6dc <_ext_irq_init+0x90>)
     674:	785b      	ldrb	r3, [r3, #1]
     676:	09db      	lsrs	r3, r3, #7
     678:	d1fb      	bne.n	672 <_ext_irq_init+0x26>
	((Eic *)hw)->CTRL.reg = data;
     67a:	2201      	movs	r2, #1
     67c:	4b17      	ldr	r3, [pc, #92]	; (6dc <_ext_irq_init+0x90>)
     67e:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     680:	4b16      	ldr	r3, [pc, #88]	; (6dc <_ext_irq_init+0x90>)
     682:	785b      	ldrb	r3, [r3, #1]
     684:	09db      	lsrs	r3, r3, #7
     686:	d1fb      	bne.n	680 <_ext_irq_init+0x34>
     688:	4b14      	ldr	r3, [pc, #80]	; (6dc <_ext_irq_init+0x90>)
     68a:	785b      	ldrb	r3, [r3, #1]
     68c:	09db      	lsrs	r3, r3, #7
     68e:	d1fb      	bne.n	688 <_ext_irq_init+0x3c>
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
     690:	4b12      	ldr	r3, [pc, #72]	; (6dc <_ext_irq_init+0x90>)
     692:	2200      	movs	r2, #0
     694:	709a      	strb	r2, [r3, #2]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
     696:	605a      	str	r2, [r3, #4]
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
     698:	2282      	movs	r2, #130	; 0x82
     69a:	0192      	lsls	r2, r2, #6
     69c:	615a      	str	r2, [r3, #20]
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
     69e:	2280      	movs	r2, #128	; 0x80
     6a0:	0552      	lsls	r2, r2, #21
     6a2:	619a      	str	r2, [r3, #24]
     6a4:	2280      	movs	r2, #128	; 0x80
     6a6:	0392      	lsls	r2, r2, #14
     6a8:	61da      	str	r2, [r3, #28]
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
     6aa:	781a      	ldrb	r2, [r3, #0]
     6ac:	2102      	movs	r1, #2
     6ae:	430a      	orrs	r2, r1
     6b0:	b2d2      	uxtb	r2, r2
     6b2:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     6b4:	4b09      	ldr	r3, [pc, #36]	; (6dc <_ext_irq_init+0x90>)
     6b6:	785b      	ldrb	r3, [r3, #1]
     6b8:	09db      	lsrs	r3, r3, #7
     6ba:	d1fb      	bne.n	6b4 <_ext_irq_init+0x68>
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     6bc:	4b08      	ldr	r3, [pc, #32]	; (6e0 <_ext_irq_init+0x94>)
     6be:	2210      	movs	r2, #16
     6c0:	2180      	movs	r1, #128	; 0x80
     6c2:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
     6c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     6c8:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     6cc:	3101      	adds	r1, #1
     6ce:	31ff      	adds	r1, #255	; 0xff
     6d0:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     6d2:	601a      	str	r2, [r3, #0]

	NVIC_DisableIRQ(EIC_IRQn);
	NVIC_ClearPendingIRQ(EIC_IRQn);
	NVIC_EnableIRQ(EIC_IRQn);

	callback = cb;
     6d4:	4b03      	ldr	r3, [pc, #12]	; (6e4 <_ext_irq_init+0x98>)
     6d6:	6018      	str	r0, [r3, #0]

	return ERR_NONE;
}
     6d8:	2000      	movs	r0, #0
     6da:	4770      	bx	lr
     6dc:	40001800 	.word	0x40001800
     6e0:	e000e100 	.word	0xe000e100
     6e4:	20000048 	.word	0x20000048

000006e8 <_ext_irq_enable>:

/**
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
     6e8:	b530      	push	{r4, r5, lr}
	uint8_t extint = INVALID_EXTINT_NUMBER;
	uint8_t i      = 0;
     6ea:	2300      	movs	r3, #0

	for (; i < ARRAY_SIZE(_map); i++) {
     6ec:	2b01      	cmp	r3, #1
     6ee:	d80b      	bhi.n	708 <_ext_irq_enable+0x20>
		if (_map[i].pin == pin) {
     6f0:	00dc      	lsls	r4, r3, #3
     6f2:	4a10      	ldr	r2, [pc, #64]	; (734 <_ext_irq_enable+0x4c>)
     6f4:	1912      	adds	r2, r2, r4
     6f6:	6852      	ldr	r2, [r2, #4]
     6f8:	4282      	cmp	r2, r0
     6fa:	d002      	beq.n	702 <_ext_irq_enable+0x1a>
	for (; i < ARRAY_SIZE(_map); i++) {
     6fc:	3301      	adds	r3, #1
     6fe:	b2db      	uxtb	r3, r3
     700:	e7f4      	b.n	6ec <_ext_irq_enable+0x4>
			extint = _map[i].extint;
     702:	4b0c      	ldr	r3, [pc, #48]	; (734 <_ext_irq_enable+0x4c>)
     704:	5ce2      	ldrb	r2, [r4, r3]
			break;
     706:	e000      	b.n	70a <_ext_irq_enable+0x22>
	uint8_t extint = INVALID_EXTINT_NUMBER;
     708:	22ff      	movs	r2, #255	; 0xff
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
     70a:	2aff      	cmp	r2, #255	; 0xff
     70c:	d00e      	beq.n	72c <_ext_irq_enable+0x44>
		return ERR_INVALID_ARG;
	}

	if (enable) {
     70e:	2900      	cmp	r1, #0
     710:	d106      	bne.n	720 <_ext_irq_enable+0x38>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
     712:	2301      	movs	r3, #1
     714:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENCLR.reg = mask;
     716:	4a08      	ldr	r2, [pc, #32]	; (738 <_ext_irq_enable+0x50>)
     718:	6093      	str	r3, [r2, #8]
	((Eic *)hw)->INTFLAG.reg = mask;
     71a:	6113      	str	r3, [r2, #16]
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
	}

	return ERR_NONE;
     71c:	2000      	movs	r0, #0
}
     71e:	bd30      	pop	{r4, r5, pc}
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
     720:	2301      	movs	r3, #1
     722:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENSET.reg = mask;
     724:	4a04      	ldr	r2, [pc, #16]	; (738 <_ext_irq_enable+0x50>)
     726:	60d3      	str	r3, [r2, #12]
	return ERR_NONE;
     728:	2000      	movs	r0, #0
     72a:	e7f8      	b.n	71e <_ext_irq_enable+0x36>
		return ERR_INVALID_ARG;
     72c:	200d      	movs	r0, #13
     72e:	4240      	negs	r0, r0
     730:	e7f5      	b.n	71e <_ext_irq_enable+0x36>
     732:	46c0      	nop			; (mov r8, r8)
     734:	00002d24 	.word	0x00002d24
     738:	40001800 	.word	0x40001800

0000073c <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
     73c:	b5f0      	push	{r4, r5, r6, r7, lr}
     73e:	b083      	sub	sp, #12
	return ((Eic *)hw)->INTFLAG.reg;
     740:	4b27      	ldr	r3, [pc, #156]	; (7e0 <EIC_Handler+0xa4>)
     742:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     744:	68d9      	ldr	r1, [r3, #12]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     746:	400a      	ands	r2, r1
     748:	9201      	str	r2, [sp, #4]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;

	hri_eic_clear_INTFLAG_reg(EIC, flags);
     74a:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     74c:	611a      	str	r2, [r3, #16]

	ASSERT(callback);
     74e:	4b25      	ldr	r3, [pc, #148]	; (7e4 <EIC_Handler+0xa8>)
     750:	6818      	ldr	r0, [r3, #0]
     752:	1e43      	subs	r3, r0, #1
     754:	4198      	sbcs	r0, r3
     756:	b2c0      	uxtb	r0, r0
     758:	22d2      	movs	r2, #210	; 0xd2
     75a:	4923      	ldr	r1, [pc, #140]	; (7e8 <EIC_Handler+0xac>)
     75c:	4b23      	ldr	r3, [pc, #140]	; (7ec <EIC_Handler+0xb0>)
     75e:	4798      	blx	r3
	uint32_t          pin = INVALID_PIN_NUMBER;
     760:	2501      	movs	r5, #1
     762:	426d      	negs	r5, r5

	while (flags) {
     764:	e031      	b.n	7ca <EIC_Handler+0x8e>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;

			while (upper >= lower) {
				middle = (upper + lower) >> 1;
				if (_map[middle].extint == pos) {
					pin = _map[middle].pin;
     766:	00db      	lsls	r3, r3, #3
     768:	4a21      	ldr	r2, [pc, #132]	; (7f0 <EIC_Handler+0xb4>)
     76a:	18d3      	adds	r3, r2, r3
     76c:	685d      	ldr	r5, [r3, #4]
				} else {
					upper = middle - 1;
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
     76e:	1c6b      	adds	r3, r5, #1
     770:	d003      	beq.n	77a <EIC_Handler+0x3e>
				callback(pin);
     772:	4b1c      	ldr	r3, [pc, #112]	; (7e4 <EIC_Handler+0xa8>)
     774:	681b      	ldr	r3, [r3, #0]
     776:	0028      	movs	r0, r5
     778:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
     77a:	2201      	movs	r2, #1
     77c:	40a2      	lsls	r2, r4
     77e:	9b01      	ldr	r3, [sp, #4]
     780:	4393      	bics	r3, r2
     782:	9301      	str	r3, [sp, #4]
			pos = ffs(flags) - 1;
     784:	9801      	ldr	r0, [sp, #4]
     786:	4b1b      	ldr	r3, [pc, #108]	; (7f4 <EIC_Handler+0xb8>)
     788:	4798      	blx	r3
     78a:	3801      	subs	r0, #1
     78c:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     78e:	1c63      	adds	r3, r4, #1
     790:	d014      	beq.n	7bc <EIC_Handler+0x80>
     792:	2602      	movs	r6, #2
     794:	2000      	movs	r0, #0
     796:	e001      	b.n	79c <EIC_Handler+0x60>
					upper = middle - 1;
     798:	3901      	subs	r1, #1
     79a:	b2ce      	uxtb	r6, r1
			while (upper >= lower) {
     79c:	42b0      	cmp	r0, r6
     79e:	d8e6      	bhi.n	76e <EIC_Handler+0x32>
				middle = (upper + lower) >> 1;
     7a0:	1833      	adds	r3, r6, r0
     7a2:	105b      	asrs	r3, r3, #1
     7a4:	b2d9      	uxtb	r1, r3
     7a6:	22ff      	movs	r2, #255	; 0xff
     7a8:	4013      	ands	r3, r2
				if (_map[middle].extint == pos) {
     7aa:	00df      	lsls	r7, r3, #3
     7ac:	4a10      	ldr	r2, [pc, #64]	; (7f0 <EIC_Handler+0xb4>)
     7ae:	5cba      	ldrb	r2, [r7, r2]
     7b0:	42a2      	cmp	r2, r4
     7b2:	d0d8      	beq.n	766 <EIC_Handler+0x2a>
				if (_map[middle].extint < pos) {
     7b4:	daf0      	bge.n	798 <EIC_Handler+0x5c>
					lower = middle + 1;
     7b6:	3101      	adds	r1, #1
     7b8:	b2c8      	uxtb	r0, r1
     7ba:	e7ef      	b.n	79c <EIC_Handler+0x60>
	return ((Eic *)hw)->INTFLAG.reg;
     7bc:	4b08      	ldr	r3, [pc, #32]	; (7e0 <EIC_Handler+0xa4>)
     7be:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     7c0:	68d9      	ldr	r1, [r3, #12]
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     7c2:	400a      	ands	r2, r1
     7c4:	9201      	str	r2, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
     7c6:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     7c8:	611a      	str	r2, [r3, #16]
	while (flags) {
     7ca:	9b01      	ldr	r3, [sp, #4]
     7cc:	2b00      	cmp	r3, #0
     7ce:	d005      	beq.n	7dc <EIC_Handler+0xa0>
		pos = ffs(flags) - 1;
     7d0:	9801      	ldr	r0, [sp, #4]
     7d2:	4b08      	ldr	r3, [pc, #32]	; (7f4 <EIC_Handler+0xb8>)
     7d4:	4798      	blx	r3
     7d6:	3801      	subs	r0, #1
     7d8:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     7da:	e7d8      	b.n	78e <EIC_Handler+0x52>
	}
}
     7dc:	b003      	add	sp, #12
     7de:	bdf0      	pop	{r4, r5, r6, r7, pc}
     7e0:	40001800 	.word	0x40001800
     7e4:	20000048 	.word	0x20000048
     7e8:	00002d0c 	.word	0x00002d0c
     7ec:	00000601 	.word	0x00000601
     7f0:	00002d24 	.word	0x00002d24
     7f4:	00002c15 	.word	0x00002c15

000007f8 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     7f8:	07c3      	lsls	r3, r0, #31
     7fa:	d509      	bpl.n	810 <_gclk_init_generators_by_fref+0x18>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
     7fc:	4b11      	ldr	r3, [pc, #68]	; (844 <_gclk_init_generators_by_fref+0x4c>)
     7fe:	2280      	movs	r2, #128	; 0x80
     800:	0052      	lsls	r2, r2, #1
     802:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     804:	4a10      	ldr	r2, [pc, #64]	; (848 <_gclk_init_generators_by_fref+0x50>)
     806:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     808:	4b0e      	ldr	r3, [pc, #56]	; (844 <_gclk_init_generators_by_fref+0x4c>)
     80a:	785b      	ldrb	r3, [r3, #1]
     80c:	09db      	lsrs	r3, r3, #7
     80e:	d1fb      	bne.n	808 <_gclk_init_generators_by_fref+0x10>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SRC | GCLK_GENCTRL_ID(0));
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
     810:	0783      	lsls	r3, r0, #30
     812:	d509      	bpl.n	828 <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENDIV.reg = data;
     814:	4b0b      	ldr	r3, [pc, #44]	; (844 <_gclk_init_generators_by_fref+0x4c>)
     816:	2202      	movs	r2, #2
     818:	32ff      	adds	r2, #255	; 0xff
     81a:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     81c:	4a0b      	ldr	r2, [pc, #44]	; (84c <_gclk_init_generators_by_fref+0x54>)
     81e:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     820:	4b08      	ldr	r3, [pc, #32]	; (844 <_gclk_init_generators_by_fref+0x4c>)
     822:	785b      	ldrb	r3, [r3, #1]
     824:	09db      	lsrs	r3, r3, #7
     826:	d1fb      	bne.n	820 <_gclk_init_generators_by_fref+0x28>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
     828:	0703      	lsls	r3, r0, #28
     82a:	d509      	bpl.n	840 <_gclk_init_generators_by_fref+0x48>
	((Gclk *)hw)->GENDIV.reg = data;
     82c:	4b05      	ldr	r3, [pc, #20]	; (844 <_gclk_init_generators_by_fref+0x4c>)
     82e:	2204      	movs	r2, #4
     830:	32ff      	adds	r2, #255	; 0xff
     832:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     834:	4a06      	ldr	r2, [pc, #24]	; (850 <_gclk_init_generators_by_fref+0x58>)
     836:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     838:	4b02      	ldr	r3, [pc, #8]	; (844 <_gclk_init_generators_by_fref+0x4c>)
     83a:	785b      	ldrb	r3, [r3, #1]
     83c:	09db      	lsrs	r3, r3, #7
     83e:	d1fb      	bne.n	838 <_gclk_init_generators_by_fref+0x40>
		        | (CONF_GCLK_GEN_7_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_7_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_7_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_7_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_7_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
	}
#endif
}
     840:	4770      	bx	lr
     842:	46c0      	nop			; (mov r8, r8)
     844:	40000c00 	.word	0x40000c00
     848:	00090700 	.word	0x00090700
     84c:	00290301 	.word	0x00290301
     850:	00090303 	.word	0x00090303

00000854 <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
     854:	4b06      	ldr	r3, [pc, #24]	; (870 <_pm_init+0x1c>)
     856:	7a1a      	ldrb	r2, [r3, #8]
     858:	b2d2      	uxtb	r2, r2
     85a:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
     85c:	7a5a      	ldrb	r2, [r3, #9]
     85e:	b2d2      	uxtb	r2, r2
     860:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
     862:	7a9a      	ldrb	r2, [r3, #10]
     864:	b2d2      	uxtb	r2, r2
     866:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
     868:	7ada      	ldrb	r2, [r3, #11]
     86a:	b2d2      	uxtb	r2, r2
     86c:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
     86e:	4770      	bx	lr
     870:	40000400 	.word	0x40000400

00000874 <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
     874:	4b02      	ldr	r3, [pc, #8]	; (880 <_sercom_get_hardware_index+0xc>)
     876:	469c      	mov	ip, r3
     878:	4460      	add	r0, ip
     87a:	0a80      	lsrs	r0, r0, #10
     87c:	b2c0      	uxtb	r0, r0
}
     87e:	4770      	bx	lr
     880:	bdfff800 	.word	0xbdfff800

00000884 <_spi_sync_enable>:
		;
}

static inline bool hri_sercomspi_is_syncing(const void *const hw)
{
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
     884:	8a03      	ldrh	r3, [r0, #16]
     886:	0bdb      	lsrs	r3, r3, #15
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw)) {
     888:	d108      	bne.n	89c <_spi_sync_enable+0x18>
}

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
     88a:	6803      	ldr	r3, [r0, #0]
     88c:	2202      	movs	r2, #2
     88e:	4313      	orrs	r3, r2
     890:	6003      	str	r3, [r0, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     892:	8a03      	ldrh	r3, [r0, #16]
     894:	0bdb      	lsrs	r3, r3, #15
     896:	d1fc      	bne.n	892 <_spi_sync_enable+0xe>
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
     898:	2000      	movs	r0, #0
}
     89a:	4770      	bx	lr
		return ERR_BUSY;
     89c:	2004      	movs	r0, #4
     89e:	4240      	negs	r0, r0
     8a0:	e7fb      	b.n	89a <_spi_sync_enable+0x16>
	...

000008a4 <_get_i2cm_index>:
{
     8a4:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     8a6:	4b0b      	ldr	r3, [pc, #44]	; (8d4 <_get_i2cm_index+0x30>)
     8a8:	4798      	blx	r3
     8aa:	0002      	movs	r2, r0
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     8ac:	2000      	movs	r0, #0
     8ae:	2800      	cmp	r0, #0
     8b0:	d006      	beq.n	8c0 <_get_i2cm_index+0x1c>
	ASSERT(false);
     8b2:	4a09      	ldr	r2, [pc, #36]	; (8d8 <_get_i2cm_index+0x34>)
     8b4:	4909      	ldr	r1, [pc, #36]	; (8dc <_get_i2cm_index+0x38>)
     8b6:	2000      	movs	r0, #0
     8b8:	4b09      	ldr	r3, [pc, #36]	; (8e0 <_get_i2cm_index+0x3c>)
     8ba:	4798      	blx	r3
	return 0;
     8bc:	2000      	movs	r0, #0
}
     8be:	bd10      	pop	{r4, pc}
		if (_i2cms[i].number == sercom_offset) {
     8c0:	0043      	lsls	r3, r0, #1
     8c2:	181b      	adds	r3, r3, r0
     8c4:	00d9      	lsls	r1, r3, #3
     8c6:	4b07      	ldr	r3, [pc, #28]	; (8e4 <_get_i2cm_index+0x40>)
     8c8:	5ccb      	ldrb	r3, [r1, r3]
     8ca:	429a      	cmp	r2, r3
     8cc:	d0f7      	beq.n	8be <_get_i2cm_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     8ce:	3001      	adds	r0, #1
     8d0:	b2c0      	uxtb	r0, r0
     8d2:	e7ec      	b.n	8ae <_get_i2cm_index+0xa>
     8d4:	00000875 	.word	0x00000875
     8d8:	00000366 	.word	0x00000366
     8dc:	00002d34 	.word	0x00002d34
     8e0:	00000601 	.word	0x00000601
     8e4:	00002d50 	.word	0x00002d50

000008e8 <_sercom_i2c_sync_send_address>:
{
     8e8:	b570      	push	{r4, r5, r6, lr}
     8ea:	0005      	movs	r5, r0
	void *             hw  = i2c_dev->hw;
     8ec:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
     8ee:	1e43      	subs	r3, r0, #1
     8f0:	4198      	sbcs	r0, r3
     8f2:	b2c0      	uxtb	r0, r0
     8f4:	4a5c      	ldr	r2, [pc, #368]	; (a68 <_sercom_i2c_sync_send_address+0x180>)
     8f6:	495d      	ldr	r1, [pc, #372]	; (a6c <_sercom_i2c_sync_send_address+0x184>)
     8f8:	4b5d      	ldr	r3, [pc, #372]	; (a70 <_sercom_i2c_sync_send_address+0x188>)
     8fa:	4798      	blx	r3
}

static inline void hri_sercomi2cm_clear_CTRLB_ACKACT_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     8fc:	6863      	ldr	r3, [r4, #4]
     8fe:	4a5d      	ldr	r2, [pc, #372]	; (a74 <_sercom_i2c_sync_send_address+0x18c>)
     900:	4013      	ands	r3, r2
     902:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     904:	8a23      	ldrh	r3, [r4, #16]
     906:	0bdb      	lsrs	r3, r3, #15
     908:	d1fc      	bne.n	904 <_sercom_i2c_sync_send_address+0x1c>
	hri_sercomi2cm_write_ADDR_reg(hw, ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0));
     90a:	882a      	ldrh	r2, [r5, #0]
     90c:	0052      	lsls	r2, r2, #1
     90e:	886b      	ldrh	r3, [r5, #2]
     910:	2101      	movs	r1, #1
     912:	400b      	ands	r3, r1
     914:	4313      	orrs	r3, r2
     916:	b2db      	uxtb	r3, r3
}

static inline void hri_sercomi2cm_write_ADDR_reg(const void *const hw, hri_sercomi2cm_addr_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.ADDR.reg = data;
     918:	7523      	strb	r3, [r4, #20]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     91a:	8a23      	ldrh	r3, [r4, #16]
     91c:	0bdb      	lsrs	r3, r3, #15
     91e:	d1fc      	bne.n	91a <_sercom_i2c_sync_send_address+0x32>
	void *   hw      = i2c_dev->hw;
     920:	692e      	ldr	r6, [r5, #16]
	uint32_t timeout = 65535;
     922:	4a55      	ldr	r2, [pc, #340]	; (a78 <_sercom_i2c_sync_send_address+0x190>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
     924:	7bb3      	ldrb	r3, [r6, #14]
     926:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
     928:	0018      	movs	r0, r3
		if (timeout-- == 0) {
     92a:	1e51      	subs	r1, r2, #1
     92c:	2a00      	cmp	r2, #0
     92e:	d002      	beq.n	936 <_sercom_i2c_sync_send_address+0x4e>
     930:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
     932:	079b      	lsls	r3, r3, #30
     934:	d0f6      	beq.n	924 <_sercom_i2c_sync_send_address+0x3c>
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     936:	8a23      	ldrh	r3, [r4, #16]
     938:	0bdb      	lsrs	r3, r3, #15
     93a:	d1fc      	bne.n	936 <_sercom_i2c_sync_send_address+0x4e>
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw);
	return ((Sercom *)hw)->I2CM.STATUS.reg;
     93c:	8a23      	ldrh	r3, [r4, #16]
     93e:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
     940:	07c2      	lsls	r2, r0, #31
     942:	d550      	bpl.n	9e6 <_sercom_i2c_sync_send_address+0xfe>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
     944:	079a      	lsls	r2, r3, #30
     946:	d510      	bpl.n	96a <_sercom_i2c_sync_send_address+0x82>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
     948:	2201      	movs	r2, #1
     94a:	73a2      	strb	r2, [r4, #14]
			msg->flags |= I2C_M_FAIL;
     94c:	886a      	ldrh	r2, [r5, #2]
     94e:	2180      	movs	r1, #128	; 0x80
     950:	0149      	lsls	r1, r1, #5
     952:	430a      	orrs	r2, r1
     954:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
     956:	886a      	ldrh	r2, [r5, #2]
     958:	4948      	ldr	r1, [pc, #288]	; (a7c <_sercom_i2c_sync_send_address+0x194>)
     95a:	400a      	ands	r2, r1
     95c:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
     95e:	07db      	lsls	r3, r3, #31
     960:	d400      	bmi.n	964 <_sercom_i2c_sync_send_address+0x7c>
     962:	e07c      	b.n	a5e <_sercom_i2c_sync_send_address+0x176>
				return I2C_ERR_BUS;
     964:	2005      	movs	r0, #5
     966:	4240      	negs	r0, r0
     968:	e063      	b.n	a32 <_sercom_i2c_sync_send_address+0x14a>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
     96a:	075b      	lsls	r3, r3, #29
     96c:	d40b      	bmi.n	986 <_sercom_i2c_sync_send_address+0x9e>
			if (msg->len == 0) {
     96e:	6868      	ldr	r0, [r5, #4]
     970:	2800      	cmp	r0, #0
     972:	d12d      	bne.n	9d0 <_sercom_i2c_sync_send_address+0xe8>
				if (msg->flags & I2C_M_STOP) {
     974:	886b      	ldrh	r3, [r5, #2]
     976:	b21b      	sxth	r3, r3
     978:	2b00      	cmp	r3, #0
     97a:	db20      	blt.n	9be <_sercom_i2c_sync_send_address+0xd6>
				msg->flags &= ~I2C_M_BUSY;
     97c:	886b      	ldrh	r3, [r5, #2]
     97e:	4a3f      	ldr	r2, [pc, #252]	; (a7c <_sercom_i2c_sync_send_address+0x194>)
     980:	4013      	ands	r3, r2
     982:	806b      	strh	r3, [r5, #2]
     984:	e055      	b.n	a32 <_sercom_i2c_sync_send_address+0x14a>
				if (msg->len > 0) {
     986:	686b      	ldr	r3, [r5, #4]
     988:	2b00      	cmp	r3, #0
     98a:	dd04      	ble.n	996 <_sercom_i2c_sync_send_address+0xae>
					msg->flags |= I2C_M_FAIL;
     98c:	886b      	ldrh	r3, [r5, #2]
     98e:	2280      	movs	r2, #128	; 0x80
     990:	0152      	lsls	r2, r2, #5
     992:	4313      	orrs	r3, r2
     994:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
     996:	886b      	ldrh	r3, [r5, #2]
     998:	b21b      	sxth	r3, r3
     99a:	2b00      	cmp	r3, #0
     99c:	db06      	blt.n	9ac <_sercom_i2c_sync_send_address+0xc4>
				msg->flags &= ~I2C_M_BUSY;
     99e:	886b      	ldrh	r3, [r5, #2]
     9a0:	4a36      	ldr	r2, [pc, #216]	; (a7c <_sercom_i2c_sync_send_address+0x194>)
     9a2:	4013      	ands	r3, r2
     9a4:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
     9a6:	2002      	movs	r0, #2
     9a8:	4240      	negs	r0, r0
     9aa:	e042      	b.n	a32 <_sercom_i2c_sync_send_address+0x14a>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     9ac:	6862      	ldr	r2, [r4, #4]
     9ae:	23c0      	movs	r3, #192	; 0xc0
     9b0:	029b      	lsls	r3, r3, #10
     9b2:	4313      	orrs	r3, r2
     9b4:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     9b6:	8a23      	ldrh	r3, [r4, #16]
     9b8:	0bdb      	lsrs	r3, r3, #15
     9ba:	d1fc      	bne.n	9b6 <_sercom_i2c_sync_send_address+0xce>
     9bc:	e7ef      	b.n	99e <_sercom_i2c_sync_send_address+0xb6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     9be:	6862      	ldr	r2, [r4, #4]
     9c0:	23c0      	movs	r3, #192	; 0xc0
     9c2:	029b      	lsls	r3, r3, #10
     9c4:	4313      	orrs	r3, r2
     9c6:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     9c8:	8a23      	ldrh	r3, [r4, #16]
     9ca:	0bdb      	lsrs	r3, r3, #15
     9cc:	d1fc      	bne.n	9c8 <_sercom_i2c_sync_send_address+0xe0>
     9ce:	e7d5      	b.n	97c <_sercom_i2c_sync_send_address+0x94>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
     9d0:	68ab      	ldr	r3, [r5, #8]
     9d2:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
     9d4:	7623      	strb	r3, [r4, #24]
				msg->buffer++;
     9d6:	68ab      	ldr	r3, [r5, #8]
     9d8:	3301      	adds	r3, #1
     9da:	60ab      	str	r3, [r5, #8]
				msg->len--;
     9dc:	686b      	ldr	r3, [r5, #4]
     9de:	3b01      	subs	r3, #1
     9e0:	606b      	str	r3, [r5, #4]
			return I2C_OK;
     9e2:	2000      	movs	r0, #0
     9e4:	e025      	b.n	a32 <_sercom_i2c_sync_send_address+0x14a>
	} else if (flags & SB_FLAG) {
     9e6:	0782      	lsls	r2, r0, #30
     9e8:	d53c      	bpl.n	a64 <_sercom_i2c_sync_send_address+0x17c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
     9ea:	686a      	ldr	r2, [r5, #4]
     9ec:	2a00      	cmp	r2, #0
     9ee:	d031      	beq.n	a54 <_sercom_i2c_sync_send_address+0x16c>
     9f0:	075b      	lsls	r3, r3, #29
     9f2:	d42f      	bmi.n	a54 <_sercom_i2c_sync_send_address+0x16c>
			msg->len--;
     9f4:	3a01      	subs	r2, #1
     9f6:	606a      	str	r2, [r5, #4]
			if (msg->len == 0) {
     9f8:	2a00      	cmp	r2, #0
     9fa:	d107      	bne.n	a0c <_sercom_i2c_sync_send_address+0x124>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     9fc:	6862      	ldr	r2, [r4, #4]
     9fe:	2380      	movs	r3, #128	; 0x80
     a00:	02db      	lsls	r3, r3, #11
     a02:	4313      	orrs	r3, r2
     a04:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     a06:	8a23      	ldrh	r3, [r4, #16]
     a08:	0bdb      	lsrs	r3, r3, #15
     a0a:	d1fc      	bne.n	a06 <_sercom_i2c_sync_send_address+0x11e>
			if (msg->len == 0) {
     a0c:	686b      	ldr	r3, [r5, #4]
     a0e:	2b00      	cmp	r3, #0
     a10:	d107      	bne.n	a22 <_sercom_i2c_sync_send_address+0x13a>
				if (msg->flags & I2C_M_STOP) {
     a12:	886b      	ldrh	r3, [r5, #2]
     a14:	b21b      	sxth	r3, r3
     a16:	2b00      	cmp	r3, #0
     a18:	db0c      	blt.n	a34 <_sercom_i2c_sync_send_address+0x14c>
				msg->flags &= ~I2C_M_BUSY;
     a1a:	886b      	ldrh	r3, [r5, #2]
     a1c:	4a17      	ldr	r2, [pc, #92]	; (a7c <_sercom_i2c_sync_send_address+0x194>)
     a1e:	4013      	ands	r3, r2
     a20:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
     a22:	68ab      	ldr	r3, [r5, #8]
     a24:	1c5a      	adds	r2, r3, #1
     a26:	60aa      	str	r2, [r5, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
     a28:	7e22      	ldrb	r2, [r4, #24]
     a2a:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     a2c:	2302      	movs	r3, #2
     a2e:	73a3      	strb	r3, [r4, #14]
	return I2C_OK;
     a30:	2000      	movs	r0, #0
}
     a32:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
     a34:	6863      	ldr	r3, [r4, #4]
     a36:	4a11      	ldr	r2, [pc, #68]	; (a7c <_sercom_i2c_sync_send_address+0x194>)
     a38:	4013      	ands	r3, r2
     a3a:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     a3c:	8a23      	ldrh	r3, [r4, #16]
     a3e:	0bdb      	lsrs	r3, r3, #15
     a40:	d1fc      	bne.n	a3c <_sercom_i2c_sync_send_address+0x154>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     a42:	6862      	ldr	r2, [r4, #4]
     a44:	23c0      	movs	r3, #192	; 0xc0
     a46:	029b      	lsls	r3, r3, #10
     a48:	4313      	orrs	r3, r2
     a4a:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     a4c:	8a23      	ldrh	r3, [r4, #16]
     a4e:	0bdb      	lsrs	r3, r3, #15
     a50:	d1fc      	bne.n	a4c <_sercom_i2c_sync_send_address+0x164>
     a52:	e7e2      	b.n	a1a <_sercom_i2c_sync_send_address+0x132>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     a54:	2302      	movs	r3, #2
     a56:	73a3      	strb	r3, [r4, #14]
			return I2C_NACK;
     a58:	2002      	movs	r0, #2
     a5a:	4240      	negs	r0, r0
     a5c:	e7e9      	b.n	a32 <_sercom_i2c_sync_send_address+0x14a>
			return I2C_ERR_BAD_ADDRESS;
     a5e:	2004      	movs	r0, #4
     a60:	4240      	negs	r0, r0
     a62:	e7e6      	b.n	a32 <_sercom_i2c_sync_send_address+0x14a>
	return I2C_OK;
     a64:	2000      	movs	r0, #0
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
     a66:	e7e4      	b.n	a32 <_sercom_i2c_sync_send_address+0x14a>
     a68:	00000581 	.word	0x00000581
     a6c:	00002d34 	.word	0x00002d34
     a70:	00000601 	.word	0x00000601
     a74:	fffbffff 	.word	0xfffbffff
     a78:	0000ffff 	.word	0x0000ffff
     a7c:	fffffeff 	.word	0xfffffeff

00000a80 <_i2c_m_sync_init>:
{
     a80:	b570      	push	{r4, r5, r6, lr}
     a82:	0006      	movs	r6, r0
     a84:	000c      	movs	r4, r1
	uint8_t i = _get_i2cm_index(hw);
     a86:	0008      	movs	r0, r1
     a88:	4b23      	ldr	r3, [pc, #140]	; (b18 <_i2c_m_sync_init+0x98>)
     a8a:	4798      	blx	r3
     a8c:	0005      	movs	r5, r0
	ASSERT(i2c_dev);
     a8e:	0030      	movs	r0, r6
     a90:	1e43      	subs	r3, r0, #1
     a92:	4198      	sbcs	r0, r3
     a94:	b2c0      	uxtb	r0, r0
     a96:	4a21      	ldr	r2, [pc, #132]	; (b1c <_i2c_m_sync_init+0x9c>)
     a98:	4921      	ldr	r1, [pc, #132]	; (b20 <_i2c_m_sync_init+0xa0>)
     a9a:	4b22      	ldr	r3, [pc, #136]	; (b24 <_i2c_m_sync_init+0xa4>)
     a9c:	4798      	blx	r3
	i2c_dev->hw = hw;
     a9e:	6134      	str	r4, [r6, #16]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     aa0:	8a23      	ldrh	r3, [r4, #16]
     aa2:	0bdb      	lsrs	r3, r3, #15
     aa4:	d1fc      	bne.n	aa0 <_i2c_m_sync_init+0x20>
     aa6:	8a23      	ldrh	r3, [r4, #16]
     aa8:	0bdb      	lsrs	r3, r3, #15
     aaa:	d1fc      	bne.n	aa6 <_i2c_m_sync_init+0x26>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
     aac:	6823      	ldr	r3, [r4, #0]
	if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
     aae:	079b      	lsls	r3, r3, #30
     ab0:	d507      	bpl.n	ac2 <_i2c_m_sync_init+0x42>
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     ab2:	2300      	movs	r3, #0
     ab4:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     ab6:	8a23      	ldrh	r3, [r4, #16]
     ab8:	0bdb      	lsrs	r3, r3, #15
     aba:	d1fc      	bne.n	ab6 <_i2c_m_sync_init+0x36>
     abc:	8a23      	ldrh	r3, [r4, #16]
     abe:	0bdb      	lsrs	r3, r3, #15
     ac0:	d1fc      	bne.n	abc <_i2c_m_sync_init+0x3c>
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     ac2:	2301      	movs	r3, #1
     ac4:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     ac6:	8a23      	ldrh	r3, [r4, #16]
     ac8:	0bdb      	lsrs	r3, r3, #15
     aca:	d1fc      	bne.n	ac6 <_i2c_m_sync_init+0x46>
     acc:	8a23      	ldrh	r3, [r4, #16]
     ace:	0bdb      	lsrs	r3, r3, #15
     ad0:	d1fc      	bne.n	acc <_i2c_m_sync_init+0x4c>
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a & ~SERCOM_I2CM_CTRLA_ENABLE);
     ad2:	006b      	lsls	r3, r5, #1
     ad4:	195b      	adds	r3, r3, r5
     ad6:	00da      	lsls	r2, r3, #3
     ad8:	4b13      	ldr	r3, [pc, #76]	; (b28 <_i2c_m_sync_init+0xa8>)
     ada:	189b      	adds	r3, r3, r2
     adc:	685b      	ldr	r3, [r3, #4]
     ade:	2202      	movs	r2, #2
     ae0:	4393      	bics	r3, r2
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     ae2:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     ae4:	8a23      	ldrh	r3, [r4, #16]
     ae6:	0bdb      	lsrs	r3, r3, #15
     ae8:	d1fc      	bne.n	ae4 <_i2c_m_sync_init+0x64>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
     aea:	006b      	lsls	r3, r5, #1
     aec:	195b      	adds	r3, r3, r5
     aee:	00da      	lsls	r2, r3, #3
     af0:	4b0d      	ldr	r3, [pc, #52]	; (b28 <_i2c_m_sync_init+0xa8>)
     af2:	189b      	adds	r3, r3, r2
     af4:	689b      	ldr	r3, [r3, #8]
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
     af6:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     af8:	8a23      	ldrh	r3, [r4, #16]
     afa:	0bdb      	lsrs	r3, r3, #15
     afc:	d1fc      	bne.n	af8 <_i2c_m_sync_init+0x78>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
     afe:	4a0a      	ldr	r2, [pc, #40]	; (b28 <_i2c_m_sync_init+0xa8>)
     b00:	006b      	lsls	r3, r5, #1
     b02:	1958      	adds	r0, r3, r5
     b04:	00c1      	lsls	r1, r0, #3
     b06:	0008      	movs	r0, r1
     b08:	1851      	adds	r1, r2, r1
     b0a:	8989      	ldrh	r1, [r1, #12]
	((Sercom *)hw)->I2CM.BAUD.reg = data;
     b0c:	8161      	strh	r1, [r4, #10]
	i2c_dev->service.trise = _i2cms[i].trise;
     b0e:	1812      	adds	r2, r2, r0
     b10:	8a13      	ldrh	r3, [r2, #16]
     b12:	81f3      	strh	r3, [r6, #14]
}
     b14:	2000      	movs	r0, #0
     b16:	bd70      	pop	{r4, r5, r6, pc}
     b18:	000008a5 	.word	0x000008a5
     b1c:	000004d7 	.word	0x000004d7
     b20:	00002d34 	.word	0x00002d34
     b24:	00000601 	.word	0x00000601
     b28:	00002d50 	.word	0x00002d50

00000b2c <_i2c_m_sync_enable>:
{
     b2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     b2e:	0006      	movs	r6, r0
	void *hw              = i2c_dev->hw;
     b30:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
     b32:	4d18      	ldr	r5, [pc, #96]	; (b94 <_i2c_m_sync_enable+0x68>)
     b34:	1e43      	subs	r3, r0, #1
     b36:	4198      	sbcs	r0, r3
     b38:	b2c0      	uxtb	r0, r0
     b3a:	22a1      	movs	r2, #161	; 0xa1
     b3c:	00d2      	lsls	r2, r2, #3
     b3e:	0029      	movs	r1, r5
     b40:	4f15      	ldr	r7, [pc, #84]	; (b98 <_i2c_m_sync_enable+0x6c>)
     b42:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
     b44:	6930      	ldr	r0, [r6, #16]
     b46:	1e43      	subs	r3, r0, #1
     b48:	4198      	sbcs	r0, r3
     b4a:	b2c0      	uxtb	r0, r0
     b4c:	4a13      	ldr	r2, [pc, #76]	; (b9c <_i2c_m_sync_enable+0x70>)
     b4e:	0029      	movs	r1, r5
     b50:	47b8      	blx	r7
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
     b52:	6823      	ldr	r3, [r4, #0]
     b54:	2202      	movs	r2, #2
     b56:	4313      	orrs	r3, r2
     b58:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     b5a:	8a23      	ldrh	r3, [r4, #16]
     b5c:	0bdb      	lsrs	r3, r3, #15
     b5e:	d1fc      	bne.n	b5a <_i2c_m_sync_enable+0x2e>
     b60:	2004      	movs	r0, #4
     b62:	490f      	ldr	r1, [pc, #60]	; (ba0 <_i2c_m_sync_enable+0x74>)
     b64:	8a23      	ldrh	r3, [r4, #16]
     b66:	0bdb      	lsrs	r3, r3, #15
     b68:	d1fc      	bne.n	b64 <_i2c_m_sync_enable+0x38>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
     b6a:	8a22      	ldrh	r2, [r4, #16]
     b6c:	0912      	lsrs	r2, r2, #4
     b6e:	3303      	adds	r3, #3
     b70:	4013      	ands	r3, r2
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
     b72:	2b01      	cmp	r3, #1
     b74:	d008      	beq.n	b88 <_i2c_m_sync_enable+0x5c>
		timeout--;
     b76:	3901      	subs	r1, #1
		if (timeout <= 0) {
     b78:	2900      	cmp	r1, #0
     b7a:	dcf3      	bgt.n	b64 <_i2c_m_sync_enable+0x38>
			if (--timeout_attempt)
     b7c:	3801      	subs	r0, #1
     b7e:	2800      	cmp	r0, #0
     b80:	d004      	beq.n	b8c <_i2c_m_sync_enable+0x60>
			((Sercom *)hw)->I2CM.STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(I2C_IDLE);
     b82:	2310      	movs	r3, #16
     b84:	8223      	strh	r3, [r4, #16]
     b86:	e7ec      	b.n	b62 <_i2c_m_sync_enable+0x36>
	return ERR_NONE;
     b88:	2000      	movs	r0, #0
}
     b8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return I2C_ERR_BUSY;
     b8c:	2006      	movs	r0, #6
     b8e:	4240      	negs	r0, r0
     b90:	e7fb      	b.n	b8a <_i2c_m_sync_enable+0x5e>
     b92:	46c0      	nop			; (mov r8, r8)
     b94:	00002d34 	.word	0x00002d34
     b98:	00000601 	.word	0x00000601
     b9c:	00000509 	.word	0x00000509
     ba0:	0000ffff 	.word	0x0000ffff

00000ba4 <_i2c_m_sync_transfer>:
{
     ba4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     ba6:	0005      	movs	r5, r0
     ba8:	000e      	movs	r6, r1
	void *   hw = i2c_dev->hw;
     baa:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
     bac:	1e43      	subs	r3, r0, #1
     bae:	4198      	sbcs	r0, r3
     bb0:	b2c0      	uxtb	r0, r0
     bb2:	4a7b      	ldr	r2, [pc, #492]	; (da0 <_i2c_m_sync_transfer+0x1fc>)
     bb4:	497b      	ldr	r1, [pc, #492]	; (da4 <_i2c_m_sync_transfer+0x200>)
     bb6:	4f7c      	ldr	r7, [pc, #496]	; (da8 <_i2c_m_sync_transfer+0x204>)
     bb8:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
     bba:	6928      	ldr	r0, [r5, #16]
     bbc:	1e43      	subs	r3, r0, #1
     bbe:	4198      	sbcs	r0, r3
     bc0:	b2c0      	uxtb	r0, r0
     bc2:	4a7a      	ldr	r2, [pc, #488]	; (dac <_i2c_m_sync_transfer+0x208>)
     bc4:	4977      	ldr	r1, [pc, #476]	; (da4 <_i2c_m_sync_transfer+0x200>)
     bc6:	47b8      	blx	r7
	ASSERT(msg);
     bc8:	0030      	movs	r0, r6
     bca:	1e43      	subs	r3, r0, #1
     bcc:	4198      	sbcs	r0, r3
     bce:	b2c0      	uxtb	r0, r0
     bd0:	4a77      	ldr	r2, [pc, #476]	; (db0 <_i2c_m_sync_transfer+0x20c>)
     bd2:	4974      	ldr	r1, [pc, #464]	; (da4 <_i2c_m_sync_transfer+0x200>)
     bd4:	47b8      	blx	r7
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
     bd6:	886b      	ldrh	r3, [r5, #2]
     bd8:	05db      	lsls	r3, r3, #23
     bda:	d500      	bpl.n	bde <_i2c_m_sync_transfer+0x3a>
     bdc:	e0dc      	b.n	d98 <_i2c_m_sync_transfer+0x1f4>
	msg->flags |= I2C_M_BUSY;
     bde:	8872      	ldrh	r2, [r6, #2]
     be0:	2380      	movs	r3, #128	; 0x80
     be2:	005b      	lsls	r3, r3, #1
     be4:	469c      	mov	ip, r3
     be6:	431a      	orrs	r2, r3
     be8:	8072      	strh	r2, [r6, #2]
	i2c_dev->service.msg = *msg;
     bea:	002a      	movs	r2, r5
     bec:	0031      	movs	r1, r6
     bee:	c989      	ldmia	r1!, {r0, r3, r7}
     bf0:	c289      	stmia	r2!, {r0, r3, r7}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
     bf2:	6862      	ldr	r2, [r4, #4]
     bf4:	4663      	mov	r3, ip
     bf6:	4313      	orrs	r3, r2
     bf8:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     bfa:	8a23      	ldrh	r3, [r4, #16]
     bfc:	0bdb      	lsrs	r3, r3, #15
     bfe:	d1fc      	bne.n	bfa <_i2c_m_sync_transfer+0x56>
	ret = _sercom_i2c_sync_send_address(i2c_dev);
     c00:	0028      	movs	r0, r5
     c02:	4b6c      	ldr	r3, [pc, #432]	; (db4 <_i2c_m_sync_transfer+0x210>)
     c04:	4798      	blx	r3
	if (ret) {
     c06:	2800      	cmp	r0, #0
     c08:	d100      	bne.n	c0c <_i2c_m_sync_transfer+0x68>
     c0a:	e07d      	b.n	d08 <_i2c_m_sync_transfer+0x164>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
     c0c:	886b      	ldrh	r3, [r5, #2]
     c0e:	4a6a      	ldr	r2, [pc, #424]	; (db8 <_i2c_m_sync_transfer+0x214>)
     c10:	4013      	ands	r3, r2
     c12:	806b      	strh	r3, [r5, #2]
}
     c14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return I2C_ERR_BUS;
     c16:	2005      	movs	r0, #5
     c18:	4240      	negs	r0, r0
     c1a:	e086      	b.n	d2a <_i2c_m_sync_transfer+0x186>
			if (msg->flags & I2C_M_STOP) {
     c1c:	8873      	ldrh	r3, [r6, #2]
     c1e:	b21b      	sxth	r3, r3
     c20:	2b00      	cmp	r3, #0
     c22:	db04      	blt.n	c2e <_i2c_m_sync_transfer+0x8a>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
     c24:	886b      	ldrh	r3, [r5, #2]
     c26:	4a64      	ldr	r2, [pc, #400]	; (db8 <_i2c_m_sync_transfer+0x214>)
     c28:	4013      	ands	r3, r2
     c2a:	806b      	strh	r3, [r5, #2]
			return ret;
     c2c:	e7f2      	b.n	c14 <_i2c_m_sync_transfer+0x70>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     c2e:	6862      	ldr	r2, [r4, #4]
     c30:	23c0      	movs	r3, #192	; 0xc0
     c32:	029b      	lsls	r3, r3, #10
     c34:	4313      	orrs	r3, r2
     c36:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     c38:	8a23      	ldrh	r3, [r4, #16]
     c3a:	0bdb      	lsrs	r3, r3, #15
     c3c:	d1fc      	bne.n	c38 <_i2c_m_sync_transfer+0x94>
     c3e:	e7f1      	b.n	c24 <_i2c_m_sync_transfer+0x80>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
     c40:	075b      	lsls	r3, r3, #29
     c42:	d40b      	bmi.n	c5c <_i2c_m_sync_transfer+0xb8>
			if (msg->len == 0) {
     c44:	6868      	ldr	r0, [r5, #4]
     c46:	2800      	cmp	r0, #0
     c48:	d12d      	bne.n	ca6 <_i2c_m_sync_transfer+0x102>
				if (msg->flags & I2C_M_STOP) {
     c4a:	886b      	ldrh	r3, [r5, #2]
     c4c:	b21b      	sxth	r3, r3
     c4e:	2b00      	cmp	r3, #0
     c50:	db20      	blt.n	c94 <_i2c_m_sync_transfer+0xf0>
				msg->flags &= ~I2C_M_BUSY;
     c52:	886b      	ldrh	r3, [r5, #2]
     c54:	4a58      	ldr	r2, [pc, #352]	; (db8 <_i2c_m_sync_transfer+0x214>)
     c56:	4013      	ands	r3, r2
     c58:	806b      	strh	r3, [r5, #2]
     c5a:	e055      	b.n	d08 <_i2c_m_sync_transfer+0x164>
				if (msg->len > 0) {
     c5c:	686b      	ldr	r3, [r5, #4]
     c5e:	2b00      	cmp	r3, #0
     c60:	dd04      	ble.n	c6c <_i2c_m_sync_transfer+0xc8>
					msg->flags |= I2C_M_FAIL;
     c62:	886b      	ldrh	r3, [r5, #2]
     c64:	2280      	movs	r2, #128	; 0x80
     c66:	0152      	lsls	r2, r2, #5
     c68:	4313      	orrs	r3, r2
     c6a:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
     c6c:	886b      	ldrh	r3, [r5, #2]
     c6e:	b21b      	sxth	r3, r3
     c70:	2b00      	cmp	r3, #0
     c72:	db06      	blt.n	c82 <_i2c_m_sync_transfer+0xde>
				msg->flags &= ~I2C_M_BUSY;
     c74:	886b      	ldrh	r3, [r5, #2]
     c76:	4a50      	ldr	r2, [pc, #320]	; (db8 <_i2c_m_sync_transfer+0x214>)
     c78:	4013      	ands	r3, r2
     c7a:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
     c7c:	2002      	movs	r0, #2
     c7e:	4240      	negs	r0, r0
     c80:	e042      	b.n	d08 <_i2c_m_sync_transfer+0x164>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     c82:	6862      	ldr	r2, [r4, #4]
     c84:	23c0      	movs	r3, #192	; 0xc0
     c86:	029b      	lsls	r3, r3, #10
     c88:	4313      	orrs	r3, r2
     c8a:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     c8c:	8a23      	ldrh	r3, [r4, #16]
     c8e:	0bdb      	lsrs	r3, r3, #15
     c90:	d1fc      	bne.n	c8c <_i2c_m_sync_transfer+0xe8>
     c92:	e7ef      	b.n	c74 <_i2c_m_sync_transfer+0xd0>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     c94:	6862      	ldr	r2, [r4, #4]
     c96:	23c0      	movs	r3, #192	; 0xc0
     c98:	029b      	lsls	r3, r3, #10
     c9a:	4313      	orrs	r3, r2
     c9c:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     c9e:	8a23      	ldrh	r3, [r4, #16]
     ca0:	0bdb      	lsrs	r3, r3, #15
     ca2:	d1fc      	bne.n	c9e <_i2c_m_sync_transfer+0xfa>
     ca4:	e7d5      	b.n	c52 <_i2c_m_sync_transfer+0xae>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
     ca6:	68ab      	ldr	r3, [r5, #8]
     ca8:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
     caa:	7623      	strb	r3, [r4, #24]
				msg->buffer++;
     cac:	68ab      	ldr	r3, [r5, #8]
     cae:	3301      	adds	r3, #1
     cb0:	60ab      	str	r3, [r5, #8]
				msg->len--;
     cb2:	686b      	ldr	r3, [r5, #4]
     cb4:	3b01      	subs	r3, #1
     cb6:	606b      	str	r3, [r5, #4]
			return I2C_OK;
     cb8:	2000      	movs	r0, #0
     cba:	e025      	b.n	d08 <_i2c_m_sync_transfer+0x164>
	} else if (flags & SB_FLAG) {
     cbc:	078a      	lsls	r2, r1, #30
     cbe:	d569      	bpl.n	d94 <_i2c_m_sync_transfer+0x1f0>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
     cc0:	686a      	ldr	r2, [r5, #4]
     cc2:	2a00      	cmp	r2, #0
     cc4:	d05e      	beq.n	d84 <_i2c_m_sync_transfer+0x1e0>
     cc6:	075b      	lsls	r3, r3, #29
     cc8:	d45c      	bmi.n	d84 <_i2c_m_sync_transfer+0x1e0>
			msg->len--;
     cca:	3a01      	subs	r2, #1
     ccc:	606a      	str	r2, [r5, #4]
			if (msg->len == 0) {
     cce:	2a00      	cmp	r2, #0
     cd0:	d107      	bne.n	ce2 <_i2c_m_sync_transfer+0x13e>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     cd2:	6862      	ldr	r2, [r4, #4]
     cd4:	2380      	movs	r3, #128	; 0x80
     cd6:	02db      	lsls	r3, r3, #11
     cd8:	4313      	orrs	r3, r2
     cda:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     cdc:	8a23      	ldrh	r3, [r4, #16]
     cde:	0bdb      	lsrs	r3, r3, #15
     ce0:	d1fc      	bne.n	cdc <_i2c_m_sync_transfer+0x138>
			if (msg->len == 0) {
     ce2:	686b      	ldr	r3, [r5, #4]
     ce4:	2b00      	cmp	r3, #0
     ce6:	d107      	bne.n	cf8 <_i2c_m_sync_transfer+0x154>
				if (msg->flags & I2C_M_STOP) {
     ce8:	886b      	ldrh	r3, [r5, #2]
     cea:	b21b      	sxth	r3, r3
     cec:	2b00      	cmp	r3, #0
     cee:	db39      	blt.n	d64 <_i2c_m_sync_transfer+0x1c0>
				msg->flags &= ~I2C_M_BUSY;
     cf0:	886b      	ldrh	r3, [r5, #2]
     cf2:	4a31      	ldr	r2, [pc, #196]	; (db8 <_i2c_m_sync_transfer+0x214>)
     cf4:	4013      	ands	r3, r2
     cf6:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
     cf8:	68ab      	ldr	r3, [r5, #8]
     cfa:	1c5a      	adds	r2, r3, #1
     cfc:	60aa      	str	r2, [r5, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
     cfe:	7e22      	ldrb	r2, [r4, #24]
     d00:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     d02:	2302      	movs	r3, #2
     d04:	73a3      	strb	r3, [r4, #14]
	return I2C_OK;
     d06:	2000      	movs	r0, #0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
     d08:	886b      	ldrh	r3, [r5, #2]
     d0a:	05db      	lsls	r3, r3, #23
     d0c:	d400      	bmi.n	d10 <_i2c_m_sync_transfer+0x16c>
     d0e:	e781      	b.n	c14 <_i2c_m_sync_transfer+0x70>
	void *   hw      = i2c_dev->hw;
     d10:	692f      	ldr	r7, [r5, #16]
	uint32_t timeout = 65535;
     d12:	4a2a      	ldr	r2, [pc, #168]	; (dbc <_i2c_m_sync_transfer+0x218>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
     d14:	7bbb      	ldrb	r3, [r7, #14]
     d16:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
     d18:	0019      	movs	r1, r3
		if (timeout-- == 0) {
     d1a:	1e50      	subs	r0, r2, #1
     d1c:	2a00      	cmp	r2, #0
     d1e:	d100      	bne.n	d22 <_i2c_m_sync_transfer+0x17e>
     d20:	e779      	b.n	c16 <_i2c_m_sync_transfer+0x72>
     d22:	0002      	movs	r2, r0
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
     d24:	079b      	lsls	r3, r3, #30
     d26:	d0f5      	beq.n	d14 <_i2c_m_sync_transfer+0x170>
	return I2C_OK;
     d28:	2000      	movs	r0, #0
		if (ret) {
     d2a:	2800      	cmp	r0, #0
     d2c:	d000      	beq.n	d30 <_i2c_m_sync_transfer+0x18c>
     d2e:	e775      	b.n	c1c <_i2c_m_sync_transfer+0x78>
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     d30:	8a23      	ldrh	r3, [r4, #16]
     d32:	0bdb      	lsrs	r3, r3, #15
     d34:	d1fc      	bne.n	d30 <_i2c_m_sync_transfer+0x18c>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
     d36:	8a23      	ldrh	r3, [r4, #16]
     d38:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
     d3a:	07ca      	lsls	r2, r1, #31
     d3c:	d5be      	bpl.n	cbc <_i2c_m_sync_transfer+0x118>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
     d3e:	079a      	lsls	r2, r3, #30
     d40:	d400      	bmi.n	d44 <_i2c_m_sync_transfer+0x1a0>
     d42:	e77d      	b.n	c40 <_i2c_m_sync_transfer+0x9c>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
     d44:	2201      	movs	r2, #1
     d46:	73a2      	strb	r2, [r4, #14]
			msg->flags |= I2C_M_FAIL;
     d48:	886a      	ldrh	r2, [r5, #2]
     d4a:	2180      	movs	r1, #128	; 0x80
     d4c:	0149      	lsls	r1, r1, #5
     d4e:	430a      	orrs	r2, r1
     d50:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
     d52:	886a      	ldrh	r2, [r5, #2]
     d54:	4918      	ldr	r1, [pc, #96]	; (db8 <_i2c_m_sync_transfer+0x214>)
     d56:	400a      	ands	r2, r1
     d58:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
     d5a:	07db      	lsls	r3, r3, #31
     d5c:	d517      	bpl.n	d8e <_i2c_m_sync_transfer+0x1ea>
				return I2C_ERR_BUS;
     d5e:	2005      	movs	r0, #5
     d60:	4240      	negs	r0, r0
     d62:	e7d1      	b.n	d08 <_i2c_m_sync_transfer+0x164>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
     d64:	6863      	ldr	r3, [r4, #4]
     d66:	4a14      	ldr	r2, [pc, #80]	; (db8 <_i2c_m_sync_transfer+0x214>)
     d68:	4013      	ands	r3, r2
     d6a:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     d6c:	8a23      	ldrh	r3, [r4, #16]
     d6e:	0bdb      	lsrs	r3, r3, #15
     d70:	d1fc      	bne.n	d6c <_i2c_m_sync_transfer+0x1c8>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     d72:	6862      	ldr	r2, [r4, #4]
     d74:	23c0      	movs	r3, #192	; 0xc0
     d76:	029b      	lsls	r3, r3, #10
     d78:	4313      	orrs	r3, r2
     d7a:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     d7c:	8a23      	ldrh	r3, [r4, #16]
     d7e:	0bdb      	lsrs	r3, r3, #15
     d80:	d1fc      	bne.n	d7c <_i2c_m_sync_transfer+0x1d8>
     d82:	e7b5      	b.n	cf0 <_i2c_m_sync_transfer+0x14c>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     d84:	2302      	movs	r3, #2
     d86:	73a3      	strb	r3, [r4, #14]
			return I2C_NACK;
     d88:	2002      	movs	r0, #2
     d8a:	4240      	negs	r0, r0
     d8c:	e7bc      	b.n	d08 <_i2c_m_sync_transfer+0x164>
			return I2C_ERR_BAD_ADDRESS;
     d8e:	2004      	movs	r0, #4
     d90:	4240      	negs	r0, r0
     d92:	e7b9      	b.n	d08 <_i2c_m_sync_transfer+0x164>
	return I2C_OK;
     d94:	2000      	movs	r0, #0
     d96:	e7b7      	b.n	d08 <_i2c_m_sync_transfer+0x164>
		return I2C_ERR_BUSY;
     d98:	2006      	movs	r0, #6
     d9a:	4240      	negs	r0, r0
     d9c:	e73a      	b.n	c14 <_i2c_m_sync_transfer+0x70>
     d9e:	46c0      	nop			; (mov r8, r8)
     da0:	0000059b 	.word	0x0000059b
     da4:	00002d34 	.word	0x00002d34
     da8:	00000601 	.word	0x00000601
     dac:	0000059c 	.word	0x0000059c
     db0:	0000059d 	.word	0x0000059d
     db4:	000008e9 	.word	0x000008e9
     db8:	fffffeff 	.word	0xfffffeff
     dbc:	0000ffff 	.word	0x0000ffff

00000dc0 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
     dc0:	b570      	push	{r4, r5, r6, lr}
     dc2:	0006      	movs	r6, r0
     dc4:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
     dc6:	0008      	movs	r0, r1
     dc8:	4b61      	ldr	r3, [pc, #388]	; (f50 <_spi_m_sync_init+0x190>)
     dca:	4798      	blx	r3
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
     dcc:	2300      	movs	r3, #0
     dce:	2b00      	cmp	r3, #0
     dd0:	d100      	bne.n	dd4 <_spi_m_sync_init+0x14>
     dd2:	e06c      	b.n	eae <_spi_m_sync_init+0xee>
	return NULL;
     dd4:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
     dd6:	2e00      	cmp	r6, #0
     dd8:	d100      	bne.n	ddc <_spi_m_sync_init+0x1c>
     dda:	e073      	b.n	ec4 <_spi_m_sync_init+0x104>
     ddc:	2c00      	cmp	r4, #0
     dde:	d100      	bne.n	de2 <_spi_m_sync_init+0x22>
     de0:	e06e      	b.n	ec0 <_spi_m_sync_init+0x100>
     de2:	2001      	movs	r0, #1
     de4:	4a5b      	ldr	r2, [pc, #364]	; (f54 <_spi_m_sync_init+0x194>)
     de6:	495c      	ldr	r1, [pc, #368]	; (f58 <_spi_m_sync_init+0x198>)
     de8:	4b5c      	ldr	r3, [pc, #368]	; (f5c <_spi_m_sync_init+0x19c>)
     dea:	4798      	blx	r3

	if (regs == NULL) {
     dec:	2d00      	cmp	r5, #0
     dee:	d100      	bne.n	df2 <_spi_m_sync_init+0x32>
     df0:	e0ab      	b.n	f4a <_spi_m_sync_init+0x18a>
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     df2:	8a23      	ldrh	r3, [r4, #16]
     df4:	0bdb      	lsrs	r3, r3, #15
     df6:	d1fc      	bne.n	df2 <_spi_m_sync_init+0x32>
     df8:	8a23      	ldrh	r3, [r4, #16]
     dfa:	0bdb      	lsrs	r3, r3, #15
     dfc:	d1fc      	bne.n	df8 <_spi_m_sync_init+0x38>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
     dfe:	6823      	ldr	r3, [r4, #0]
		return ERR_INVALID_ARG;
	}

	hri_sercomspi_wait_for_sync(hw);
	if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
     e00:	079b      	lsls	r3, r3, #30
     e02:	d507      	bpl.n	e14 <_spi_m_sync_init+0x54>
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     e04:	2300      	movs	r3, #0
     e06:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     e08:	8a23      	ldrh	r3, [r4, #16]
     e0a:	0bdb      	lsrs	r3, r3, #15
     e0c:	d1fc      	bne.n	e08 <_spi_m_sync_init+0x48>
     e0e:	8a23      	ldrh	r3, [r4, #16]
     e10:	0bdb      	lsrs	r3, r3, #15
     e12:	d1fc      	bne.n	e0e <_spi_m_sync_init+0x4e>
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     e14:	2301      	movs	r3, #1
     e16:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     e18:	8a23      	ldrh	r3, [r4, #16]
     e1a:	0bdb      	lsrs	r3, r3, #15
     e1c:	d1fc      	bne.n	e18 <_spi_m_sync_init+0x58>
     e1e:	8a23      	ldrh	r3, [r4, #16]
     e20:	0bdb      	lsrs	r3, r3, #15
     e22:	d1fc      	bne.n	e1e <_spi_m_sync_init+0x5e>
		hri_sercomspi_wait_for_sync(hw);
	}
	hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST);
	hri_sercomspi_wait_for_sync(hw);

	dev->prvt = hw;
     e24:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
     e26:	782b      	ldrb	r3, [r5, #0]
     e28:	786a      	ldrb	r2, [r5, #1]
     e2a:	0212      	lsls	r2, r2, #8
     e2c:	431a      	orrs	r2, r3
     e2e:	78ab      	ldrb	r3, [r5, #2]
     e30:	041b      	lsls	r3, r3, #16
     e32:	431a      	orrs	r2, r3
     e34:	78eb      	ldrb	r3, [r5, #3]
     e36:	061b      	lsls	r3, r3, #24
     e38:	4313      	orrs	r3, r2
     e3a:	221c      	movs	r2, #28
     e3c:	4013      	ands	r3, r2
     e3e:	2b08      	cmp	r3, #8
     e40:	d042      	beq.n	ec8 <_spi_m_sync_init+0x108>
	ASSERT(hw && regs);
     e42:	2c00      	cmp	r4, #0
     e44:	d100      	bne.n	e48 <_spi_m_sync_init+0x88>
     e46:	e07c      	b.n	f42 <_spi_m_sync_init+0x182>
     e48:	2d00      	cmp	r5, #0
     e4a:	d100      	bne.n	e4e <_spi_m_sync_init+0x8e>
     e4c:	e077      	b.n	f3e <_spi_m_sync_init+0x17e>
     e4e:	2001      	movs	r0, #1
     e50:	4a43      	ldr	r2, [pc, #268]	; (f60 <_spi_m_sync_init+0x1a0>)
     e52:	4941      	ldr	r1, [pc, #260]	; (f58 <_spi_m_sync_init+0x198>)
     e54:	4b41      	ldr	r3, [pc, #260]	; (f5c <_spi_m_sync_init+0x19c>)
     e56:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
     e58:	782b      	ldrb	r3, [r5, #0]
     e5a:	786a      	ldrb	r2, [r5, #1]
     e5c:	0212      	lsls	r2, r2, #8
     e5e:	431a      	orrs	r2, r3
     e60:	78ab      	ldrb	r3, [r5, #2]
     e62:	041b      	lsls	r3, r3, #16
     e64:	431a      	orrs	r2, r3
     e66:	78eb      	ldrb	r3, [r5, #3]
     e68:	061b      	lsls	r3, r3, #24
     e6a:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
     e6c:	4a3d      	ldr	r2, [pc, #244]	; (f64 <_spi_m_sync_init+0x1a4>)
     e6e:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     e70:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     e72:	8a23      	ldrh	r3, [r4, #16]
     e74:	0bdb      	lsrs	r3, r3, #15
     e76:	d1fc      	bne.n	e72 <_spi_m_sync_init+0xb2>
	    hw, (regs->ctrlb & ~(SERCOM_SPI_CTRLB_AMODE_Msk | SERCOM_SPI_CTRLB_PLOADEN)) | (SERCOM_SPI_CTRLB_RXEN));
     e78:	792b      	ldrb	r3, [r5, #4]
     e7a:	796a      	ldrb	r2, [r5, #5]
     e7c:	0212      	lsls	r2, r2, #8
     e7e:	431a      	orrs	r2, r3
     e80:	79ab      	ldrb	r3, [r5, #6]
     e82:	041b      	lsls	r3, r3, #16
     e84:	431a      	orrs	r2, r3
     e86:	79eb      	ldrb	r3, [r5, #7]
     e88:	061b      	lsls	r3, r3, #24
     e8a:	4313      	orrs	r3, r2
     e8c:	4a36      	ldr	r2, [pc, #216]	; (f68 <_spi_m_sync_init+0x1a8>)
     e8e:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
     e90:	2280      	movs	r2, #128	; 0x80
     e92:	0292      	lsls	r2, r2, #10
     e94:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
     e96:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
     e98:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
     e9a:	72a3      	strb	r3, [r4, #10]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
     e9c:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
     e9e:	7223      	strb	r3, [r4, #8]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
     ea0:	792b      	ldrb	r3, [r5, #4]
     ea2:	075b      	lsls	r3, r3, #29
     ea4:	d14f      	bne.n	f46 <_spi_m_sync_init+0x186>
     ea6:	2301      	movs	r3, #1
     ea8:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
     eaa:	2000      	movs	r0, #0
}
     eac:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
     eae:	2800      	cmp	r0, #0
     eb0:	d002      	beq.n	eb8 <_spi_m_sync_init+0xf8>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
     eb2:	3301      	adds	r3, #1
     eb4:	b2db      	uxtb	r3, r3
     eb6:	e78a      	b.n	dce <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
     eb8:	011d      	lsls	r5, r3, #4
     eba:	4b2c      	ldr	r3, [pc, #176]	; (f6c <_spi_m_sync_init+0x1ac>)
     ebc:	195d      	adds	r5, r3, r5
     ebe:	e78a      	b.n	dd6 <_spi_m_sync_init+0x16>
	ASSERT(dev && hw);
     ec0:	2000      	movs	r0, #0
     ec2:	e78f      	b.n	de4 <_spi_m_sync_init+0x24>
     ec4:	2000      	movs	r0, #0
     ec6:	e78d      	b.n	de4 <_spi_m_sync_init+0x24>
	ASSERT(hw && regs);
     ec8:	2c00      	cmp	r4, #0
     eca:	d036      	beq.n	f3a <_spi_m_sync_init+0x17a>
     ecc:	2d00      	cmp	r5, #0
     ece:	d032      	beq.n	f36 <_spi_m_sync_init+0x176>
     ed0:	2001      	movs	r0, #1
     ed2:	4a27      	ldr	r2, [pc, #156]	; (f70 <_spi_m_sync_init+0x1b0>)
     ed4:	4920      	ldr	r1, [pc, #128]	; (f58 <_spi_m_sync_init+0x198>)
     ed6:	4b21      	ldr	r3, [pc, #132]	; (f5c <_spi_m_sync_init+0x19c>)
     ed8:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
     eda:	782b      	ldrb	r3, [r5, #0]
     edc:	786a      	ldrb	r2, [r5, #1]
     ede:	0212      	lsls	r2, r2, #8
     ee0:	431a      	orrs	r2, r3
     ee2:	78ab      	ldrb	r3, [r5, #2]
     ee4:	041b      	lsls	r3, r3, #16
     ee6:	431a      	orrs	r2, r3
     ee8:	78eb      	ldrb	r3, [r5, #3]
     eea:	061b      	lsls	r3, r3, #24
     eec:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
     eee:	4a1d      	ldr	r2, [pc, #116]	; (f64 <_spi_m_sync_init+0x1a4>)
     ef0:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     ef2:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     ef4:	8a23      	ldrh	r3, [r4, #16]
     ef6:	0bdb      	lsrs	r3, r3, #15
     ef8:	d1fc      	bne.n	ef4 <_spi_m_sync_init+0x134>
	hri_sercomspi_write_CTRLB_reg(hw, regs->ctrlb | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_PLOADEN));
     efa:	792b      	ldrb	r3, [r5, #4]
     efc:	796a      	ldrb	r2, [r5, #5]
     efe:	0212      	lsls	r2, r2, #8
     f00:	431a      	orrs	r2, r3
     f02:	79ab      	ldrb	r3, [r5, #6]
     f04:	041b      	lsls	r3, r3, #16
     f06:	431a      	orrs	r2, r3
     f08:	79eb      	ldrb	r3, [r5, #7]
     f0a:	061b      	lsls	r3, r3, #24
     f0c:	4313      	orrs	r3, r2
     f0e:	4a19      	ldr	r2, [pc, #100]	; (f74 <_spi_m_sync_init+0x1b4>)
     f10:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
     f12:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
     f14:	7a2b      	ldrb	r3, [r5, #8]
     f16:	7a6a      	ldrb	r2, [r5, #9]
     f18:	0212      	lsls	r2, r2, #8
     f1a:	431a      	orrs	r2, r3
     f1c:	7aab      	ldrb	r3, [r5, #10]
     f1e:	041b      	lsls	r3, r3, #16
     f20:	431a      	orrs	r2, r3
     f22:	7aeb      	ldrb	r3, [r5, #11]
     f24:	061b      	lsls	r3, r3, #24
     f26:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
     f28:	6163      	str	r3, [r4, #20]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
     f2a:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
     f2c:	7223      	strb	r3, [r4, #8]
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
     f2e:	8a23      	ldrh	r3, [r4, #16]
     f30:	0bdb      	lsrs	r3, r3, #15
	while (hri_sercomspi_is_syncing(hw))
     f32:	d1fc      	bne.n	f2e <_spi_m_sync_init+0x16e>
     f34:	e7b4      	b.n	ea0 <_spi_m_sync_init+0xe0>
	ASSERT(hw && regs);
     f36:	2000      	movs	r0, #0
     f38:	e7cb      	b.n	ed2 <_spi_m_sync_init+0x112>
     f3a:	2000      	movs	r0, #0
     f3c:	e7c9      	b.n	ed2 <_spi_m_sync_init+0x112>
	ASSERT(hw && regs);
     f3e:	2000      	movs	r0, #0
     f40:	e786      	b.n	e50 <_spi_m_sync_init+0x90>
     f42:	2000      	movs	r0, #0
     f44:	e784      	b.n	e50 <_spi_m_sync_init+0x90>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
     f46:	2302      	movs	r3, #2
     f48:	e7ae      	b.n	ea8 <_spi_m_sync_init+0xe8>
		return ERR_INVALID_ARG;
     f4a:	200d      	movs	r0, #13
     f4c:	4240      	negs	r0, r0
     f4e:	e7ad      	b.n	eac <_spi_m_sync_init+0xec>
     f50:	00000875 	.word	0x00000875
     f54:	000008a3 	.word	0x000008a3
     f58:	00002d34 	.word	0x00002d34
     f5c:	00000601 	.word	0x00000601
     f60:	00000872 	.word	0x00000872
     f64:	fffffefc 	.word	0xfffffefc
     f68:	fffd3fbf 	.word	0xfffd3fbf
     f6c:	00002d68 	.word	0x00002d68
     f70:	00000883 	.word	0x00000883
     f74:	00020040 	.word	0x00020040

00000f78 <_spi_m_sync_enable>:

	return _spi_deinit(hw);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
     f78:	b510      	push	{r4, lr}
     f7a:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->prvt);
     f7c:	d00d      	beq.n	f9a <_spi_m_sync_enable+0x22>
     f7e:	6803      	ldr	r3, [r0, #0]
     f80:	2b00      	cmp	r3, #0
     f82:	d008      	beq.n	f96 <_spi_m_sync_enable+0x1e>
     f84:	2001      	movs	r0, #1
     f86:	4a06      	ldr	r2, [pc, #24]	; (fa0 <_spi_m_sync_enable+0x28>)
     f88:	4906      	ldr	r1, [pc, #24]	; (fa4 <_spi_m_sync_enable+0x2c>)
     f8a:	4b07      	ldr	r3, [pc, #28]	; (fa8 <_spi_m_sync_enable+0x30>)
     f8c:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
     f8e:	6820      	ldr	r0, [r4, #0]
     f90:	4b06      	ldr	r3, [pc, #24]	; (fac <_spi_m_sync_enable+0x34>)
     f92:	4798      	blx	r3
}
     f94:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
     f96:	2000      	movs	r0, #0
     f98:	e7f5      	b.n	f86 <_spi_m_sync_enable+0xe>
     f9a:	2000      	movs	r0, #0
     f9c:	e7f3      	b.n	f86 <_spi_m_sync_enable+0xe>
     f9e:	46c0      	nop			; (mov r8, r8)
     fa0:	0000090a 	.word	0x0000090a
     fa4:	00002d34 	.word	0x00002d34
     fa8:	00000601 	.word	0x00000601
     fac:	00000885 	.word	0x00000885

00000fb0 <_spi_m_sync_trans>:
	ctrl->txcnt++;
	hri_sercomspi_write_DATA_reg(hw, data);
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
     fb0:	b570      	push	{r4, r5, r6, lr}
     fb2:	b088      	sub	sp, #32
     fb4:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
     fb6:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
     fb8:	680b      	ldr	r3, [r1, #0]
     fba:	9303      	str	r3, [sp, #12]
     fbc:	684b      	ldr	r3, [r1, #4]
     fbe:	9304      	str	r3, [sp, #16]
     fc0:	2300      	movs	r3, #0
     fc2:	9305      	str	r3, [sp, #20]
     fc4:	9306      	str	r3, [sp, #24]
     fc6:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
     fc8:	2800      	cmp	r0, #0
     fca:	d014      	beq.n	ff6 <_spi_m_sync_trans+0x46>
     fcc:	2c00      	cmp	r4, #0
     fce:	d010      	beq.n	ff2 <_spi_m_sync_trans+0x42>
     fd0:	2001      	movs	r0, #1
     fd2:	4a2d      	ldr	r2, [pc, #180]	; (1088 <STACK_SIZE+0x88>)
     fd4:	492d      	ldr	r1, [pc, #180]	; (108c <STACK_SIZE+0x8c>)
     fd6:	4b2e      	ldr	r3, [pc, #184]	; (1090 <STACK_SIZE+0x90>)
     fd8:	4798      	blx	r3
     fda:	8a23      	ldrh	r3, [r4, #16]
     fdc:	0bdb      	lsrs	r3, r3, #15

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(hw)) {
     fde:	d14f      	bne.n	1080 <STACK_SIZE+0x80>
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     fe0:	8a23      	ldrh	r3, [r4, #16]
     fe2:	0bdb      	lsrs	r3, r3, #15
     fe4:	d1fc      	bne.n	fe0 <_spi_m_sync_trans+0x30>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
     fe6:	6823      	ldr	r3, [r4, #0]
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
     fe8:	079b      	lsls	r3, r3, #30
     fea:	d418      	bmi.n	101e <STACK_SIZE+0x1e>
		return ERR_NOT_INITIALIZED;
     fec:	2014      	movs	r0, #20
     fee:	4240      	negs	r0, r0
     ff0:	e044      	b.n	107c <STACK_SIZE+0x7c>
	ASSERT(dev && hw);
     ff2:	2000      	movs	r0, #0
     ff4:	e7ed      	b.n	fd2 <_spi_m_sync_trans+0x22>
     ff6:	2000      	movs	r0, #0
     ff8:	e7eb      	b.n	fd2 <_spi_m_sync_trans+0x22>
		return false;
     ffa:	2200      	movs	r2, #0
     ffc:	e026      	b.n	104c <STACK_SIZE+0x4c>
			data |= (*ctrl->txbuf) << 8;
     ffe:	7858      	ldrb	r0, [r3, #1]
    1000:	0200      	lsls	r0, r0, #8
    1002:	4301      	orrs	r1, r0
			ctrl->txbuf++;
    1004:	3302      	adds	r3, #2
    1006:	9303      	str	r3, [sp, #12]
	ctrl->txcnt++;
    1008:	3201      	adds	r2, #1
    100a:	9205      	str	r2, [sp, #20]
	hri_sercomspi_write_DATA_reg(hw, data);
    100c:	b289      	uxth	r1, r1
	((Sercom *)hw)->SPI.DATA.reg = data;
    100e:	8321      	strh	r1, [r4, #24]
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check(hw, iflag, &ctrl);
			}
		}

		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    1010:	9805      	ldr	r0, [sp, #20]
    1012:	68ab      	ldr	r3, [r5, #8]
    1014:	4298      	cmp	r0, r3
    1016:	d302      	bcc.n	101e <STACK_SIZE+0x1e>
    1018:	9a06      	ldr	r2, [sp, #24]
    101a:	4293      	cmp	r3, r2
    101c:	d929      	bls.n	1072 <STACK_SIZE+0x72>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    101e:	7ba3      	ldrb	r3, [r4, #14]
    1020:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    1022:	075a      	lsls	r2, r3, #29
    1024:	d5e9      	bpl.n	ffa <_spi_m_sync_trans+0x4a>
	return ((Sercom *)hw)->SPI.DATA.reg;
    1026:	8b22      	ldrh	r2, [r4, #24]
    1028:	b292      	uxth	r2, r2
	if (ctrl->rxbuf) {
    102a:	9904      	ldr	r1, [sp, #16]
    102c:	2900      	cmp	r1, #0
    102e:	d008      	beq.n	1042 <STACK_SIZE+0x42>
		*ctrl->rxbuf++ = (uint8_t)data;
    1030:	1c48      	adds	r0, r1, #1
    1032:	9004      	str	r0, [sp, #16]
    1034:	700a      	strb	r2, [r1, #0]
		if (ctrl->char_size > 1) {
    1036:	2e01      	cmp	r6, #1
    1038:	d903      	bls.n	1042 <STACK_SIZE+0x42>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    103a:	1c88      	adds	r0, r1, #2
    103c:	9004      	str	r0, [sp, #16]
    103e:	0a12      	lsrs	r2, r2, #8
    1040:	704a      	strb	r2, [r1, #1]
	ctrl->rxcnt++;
    1042:	9a06      	ldr	r2, [sp, #24]
    1044:	9201      	str	r2, [sp, #4]
    1046:	3201      	adds	r2, #1
    1048:	9206      	str	r2, [sp, #24]
	return true;
    104a:	2201      	movs	r2, #1
		if (!_spi_rx_check(hw, iflag, &ctrl)) {
    104c:	2a00      	cmp	r2, #0
    104e:	d1df      	bne.n	1010 <STACK_SIZE+0x10>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    1050:	9906      	ldr	r1, [sp, #24]
    1052:	9a05      	ldr	r2, [sp, #20]
    1054:	4291      	cmp	r1, r2
    1056:	d3db      	bcc.n	1010 <STACK_SIZE+0x10>
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    1058:	07db      	lsls	r3, r3, #31
    105a:	d5d9      	bpl.n	1010 <STACK_SIZE+0x10>
	if (ctrl->txbuf) {
    105c:	9b03      	ldr	r3, [sp, #12]
    105e:	2b00      	cmp	r3, #0
    1060:	d005      	beq.n	106e <STACK_SIZE+0x6e>
		data = *ctrl->txbuf++;
    1062:	1c59      	adds	r1, r3, #1
    1064:	9103      	str	r1, [sp, #12]
    1066:	7819      	ldrb	r1, [r3, #0]
		if (ctrl->char_size > 1) {
    1068:	2e01      	cmp	r6, #1
    106a:	d8c8      	bhi.n	ffe <_spi_m_sync_trans+0x4e>
    106c:	e7cc      	b.n	1008 <STACK_SIZE+0x8>
		data = SPI_DUMMY_CHAR;
    106e:	4909      	ldr	r1, [pc, #36]	; (1094 <STACK_SIZE+0x94>)
    1070:	e7ca      	b.n	1008 <STACK_SIZE+0x8>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    1072:	7ba3      	ldrb	r3, [r4, #14]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    1074:	079b      	lsls	r3, r3, #30
    1076:	d0fc      	beq.n	1072 <STACK_SIZE+0x72>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    1078:	2303      	movs	r3, #3
    107a:	73a3      	strb	r3, [r4, #14]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    107c:	b008      	add	sp, #32
    107e:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
    1080:	2004      	movs	r0, #4
    1082:	4240      	negs	r0, r0
    1084:	e7fa      	b.n	107c <STACK_SIZE+0x7c>
    1086:	46c0      	nop			; (mov r8, r8)
    1088:	00000a01 	.word	0x00000a01
    108c:	00002d34 	.word	0x00002d34
    1090:	00000601 	.word	0x00000601
    1094:	000001ff 	.word	0x000001ff

00001098 <_sysctrl_init_sources>:
}

static inline hri_sysctrl_osc32k_reg_t hri_sysctrl_read_OSC32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC32K.reg;
    1098:	4a0b      	ldr	r2, [pc, #44]	; (10c8 <_sysctrl_init_sources+0x30>)
    109a:	6993      	ldr	r3, [r2, #24]
	tmp = (tmp & SYSCTRL_OSC32K_CALIB_Msk) >> SYSCTRL_OSC32K_CALIB_Pos;
    109c:	0c1b      	lsrs	r3, r3, #16
	hri_sysctrl_write_OSC32K_reg(
	    hw,
#if CONF_OSC32K_OVERWRITE_CALIBRATION == 1
	    SYSCTRL_OSC32K_CALIB(CONF_OSC32K_CALIB) |
#else
	    SYSCTRL_OSC32K_CALIB(calib) |
    109e:	041b      	lsls	r3, r3, #16
    10a0:	21fe      	movs	r1, #254	; 0xfe
    10a2:	03c9      	lsls	r1, r1, #15
    10a4:	400b      	ands	r3, r1
#endif
	        (CONF_OSC32K_WRTLOCK << SYSCTRL_OSC32K_WRTLOCK_Pos) | SYSCTRL_OSC32K_STARTUP(CONF_OSC32K_STARTUP)
	        | (CONF_OSC32K_RUNSTDBY << SYSCTRL_OSC32K_RUNSTDBY_Pos) | (CONF_OSC32K_EN1K << SYSCTRL_OSC32K_EN1K_Pos)
	        | (CONF_OSC32K_EN32K << SYSCTRL_OSC32K_EN32K_Pos) | (1 << SYSCTRL_OSC32K_ENABLE_Pos));
    10a6:	210e      	movs	r1, #14
    10a8:	430b      	orrs	r3, r1
}

static inline void hri_sysctrl_write_OSC32K_reg(const void *const hw, hri_sysctrl_osc32k_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg = data;
    10aa:	6193      	str	r3, [r2, #24]
}

static inline hri_sysctrl_osculp32k_reg_t hri_sysctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    10ac:	7f13      	ldrb	r3, [r2, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    10ae:	3111      	adds	r1, #17
    10b0:	400b      	ands	r3, r1
}

static inline void hri_sysctrl_write_OSCULP32K_reg(const void *const hw, hri_sysctrl_osculp32k_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    10b2:	7713      	strb	r3, [r2, #28]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) >> SYSCTRL_PCLKSR_OSC32KRDY_Pos;
    10b4:	4b04      	ldr	r3, [pc, #16]	; (10c8 <_sysctrl_init_sources+0x30>)
    10b6:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC32K_CONFIG == 1
#if CONF_OSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(hw))
    10b8:	075b      	lsls	r3, r3, #29
    10ba:	d5fb      	bpl.n	10b4 <_sysctrl_init_sources+0x1c>
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ONDEMAND;
    10bc:	4a02      	ldr	r2, [pc, #8]	; (10c8 <_sysctrl_init_sources+0x30>)
    10be:	6993      	ldr	r3, [r2, #24]
    10c0:	2180      	movs	r1, #128	; 0x80
    10c2:	430b      	orrs	r3, r1
    10c4:	6193      	str	r3, [r2, #24]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
    10c6:	4770      	bx	lr
    10c8:	40000800 	.word	0x40000800

000010cc <_sysctrl_init_referenced_generators>:
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    10cc:	2202      	movs	r2, #2
    10ce:	4b19      	ldr	r3, [pc, #100]	; (1134 <_sysctrl_init_referenced_generators+0x68>)
    10d0:	849a      	strh	r2, [r3, #36]	; 0x24
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    10d2:	4b18      	ldr	r3, [pc, #96]	; (1134 <_sysctrl_init_referenced_generators+0x68>)
    10d4:	68db      	ldr	r3, [r3, #12]
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    10d6:	06db      	lsls	r3, r3, #27
    10d8:	d5fb      	bpl.n	10d2 <_sysctrl_init_referenced_generators+0x6>
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    10da:	4a17      	ldr	r2, [pc, #92]	; (1138 <_sysctrl_init_referenced_generators+0x6c>)
    10dc:	4b15      	ldr	r3, [pc, #84]	; (1134 <_sysctrl_init_referenced_generators+0x68>)
    10de:	62da      	str	r2, [r3, #44]	; 0x2c
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    10e0:	4b16      	ldr	r3, [pc, #88]	; (113c <_sysctrl_init_referenced_generators+0x70>)
    10e2:	681b      	ldr	r3, [r3, #0]
    10e4:	0e9b      	lsrs	r3, r3, #26
    10e6:	2b3f      	cmp	r3, #63	; 0x3f
    10e8:	d01b      	beq.n	1122 <_sysctrl_init_referenced_generators+0x56>
    10ea:	029b      	lsls	r3, r3, #10
    10ec:	2280      	movs	r2, #128	; 0x80
    10ee:	0092      	lsls	r2, r2, #2
    10f0:	4313      	orrs	r3, r2
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    10f2:	4a10      	ldr	r2, [pc, #64]	; (1134 <_sysctrl_init_referenced_generators+0x68>)
    10f4:	6293      	str	r3, [r2, #40]	; 0x28
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    10f6:	2302      	movs	r3, #2
    10f8:	8493      	strh	r3, [r2, #36]	; 0x24
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    10fa:	8c93      	ldrh	r3, [r2, #36]	; 0x24
	hri_sysctrl_write_DFLLCTRL_reg(hw, tmp);
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    10fc:	075b      	lsls	r3, r3, #29
    10fe:	d513      	bpl.n	1128 <_sysctrl_init_referenced_generators+0x5c>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    1100:	4b0c      	ldr	r3, [pc, #48]	; (1134 <_sysctrl_init_referenced_generators+0x68>)
    1102:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
    1104:	23d0      	movs	r3, #208	; 0xd0
    1106:	4013      	ands	r3, r2
		hri_sysctrl_pclksr_reg_t status_mask
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    1108:	2bd0      	cmp	r3, #208	; 0xd0
    110a:	d1f9      	bne.n	1100 <_sysctrl_init_referenced_generators+0x34>
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
    110c:	4a09      	ldr	r2, [pc, #36]	; (1134 <_sysctrl_init_referenced_generators+0x68>)
    110e:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    1110:	2180      	movs	r1, #128	; 0x80
    1112:	430b      	orrs	r3, r1
    1114:	b29b      	uxth	r3, r3
    1116:	8493      	strh	r3, [r2, #36]	; 0x24
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    1118:	4b09      	ldr	r3, [pc, #36]	; (1140 <_sysctrl_init_referenced_generators+0x74>)
    111a:	785b      	ldrb	r3, [r3, #1]
	hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    111c:	09db      	lsrs	r3, r3, #7
    111e:	d1fb      	bne.n	1118 <_sysctrl_init_referenced_generators+0x4c>
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    1120:	4770      	bx	lr
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    1122:	23fc      	movs	r3, #252	; 0xfc
    1124:	01db      	lsls	r3, r3, #7
    1126:	e7e4      	b.n	10f2 <_sysctrl_init_referenced_generators+0x26>
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    1128:	4b02      	ldr	r3, [pc, #8]	; (1134 <_sysctrl_init_referenced_generators+0x68>)
    112a:	68db      	ldr	r3, [r3, #12]
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    112c:	06db      	lsls	r3, r3, #27
    112e:	d5fb      	bpl.n	1128 <_sysctrl_init_referenced_generators+0x5c>
    1130:	e7ec      	b.n	110c <_sysctrl_init_referenced_generators+0x40>
    1132:	46c0      	nop			; (mov r8, r8)
    1134:	40000800 	.word	0x40000800
    1138:	04010000 	.word	0x04010000
    113c:	00806024 	.word	0x00806024
    1140:	40000c00 	.word	0x40000c00

00001144 <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    1144:	4b02      	ldr	r3, [pc, #8]	; (1150 <_system_time_init+0xc>)
    1146:	4a03      	ldr	r2, [pc, #12]	; (1154 <_system_time_init+0x10>)
    1148:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    114a:	2205      	movs	r2, #5
    114c:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    114e:	4770      	bx	lr
    1150:	e000e010 	.word	0xe000e010
    1154:	00ffffff 	.word	0x00ffffff

00001158 <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    1158:	b510      	push	{r4, lr}
	_system_time_init(hw);
    115a:	4b01      	ldr	r3, [pc, #4]	; (1160 <_delay_init+0x8>)
    115c:	4798      	blx	r3
}
    115e:	bd10      	pop	{r4, pc}
    1160:	00001145 	.word	0x00001145

00001164 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
    1164:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
    1166:	e00b      	b.n	1180 <_delay_cycles+0x1c>
		SysTick->LOAD = 0xFFFFFF;
    1168:	4b0b      	ldr	r3, [pc, #44]	; (1198 <_delay_cycles+0x34>)
    116a:	480c      	ldr	r0, [pc, #48]	; (119c <_delay_cycles+0x38>)
    116c:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    116e:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    1170:	4b09      	ldr	r3, [pc, #36]	; (1198 <_delay_cycles+0x34>)
    1172:	681b      	ldr	r3, [r3, #0]
    1174:	03db      	lsls	r3, r3, #15
    1176:	d5fb      	bpl.n	1170 <_delay_cycles+0xc>
			;
		buf -= 0xFFFFFF;
    1178:	4b09      	ldr	r3, [pc, #36]	; (11a0 <_delay_cycles+0x3c>)
    117a:	469c      	mov	ip, r3
    117c:	4461      	add	r1, ip
	while (n--) {
    117e:	0010      	movs	r0, r2
    1180:	1e42      	subs	r2, r0, #1
    1182:	b2d2      	uxtb	r2, r2
    1184:	2800      	cmp	r0, #0
    1186:	d1ef      	bne.n	1168 <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
    1188:	4b03      	ldr	r3, [pc, #12]	; (1198 <_delay_cycles+0x34>)
    118a:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
    118c:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    118e:	4b02      	ldr	r3, [pc, #8]	; (1198 <_delay_cycles+0x34>)
    1190:	681b      	ldr	r3, [r3, #0]
    1192:	03db      	lsls	r3, r3, #15
    1194:	d5fb      	bpl.n	118e <_delay_cycles+0x2a>
		;
}
    1196:	4770      	bx	lr
    1198:	e000e010 	.word	0xe000e010
    119c:	00ffffff 	.word	0x00ffffff
    11a0:	ff000001 	.word	0xff000001

000011a4 <I2C_RTC_Handler>:

uint8_t rtcIntCount = 0;
uint8_t rfIntCount = 0;

static void I2C_RTC_Handler(void){
	if (rtcIntCount < 255) {
    11a4:	4b03      	ldr	r3, [pc, #12]	; (11b4 <I2C_RTC_Handler+0x10>)
    11a6:	781b      	ldrb	r3, [r3, #0]
    11a8:	2bff      	cmp	r3, #255	; 0xff
    11aa:	d002      	beq.n	11b2 <I2C_RTC_Handler+0xe>
		rtcIntCount++;
    11ac:	3301      	adds	r3, #1
    11ae:	4a01      	ldr	r2, [pc, #4]	; (11b4 <I2C_RTC_Handler+0x10>)
    11b0:	7013      	strb	r3, [r2, #0]
	}
}
    11b2:	4770      	bx	lr
    11b4:	2000004d 	.word	0x2000004d

000011b8 <RF_int_Handler>:
	return res;
}


static void RF_int_Handler(void){
	if(rfIntCount < 255){
    11b8:	4b03      	ldr	r3, [pc, #12]	; (11c8 <RF_int_Handler+0x10>)
    11ba:	781b      	ldrb	r3, [r3, #0]
    11bc:	2bff      	cmp	r3, #255	; 0xff
    11be:	d002      	beq.n	11c6 <RF_int_Handler+0xe>
		rfIntCount++;
    11c0:	3301      	adds	r3, #1
    11c2:	4a01      	ldr	r2, [pc, #4]	; (11c8 <RF_int_Handler+0x10>)
    11c4:	7013      	strb	r3, [r2, #0]
	}	
}
    11c6:	4770      	bx	lr
    11c8:	2000004c 	.word	0x2000004c

000011cc <RTC_IRQ_Ready>:
	uint8_t res = rtcIntCount;
    11cc:	4b02      	ldr	r3, [pc, #8]	; (11d8 <RTC_IRQ_Ready+0xc>)
    11ce:	7818      	ldrb	r0, [r3, #0]
	rtcIntCount = 0;
    11d0:	2200      	movs	r2, #0
    11d2:	701a      	strb	r2, [r3, #0]
}
    11d4:	4770      	bx	lr
    11d6:	46c0      	nop			; (mov r8, r8)
    11d8:	2000004d 	.word	0x2000004d

000011dc <SPI0_WriteBuff>:
}

void SPI0_ReadBuff(uint8_t* buff, uint16_t len){
	io_read(spi0,buff,len);
}
void SPI0_WriteBuff(uint8_t* buff, uint16_t len){
    11dc:	b510      	push	{r4, lr}
    11de:	0003      	movs	r3, r0
    11e0:	000a      	movs	r2, r1
	io_write(spi0,buff,len);
    11e2:	4903      	ldr	r1, [pc, #12]	; (11f0 <SPI0_WriteBuff+0x14>)
    11e4:	6808      	ldr	r0, [r1, #0]
    11e6:	0019      	movs	r1, r3
    11e8:	4b02      	ldr	r3, [pc, #8]	; (11f4 <SPI0_WriteBuff+0x18>)
    11ea:	4798      	blx	r3
}
    11ec:	bd10      	pop	{r4, pc}
    11ee:	46c0      	nop			; (mov r8, r8)
    11f0:	20001728 	.word	0x20001728
    11f4:	00000459 	.word	0x00000459

000011f8 <RTC_write_batch>:
void SPI0_Write_byte(uint8_t byte){
	io_write(spi0, &byte, 1);
}


bool RTC_write_batch(uint8_t addres, uint8_t *data, uint8_t data_len){
    11f8:	b570      	push	{r4, r5, r6, lr}
    11fa:	000d      	movs	r5, r1
    11fc:	0014      	movs	r4, r2
	i2c_m_sync_set_slaveaddr(&I2C_0, addres, I2C_M_SEVEN);
    11fe:	b201      	sxth	r1, r0
    1200:	2280      	movs	r2, #128	; 0x80
    1202:	0112      	lsls	r2, r2, #4
    1204:	4805      	ldr	r0, [pc, #20]	; (121c <RTC_write_batch+0x24>)
    1206:	4b06      	ldr	r3, [pc, #24]	; (1220 <RTC_write_batch+0x28>)
    1208:	4798      	blx	r3
	//i2c_m_sync_cmd_write(&EXT_I2C, 0x00, data, data_len);	
	return (io_write(i2c0, (uint8_t *)data, data_len) >= 0) ? true : false;
    120a:	b2a2      	uxth	r2, r4
    120c:	4b05      	ldr	r3, [pc, #20]	; (1224 <RTC_write_batch+0x2c>)
    120e:	6818      	ldr	r0, [r3, #0]
    1210:	0029      	movs	r1, r5
    1212:	4b05      	ldr	r3, [pc, #20]	; (1228 <RTC_write_batch+0x30>)
    1214:	4798      	blx	r3
    1216:	43c0      	mvns	r0, r0
    1218:	0fc0      	lsrs	r0, r0, #31
}
    121a:	bd70      	pop	{r4, r5, r6, pc}
    121c:	200016e8 	.word	0x200016e8
    1220:	000003f5 	.word	0x000003f5
    1224:	20001724 	.word	0x20001724
    1228:	00000459 	.word	0x00000459

0000122c <RTC_read_batch>:

bool RTC_read_batch(uint8_t addres ,uint8_t *data, uint8_t data_len){
    122c:	b570      	push	{r4, r5, r6, lr}
    122e:	000c      	movs	r4, r1
    1230:	0015      	movs	r5, r2
	i2c_m_sync_set_slaveaddr(&I2C_0, addres, I2C_M_SEVEN);
    1232:	b201      	sxth	r1, r0
    1234:	4e06      	ldr	r6, [pc, #24]	; (1250 <RTC_read_batch+0x24>)
    1236:	2280      	movs	r2, #128	; 0x80
    1238:	0112      	lsls	r2, r2, #4
    123a:	0030      	movs	r0, r6
    123c:	4b05      	ldr	r3, [pc, #20]	; (1254 <RTC_read_batch+0x28>)
    123e:	4798      	blx	r3
	i2c_m_sync_cmd_read(&I2C_0, 0x00, data, data_len);
    1240:	002b      	movs	r3, r5
    1242:	0022      	movs	r2, r4
    1244:	2100      	movs	r1, #0
    1246:	0030      	movs	r0, r6
    1248:	4c03      	ldr	r4, [pc, #12]	; (1258 <RTC_read_batch+0x2c>)
    124a:	47a0      	blx	r4
	//return (io_read(I2C_io, (uint8_t *)data, data_len) >= 0) ? true : false;
}
    124c:	bd70      	pop	{r4, r5, r6, pc}
    124e:	46c0      	nop			; (mov r8, r8)
    1250:	200016e8 	.word	0x200016e8
    1254:	000003f5 	.word	0x000003f5
    1258:	00000409 	.word	0x00000409

0000125c <GPIO_init>:
	i2c_m_sync_set_slaveaddr(&I2C_0, addres, I2C_M_SEVEN);
	i2c_m_sync_cmd_read(&I2C_0, reg, data, data_len);
}


void GPIO_init(void){
    125c:	b5f0      	push	{r4, r5, r6, r7, lr}
    125e:	46ce      	mov	lr, r9
    1260:	4647      	mov	r7, r8
    1262:	b580      	push	{r7, lr}
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1264:	22c0      	movs	r2, #192	; 0xc0
    1266:	05d2      	lsls	r2, r2, #23
    1268:	2380      	movs	r3, #128	; 0x80
    126a:	031b      	lsls	r3, r3, #12
    126c:	6193      	str	r3, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    126e:	6093      	str	r3, [r2, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1270:	4b35      	ldr	r3, [pc, #212]	; (1348 <GPIO_init+0xec>)
    1272:	2480      	movs	r4, #128	; 0x80
    1274:	05e4      	lsls	r4, r4, #23
    1276:	629c      	str	r4, [r3, #40]	; 0x28
    1278:	4934      	ldr	r1, [pc, #208]	; (134c <GPIO_init+0xf0>)
    127a:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    127c:	2553      	movs	r5, #83	; 0x53
    127e:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1280:	2101      	movs	r1, #1
    1282:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1284:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1286:	2080      	movs	r0, #128	; 0x80
    1288:	01c0      	lsls	r0, r0, #7
    128a:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    128c:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    128e:	4830      	ldr	r0, [pc, #192]	; (1350 <GPIO_init+0xf4>)
    1290:	6298      	str	r0, [r3, #40]	; 0x28
    1292:	20c0      	movs	r0, #192	; 0xc0
    1294:	0600      	lsls	r0, r0, #24
    1296:	4681      	mov	r9, r0
    1298:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    129a:	3d05      	subs	r5, #5
    129c:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    129e:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    12a0:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    12a2:	2080      	movs	r0, #128	; 0x80
    12a4:	0200      	lsls	r0, r0, #8
    12a6:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    12a8:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    12aa:	482a      	ldr	r0, [pc, #168]	; (1354 <GPIO_init+0xf8>)
    12ac:	6298      	str	r0, [r3, #40]	; 0x28
    12ae:	4648      	mov	r0, r9
    12b0:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    12b2:	3501      	adds	r5, #1
    12b4:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    12b6:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    12b8:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    12ba:	2080      	movs	r0, #128	; 0x80
    12bc:	0240      	lsls	r0, r0, #9
    12be:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    12c0:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    12c2:	629c      	str	r4, [r3, #40]	; 0x28
    12c4:	4824      	ldr	r0, [pc, #144]	; (1358 <GPIO_init+0xfc>)
    12c6:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    12c8:	3501      	adds	r5, #1
    12ca:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    12cc:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    12ce:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    12d0:	2780      	movs	r7, #128	; 0x80
    12d2:	02bf      	lsls	r7, r7, #10
    12d4:	6057      	str	r7, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    12d6:	4821      	ldr	r0, [pc, #132]	; (135c <GPIO_init+0x100>)
    12d8:	6298      	str	r0, [r3, #40]	; 0x28
    12da:	4821      	ldr	r0, [pc, #132]	; (1360 <GPIO_init+0x104>)
    12dc:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    12de:	6057      	str	r7, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    12e0:	3501      	adds	r5, #1
    12e2:	5d58      	ldrb	r0, [r3, r5]
    12e4:	4680      	mov	r8, r0
    12e6:	2004      	movs	r0, #4
    12e8:	4684      	mov	ip, r0
    12ea:	4660      	mov	r0, ip
    12ec:	4646      	mov	r6, r8
    12ee:	4306      	orrs	r6, r0
    12f0:	b2f0      	uxtb	r0, r6
    12f2:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    12f4:	6197      	str	r7, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    12f6:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    12f8:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    12fa:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    12fc:	2080      	movs	r0, #128	; 0x80
    12fe:	02c0      	lsls	r0, r0, #11
    1300:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1302:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1304:	629c      	str	r4, [r3, #40]	; 0x28
    1306:	4817      	ldr	r0, [pc, #92]	; (1364 <GPIO_init+0x108>)
    1308:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    130a:	3501      	adds	r5, #1
    130c:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    130e:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1310:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1312:	2080      	movs	r0, #128	; 0x80
    1314:	0500      	lsls	r0, r0, #20
    1316:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1318:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    131a:	629c      	str	r4, [r3, #40]	; 0x28
    131c:	4812      	ldr	r0, [pc, #72]	; (1368 <GPIO_init+0x10c>)
    131e:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1320:	245b      	movs	r4, #91	; 0x5b
    1322:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1324:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1326:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1328:	2080      	movs	r0, #128	; 0x80
    132a:	0100      	lsls	r0, r0, #4
    132c:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    132e:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1330:	4a0e      	ldr	r2, [pc, #56]	; (136c <GPIO_init+0x110>)
    1332:	629a      	str	r2, [r3, #40]	; 0x28
    1334:	464a      	mov	r2, r9
    1336:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1338:	204b      	movs	r0, #75	; 0x4b
    133a:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    133c:	438a      	bics	r2, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    133e:	541a      	strb	r2, [r3, r0]
	gpio_set_pin_function(EP_EN, GPIO_PIN_FUNCTION_OFF);
	
	gpio_set_pin_level(EP_RST, true);
	gpio_set_pin_direction(EP_RST, GPIO_DIRECTION_OUT);
	gpio_set_pin_function(EP_RST, GPIO_PIN_FUNCTION_OFF);	
}
    1340:	bc0c      	pop	{r2, r3}
    1342:	4690      	mov	r8, r2
    1344:	4699      	mov	r9, r3
    1346:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1348:	41004400 	.word	0x41004400
    134c:	c0000008 	.word	0xc0000008
    1350:	40004000 	.word	0x40004000
    1354:	40008000 	.word	0x40008000
    1358:	c0000001 	.word	0xc0000001
    135c:	40020000 	.word	0x40020000
    1360:	c0020002 	.word	0xc0020002
    1364:	c0000004 	.word	0xc0000004
    1368:	c0000800 	.word	0xc0000800
    136c:	40000800 	.word	0x40000800

00001370 <SPI_init>:


void SPI_init(void){
    1370:	b5f0      	push	{r4, r5, r6, r7, lr}
    1372:	46c6      	mov	lr, r8
    1374:	b500      	push	{lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1376:	21c0      	movs	r1, #192	; 0xc0
    1378:	05c9      	lsls	r1, r1, #23
    137a:	2380      	movs	r3, #128	; 0x80
    137c:	005b      	lsls	r3, r3, #1
    137e:	614b      	str	r3, [r1, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1380:	608b      	str	r3, [r1, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1382:	4b30      	ldr	r3, [pc, #192]	; (1444 <SPI_init+0xd4>)
    1384:	4a30      	ldr	r2, [pc, #192]	; (1448 <SPI_init+0xd8>)
    1386:	629a      	str	r2, [r3, #40]	; 0x28
    1388:	22c0      	movs	r2, #192	; 0xc0
    138a:	0612      	lsls	r2, r2, #24
    138c:	4694      	mov	ip, r2
    138e:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1390:	2448      	movs	r4, #72	; 0x48
    1392:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1394:	2601      	movs	r6, #1
    1396:	43b0      	bics	r0, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1398:	2201      	movs	r2, #1
    139a:	4310      	orrs	r0, r2
    139c:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    139e:	5518      	strb	r0, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    13a0:	2734      	movs	r7, #52	; 0x34
    13a2:	5dd8      	ldrb	r0, [r3, r7]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    13a4:	250f      	movs	r5, #15
    13a6:	43a8      	bics	r0, r5
	tmp |= PORT_PMUX_PMUXE(data);
    13a8:	2402      	movs	r4, #2
    13aa:	46a0      	mov	r8, r4
    13ac:	4644      	mov	r4, r8
    13ae:	4320      	orrs	r0, r4
    13b0:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    13b2:	55d8      	strb	r0, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    13b4:	2080      	movs	r0, #128	; 0x80
    13b6:	0080      	lsls	r0, r0, #2
    13b8:	6148      	str	r0, [r1, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    13ba:	6088      	str	r0, [r1, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    13bc:	4823      	ldr	r0, [pc, #140]	; (144c <SPI_init+0xdc>)
    13be:	6298      	str	r0, [r3, #40]	; 0x28
    13c0:	4660      	mov	r0, ip
    13c2:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    13c4:	2049      	movs	r0, #73	; 0x49
    13c6:	4684      	mov	ip, r0
    13c8:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    13ca:	43b0      	bics	r0, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    13cc:	4310      	orrs	r0, r2
    13ce:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    13d0:	4664      	mov	r4, ip
    13d2:	5518      	strb	r0, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    13d4:	5dd8      	ldrb	r0, [r3, r7]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    13d6:	3c3a      	subs	r4, #58	; 0x3a
    13d8:	4020      	ands	r0, r4
	tmp |= PORT_PMUX_PMUXO(data);
    13da:	2420      	movs	r4, #32
    13dc:	46a4      	mov	ip, r4
    13de:	4664      	mov	r4, ip
    13e0:	4320      	orrs	r0, r4
    13e2:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    13e4:	55d8      	strb	r0, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    13e6:	2080      	movs	r0, #128	; 0x80
    13e8:	00c0      	lsls	r0, r0, #3
    13ea:	6048      	str	r0, [r1, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    13ec:	4918      	ldr	r1, [pc, #96]	; (1450 <SPI_init+0xe0>)
    13ee:	6299      	str	r1, [r3, #40]	; 0x28
    13f0:	4918      	ldr	r1, [pc, #96]	; (1454 <SPI_init+0xe4>)
    13f2:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    13f4:	3716      	adds	r7, #22
    13f6:	5dd9      	ldrb	r1, [r3, r7]
    13f8:	2004      	movs	r0, #4
    13fa:	4381      	bics	r1, r0
    13fc:	55d9      	strb	r1, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    13fe:	5dd9      	ldrb	r1, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1400:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1402:	4311      	orrs	r1, r2
    1404:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1406:	55d9      	strb	r1, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1408:	2135      	movs	r1, #53	; 0x35
    140a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    140c:	43aa      	bics	r2, r5
	tmp |= PORT_PMUX_PMUXE(data);
    140e:	4644      	mov	r4, r8
    1410:	4322      	orrs	r2, r4
    1412:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1414:	545a      	strb	r2, [r3, r1]
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
    1416:	4a10      	ldr	r2, [pc, #64]	; (1458 <SPI_init+0xe8>)
    1418:	6a13      	ldr	r3, [r2, #32]
    141a:	4318      	orrs	r0, r3
    141c:	6210      	str	r0, [r2, #32]
	((Gclk *)hw)->CLKCTRL.reg = data;
    141e:	4a0f      	ldr	r2, [pc, #60]	; (145c <SPI_init+0xec>)
    1420:	4b0f      	ldr	r3, [pc, #60]	; (1460 <SPI_init+0xf0>)
    1422:	805a      	strh	r2, [r3, #2]
	gpio_set_pin_function(PA10, PINMUX_PA10C_SERCOM0_PAD2);
	
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM0);
	_gclk_enable_channel(SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC);
	
	spi_m_sync_init(&SPI_0, SERCOM0);
    1424:	4c0f      	ldr	r4, [pc, #60]	; (1464 <SPI_init+0xf4>)
    1426:	4910      	ldr	r1, [pc, #64]	; (1468 <SPI_init+0xf8>)
    1428:	0020      	movs	r0, r4
    142a:	4b10      	ldr	r3, [pc, #64]	; (146c <SPI_init+0xfc>)
    142c:	4798      	blx	r3
	spi_m_sync_get_io_descriptor(&SPI_0, &spi0);
    142e:	4910      	ldr	r1, [pc, #64]	; (1470 <SPI_init+0x100>)
    1430:	0020      	movs	r0, r4
    1432:	4b10      	ldr	r3, [pc, #64]	; (1474 <SPI_init+0x104>)
    1434:	4798      	blx	r3
	spi_m_sync_enable(&SPI_0);
    1436:	0020      	movs	r0, r4
    1438:	4b0f      	ldr	r3, [pc, #60]	; (1478 <SPI_init+0x108>)
    143a:	4798      	blx	r3
	
}
    143c:	bc04      	pop	{r2}
    143e:	4690      	mov	r8, r2
    1440:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1442:	46c0      	nop			; (mov r8, r8)
    1444:	41004400 	.word	0x41004400
    1448:	40000100 	.word	0x40000100
    144c:	40000200 	.word	0x40000200
    1450:	40020400 	.word	0x40020400
    1454:	c0020000 	.word	0xc0020000
    1458:	40000400 	.word	0x40000400
    145c:	0000400d 	.word	0x0000400d
    1460:	40000c00 	.word	0x40000c00
    1464:	2000170c 	.word	0x2000170c
    1468:	42000800 	.word	0x42000800
    146c:	00000491 	.word	0x00000491
    1470:	20001728 	.word	0x20001728
    1474:	000005d1 	.word	0x000005d1
    1478:	000004e9 	.word	0x000004e9

0000147c <I2C_init>:



void I2C_init(void){
    147c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    147e:	4a1e      	ldr	r2, [pc, #120]	; (14f8 <I2C_init+0x7c>)
    1480:	6a13      	ldr	r3, [r2, #32]
    1482:	2120      	movs	r1, #32
    1484:	430b      	orrs	r3, r1
    1486:	6213      	str	r3, [r2, #32]
    1488:	4b1c      	ldr	r3, [pc, #112]	; (14fc <I2C_init+0x80>)
    148a:	4a1d      	ldr	r2, [pc, #116]	; (1500 <I2C_init+0x84>)
    148c:	805a      	strh	r2, [r3, #2]
    148e:	4a1d      	ldr	r2, [pc, #116]	; (1504 <I2C_init+0x88>)
    1490:	805a      	strh	r2, [r3, #2]
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM3);
	_gclk_enable_channel(SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC);
	_gclk_enable_channel(SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC);
	
	i2c_m_sync_init(&I2C_0, SERCOM3);
    1492:	4c1d      	ldr	r4, [pc, #116]	; (1508 <I2C_init+0x8c>)
    1494:	491d      	ldr	r1, [pc, #116]	; (150c <I2C_init+0x90>)
    1496:	0020      	movs	r0, r4
    1498:	4b1d      	ldr	r3, [pc, #116]	; (1510 <I2C_init+0x94>)
    149a:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    149c:	4b1d      	ldr	r3, [pc, #116]	; (1514 <I2C_init+0x98>)
    149e:	2056      	movs	r0, #86	; 0x56
    14a0:	5c19      	ldrb	r1, [r3, r0]
    14a2:	2204      	movs	r2, #4
    14a4:	4391      	bics	r1, r2
    14a6:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    14a8:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    14aa:	2601      	movs	r6, #1
    14ac:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    14ae:	2501      	movs	r5, #1
    14b0:	4329      	orrs	r1, r5
    14b2:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    14b4:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    14b6:	381b      	subs	r0, #27
    14b8:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    14ba:	270f      	movs	r7, #15
    14bc:	43b9      	bics	r1, r7
	tmp |= PORT_PMUX_PMUXE(data);
    14be:	2702      	movs	r7, #2
    14c0:	4339      	orrs	r1, r7
    14c2:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    14c4:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    14c6:	2157      	movs	r1, #87	; 0x57
    14c8:	5c5f      	ldrb	r7, [r3, r1]
    14ca:	4397      	bics	r7, r2
    14cc:	545f      	strb	r7, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    14ce:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    14d0:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    14d2:	432a      	orrs	r2, r5
    14d4:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    14d6:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    14d8:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    14da:	3948      	subs	r1, #72	; 0x48
    14dc:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
    14de:	2120      	movs	r1, #32
    14e0:	430a      	orrs	r2, r1
    14e2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    14e4:	541a      	strb	r2, [r3, r0]
	gpio_set_pin_function(PA22, PINMUX_PA22C_SERCOM3_PAD0);

	gpio_set_pin_pull_mode(PA23, GPIO_PULL_OFF);
	gpio_set_pin_function(PA23, PINMUX_PA23C_SERCOM3_PAD1);

	i2c_m_sync_get_io_descriptor(&I2C_0, &i2c0);
    14e6:	490c      	ldr	r1, [pc, #48]	; (1518 <I2C_init+0x9c>)
    14e8:	0020      	movs	r0, r4
    14ea:	4b0c      	ldr	r3, [pc, #48]	; (151c <I2C_init+0xa0>)
    14ec:	4798      	blx	r3
	i2c_m_sync_enable(&I2C_0);
    14ee:	0020      	movs	r0, r4
    14f0:	4b0b      	ldr	r3, [pc, #44]	; (1520 <I2C_init+0xa4>)
    14f2:	4798      	blx	r3
	
}
    14f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    14f6:	46c0      	nop			; (mov r8, r8)
    14f8:	40000400 	.word	0x40000400
    14fc:	40000c00 	.word	0x40000c00
    1500:	00004010 	.word	0x00004010
    1504:	0000430c 	.word	0x0000430c
    1508:	200016e8 	.word	0x200016e8
    150c:	42001400 	.word	0x42001400
    1510:	000003a9 	.word	0x000003a9
    1514:	41004400 	.word	0x41004400
    1518:	20001724 	.word	0x20001724
    151c:	00000451 	.word	0x00000451
    1520:	000003e9 	.word	0x000003e9

00001524 <IRQ_init>:

void IRQ_init(void){
    1524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1526:	4a1a      	ldr	r2, [pc, #104]	; (1590 <IRQ_init+0x6c>)
    1528:	4b1a      	ldr	r3, [pc, #104]	; (1594 <IRQ_init+0x70>)
    152a:	805a      	strh	r2, [r3, #2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    152c:	27c0      	movs	r7, #192	; 0xc0
    152e:	05ff      	lsls	r7, r7, #23
    1530:	2380      	movs	r3, #128	; 0x80
    1532:	607b      	str	r3, [r7, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1534:	4b18      	ldr	r3, [pc, #96]	; (1598 <IRQ_init+0x74>)
    1536:	4a19      	ldr	r2, [pc, #100]	; (159c <IRQ_init+0x78>)
    1538:	629a      	str	r2, [r3, #40]	; 0x28
    153a:	4a19      	ldr	r2, [pc, #100]	; (15a0 <IRQ_init+0x7c>)
    153c:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    153e:	2047      	movs	r0, #71	; 0x47
    1540:	5c19      	ldrb	r1, [r3, r0]
    1542:	2204      	movs	r2, #4
    1544:	4391      	bics	r1, r2
    1546:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1548:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    154a:	2501      	movs	r5, #1
    154c:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    154e:	2401      	movs	r4, #1
    1550:	4321      	orrs	r1, r4
    1552:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1554:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1556:	3814      	subs	r0, #20
    1558:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    155a:	260f      	movs	r6, #15
    155c:	4031      	ands	r1, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    155e:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1560:	2180      	movs	r1, #128	; 0x80
    1562:	0489      	lsls	r1, r1, #18
    1564:	6079      	str	r1, [r7, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1566:	490f      	ldr	r1, [pc, #60]	; (15a4 <IRQ_init+0x80>)
    1568:	6299      	str	r1, [r3, #40]	; 0x28
    156a:	490f      	ldr	r1, [pc, #60]	; (15a8 <IRQ_init+0x84>)
    156c:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    156e:	2159      	movs	r1, #89	; 0x59
    1570:	5c58      	ldrb	r0, [r3, r1]
    1572:	4390      	bics	r0, r2
    1574:	5458      	strb	r0, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1576:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1578:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    157a:	4322      	orrs	r2, r4
    157c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    157e:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1580:	391d      	subs	r1, #29
    1582:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1584:	4032      	ands	r2, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1586:	545a      	strb	r2, [r3, r1]
	
	gpio_set_pin_direction(RTC_INT, GPIO_DIRECTION_IN);
	gpio_set_pin_pull_mode(RTC_INT, GPIO_PULL_OFF);
	gpio_set_pin_function(RTC_INT, PINMUX_PA25A_EIC_EXTINT13);

	ext_irq_init();
    1588:	4b08      	ldr	r3, [pc, #32]	; (15ac <IRQ_init+0x88>)
    158a:	4798      	blx	r3
}
    158c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    158e:	46c0      	nop			; (mov r8, r8)
    1590:	00004103 	.word	0x00004103
    1594:	40000c00 	.word	0x40000c00
    1598:	41004400 	.word	0x41004400
    159c:	40020080 	.word	0x40020080
    15a0:	c0020000 	.word	0xc0020000
    15a4:	40020000 	.word	0x40020000
    15a8:	c0020200 	.word	0xc0020200
    15ac:	00000225 	.word	0x00000225

000015b0 <mcu_init>:



void mcu_init(void)
{
    15b0:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    15b2:	4b0a      	ldr	r3, [pc, #40]	; (15dc <mcu_init+0x2c>)
    15b4:	4798      	blx	r3
	init_mcu();
	GPIO_init();
    15b6:	4b0a      	ldr	r3, [pc, #40]	; (15e0 <mcu_init+0x30>)
    15b8:	4798      	blx	r3
	SPI_init();
    15ba:	4b0a      	ldr	r3, [pc, #40]	; (15e4 <mcu_init+0x34>)
    15bc:	4798      	blx	r3
	I2C_init();
    15be:	4b0a      	ldr	r3, [pc, #40]	; (15e8 <mcu_init+0x38>)
    15c0:	4798      	blx	r3
	IRQ_init();
    15c2:	4b0a      	ldr	r3, [pc, #40]	; (15ec <mcu_init+0x3c>)
    15c4:	4798      	blx	r3
	
	
	ext_irq_register(RTC_INT, I2C_RTC_Handler);
    15c6:	490a      	ldr	r1, [pc, #40]	; (15f0 <mcu_init+0x40>)
    15c8:	2019      	movs	r0, #25
    15ca:	4c0a      	ldr	r4, [pc, #40]	; (15f4 <mcu_init+0x44>)
    15cc:	47a0      	blx	r4
	ext_irq_register(RF_INT, RF_int_Handler);	
    15ce:	490a      	ldr	r1, [pc, #40]	; (15f8 <mcu_init+0x48>)
    15d0:	2007      	movs	r0, #7
    15d2:	47a0      	blx	r4
	
	delay_driver_init();
    15d4:	4b09      	ldr	r3, [pc, #36]	; (15fc <mcu_init+0x4c>)
    15d6:	4798      	blx	r3
	//...Peripherial init
	
    15d8:	bd10      	pop	{r4, pc}
    15da:	46c0      	nop			; (mov r8, r8)
    15dc:	00000615 	.word	0x00000615
    15e0:	0000125d 	.word	0x0000125d
    15e4:	00001371 	.word	0x00001371
    15e8:	0000147d 	.word	0x0000147d
    15ec:	00001525 	.word	0x00001525
    15f0:	000011a5 	.word	0x000011a5
    15f4:	00000259 	.word	0x00000259
    15f8:	000011b9 	.word	0x000011b9
    15fc:	0000017d 	.word	0x0000017d

00001600 <epdReset>:
/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	if (level) {
    1600:	2800      	cmp	r0, #0
    1602:	d105      	bne.n	1610 <epdReset+0x10>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1604:	2280      	movs	r2, #128	; 0x80
    1606:	0112      	lsls	r2, r2, #4
    1608:	23c0      	movs	r3, #192	; 0xc0
    160a:	05db      	lsls	r3, r3, #23
    160c:	615a      	str	r2, [r3, #20]
	
}

void epdReset(bool arg){
	gpio_set_pin_level(EP_RST, arg);
}
    160e:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1610:	2280      	movs	r2, #128	; 0x80
    1612:	0112      	lsls	r2, r2, #4
    1614:	23c0      	movs	r3, #192	; 0xc0
    1616:	05db      	lsls	r3, r3, #23
    1618:	619a      	str	r2, [r3, #24]
    161a:	e7f8      	b.n	160e <epdReset+0xe>

0000161c <epdSelect>:
    161c:	2800      	cmp	r0, #0
    161e:	d105      	bne.n	162c <epdSelect+0x10>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1620:	2280      	movs	r2, #128	; 0x80
    1622:	0212      	lsls	r2, r2, #8
    1624:	23c0      	movs	r3, #192	; 0xc0
    1626:	05db      	lsls	r3, r3, #23
    1628:	615a      	str	r2, [r3, #20]

void epdSelect(bool arg){
	gpio_set_pin_level(EP_CS, arg);
}
    162a:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    162c:	2280      	movs	r2, #128	; 0x80
    162e:	0212      	lsls	r2, r2, #8
    1630:	23c0      	movs	r3, #192	; 0xc0
    1632:	05db      	lsls	r3, r3, #23
    1634:	619a      	str	r2, [r3, #24]
    1636:	e7f8      	b.n	162a <epdSelect+0xe>

00001638 <epdCommand>:
    1638:	2800      	cmp	r0, #0
    163a:	d105      	bne.n	1648 <epdCommand+0x10>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    163c:	2280      	movs	r2, #128	; 0x80
    163e:	0252      	lsls	r2, r2, #9
    1640:	23c0      	movs	r3, #192	; 0xc0
    1642:	05db      	lsls	r3, r3, #23
    1644:	615a      	str	r2, [r3, #20]

void epdCommand(bool arg){
	gpio_set_pin_level(EP_CMD, arg);
}
    1646:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1648:	2280      	movs	r2, #128	; 0x80
    164a:	0252      	lsls	r2, r2, #9
    164c:	23c0      	movs	r3, #192	; 0xc0
    164e:	05db      	lsls	r3, r3, #23
    1650:	619a      	str	r2, [r3, #24]
    1652:	e7f8      	b.n	1646 <epdCommand+0xe>

00001654 <epdWriteBuff>:

void epdWriteByte(uint8_t arg){
	SPI0_WriteBuff(arg);
}

void epdWriteBuff(uint8_t* buff, uint16_t len){
    1654:	b510      	push	{r4, lr}
	SPI0_WriteBuff(buff, len);
    1656:	4b01      	ldr	r3, [pc, #4]	; (165c <epdWriteBuff+0x8>)
    1658:	4798      	blx	r3
}
    165a:	bd10      	pop	{r4, pc}
    165c:	000011dd 	.word	0x000011dd

00001660 <screenSpi>:

uint8_t screenSpi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    1660:	b510      	push	{r4, lr}
	
	switch(msg)
    1662:	3914      	subs	r1, #20
    1664:	b2cc      	uxtb	r4, r1
    1666:	2c37      	cmp	r4, #55	; 0x37
    1668:	d803      	bhi.n	1672 <screenSpi+0x12>
    166a:	00a1      	lsls	r1, r4, #2
    166c:	4819      	ldr	r0, [pc, #100]	; (16d4 <screenSpi+0x74>)
    166e:	5841      	ldr	r1, [r0, r1]
    1670:	468f      	mov	pc, r1
		case U8X8_MSG_BYTE_END_TRANSFER:
			epdSelect(true);
			epdCommand(true);
			break;
		default:
			return 0;
    1672:	2000      	movs	r0, #0
    1674:	e02c      	b.n	16d0 <screenSpi+0x70>
			epdReset((arg_int != 1) ?  false : true);
    1676:	3a01      	subs	r2, #1
    1678:	4250      	negs	r0, r2
    167a:	4150      	adcs	r0, r2
    167c:	b2c0      	uxtb	r0, r0
    167e:	4b16      	ldr	r3, [pc, #88]	; (16d8 <screenSpi+0x78>)
    1680:	4798      	blx	r3
	}
	return 1;
    1682:	2001      	movs	r0, #1
			break;
    1684:	e024      	b.n	16d0 <screenSpi+0x70>
			delay_ms(arg_int);
    1686:	b290      	uxth	r0, r2
    1688:	4b14      	ldr	r3, [pc, #80]	; (16dc <screenSpi+0x7c>)
    168a:	4798      	blx	r3
	return 1;
    168c:	2001      	movs	r0, #1
			break;
    168e:	e01f      	b.n	16d0 <screenSpi+0x70>
			epdWriteBuff(arg_ptr, arg_int);
    1690:	b291      	uxth	r1, r2
    1692:	0018      	movs	r0, r3
    1694:	4b12      	ldr	r3, [pc, #72]	; (16e0 <screenSpi+0x80>)
    1696:	4798      	blx	r3
	return 1;
    1698:	2001      	movs	r0, #1
			break;
    169a:	e019      	b.n	16d0 <screenSpi+0x70>
			epdSelect(false);
    169c:	2000      	movs	r0, #0
    169e:	4b11      	ldr	r3, [pc, #68]	; (16e4 <screenSpi+0x84>)
    16a0:	4798      	blx	r3
	return 1;
    16a2:	2001      	movs	r0, #1
			break;
    16a4:	e014      	b.n	16d0 <screenSpi+0x70>
			epdCommand(arg_int);
    16a6:	1e50      	subs	r0, r2, #1
    16a8:	4182      	sbcs	r2, r0
    16aa:	b2d0      	uxtb	r0, r2
    16ac:	4b0e      	ldr	r3, [pc, #56]	; (16e8 <screenSpi+0x88>)
    16ae:	4798      	blx	r3
	return 1;
    16b0:	2001      	movs	r0, #1
			break;
    16b2:	e00d      	b.n	16d0 <screenSpi+0x70>
			epdSelect(false);
    16b4:	2000      	movs	r0, #0
    16b6:	4b0b      	ldr	r3, [pc, #44]	; (16e4 <screenSpi+0x84>)
    16b8:	4798      	blx	r3
	return 1;
    16ba:	2001      	movs	r0, #1
			break;
    16bc:	e008      	b.n	16d0 <screenSpi+0x70>
			epdSelect(true);
    16be:	2001      	movs	r0, #1
    16c0:	4b08      	ldr	r3, [pc, #32]	; (16e4 <screenSpi+0x84>)
    16c2:	4798      	blx	r3
			epdCommand(true);
    16c4:	2001      	movs	r0, #1
    16c6:	4b08      	ldr	r3, [pc, #32]	; (16e8 <screenSpi+0x88>)
    16c8:	4798      	blx	r3
	return 1;
    16ca:	2001      	movs	r0, #1
			break;
    16cc:	e000      	b.n	16d0 <screenSpi+0x70>
	return 1;
    16ce:	2001      	movs	r0, #1
}
    16d0:	bd10      	pop	{r4, pc}
    16d2:	46c0      	nop			; (mov r8, r8)
    16d4:	00002d78 	.word	0x00002d78
    16d8:	00001601 	.word	0x00001601
    16dc:	000001c1 	.word	0x000001c1
    16e0:	00001655 	.word	0x00001655
    16e4:	0000161d 	.word	0x0000161d
    16e8:	00001639 	.word	0x00001639

000016ec <u8g2_send_tile_row>:
}

/*============================================*/

static void u8g2_send_tile_row(u8g2_t *u8g2, uint8_t src_tile_row, uint8_t dest_tile_row)
{
    16ec:	b510      	push	{r4, lr}
    16ee:	b082      	sub	sp, #8
  uint8_t *ptr;
  uint16_t offset;
  uint8_t w;
  
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    16f0:	6803      	ldr	r3, [r0, #0]
    16f2:	7c1b      	ldrb	r3, [r3, #16]
  offset = src_tile_row;
  ptr = u8g2->tile_buf_ptr;
  offset *= w;
    16f4:	4359      	muls	r1, r3
  offset *= 8;
    16f6:	00c9      	lsls	r1, r1, #3
    16f8:	b289      	uxth	r1, r1
  ptr += offset;
    16fa:	6b44      	ldr	r4, [r0, #52]	; 0x34
    16fc:	46a4      	mov	ip, r4
    16fe:	4461      	add	r1, ip
  u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr);
    1700:	9100      	str	r1, [sp, #0]
    1702:	2100      	movs	r1, #0
    1704:	4c01      	ldr	r4, [pc, #4]	; (170c <u8g2_send_tile_row+0x20>)
    1706:	47a0      	blx	r4
}
    1708:	b002      	add	sp, #8
    170a:	bd10      	pop	{r4, pc}
    170c:	000024d5 	.word	0x000024d5

00001710 <u8g2_send_buffer>:
  For most displays, this will make the content visible to the user.
  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()
*/
static void u8g2_send_buffer(u8g2_t *u8g2) U8X8_NOINLINE;
static void u8g2_send_buffer(u8g2_t *u8g2)
{
    1710:	b5f0      	push	{r4, r5, r6, r7, lr}
    1712:	46c6      	mov	lr, r8
    1714:	b500      	push	{lr}
    1716:	0006      	movs	r6, r0
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t dest_max;

  src_row = 0;
  src_max = u8g2->tile_buf_height;
    1718:	2338      	movs	r3, #56	; 0x38
    171a:	5cc7      	ldrb	r7, [r0, r3]
  dest_row = u8g2->tile_curr_row;
    171c:	3301      	adds	r3, #1
    171e:	5cc5      	ldrb	r5, [r0, r3]
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
    1720:	6803      	ldr	r3, [r0, #0]
    1722:	7c5b      	ldrb	r3, [r3, #17]
    1724:	4698      	mov	r8, r3
  src_row = 0;
    1726:	2400      	movs	r4, #0
  
  do
  {
    u8g2_send_tile_row(u8g2, src_row, dest_row);
    1728:	002a      	movs	r2, r5
    172a:	0021      	movs	r1, r4
    172c:	0030      	movs	r0, r6
    172e:	4b06      	ldr	r3, [pc, #24]	; (1748 <u8g2_send_buffer+0x38>)
    1730:	4798      	blx	r3
    src_row++;
    1732:	3401      	adds	r4, #1
    1734:	b2e4      	uxtb	r4, r4
    dest_row++;
    1736:	3501      	adds	r5, #1
    1738:	b2ed      	uxtb	r5, r5
  } while( src_row < src_max && dest_row < dest_max );
    173a:	42a7      	cmp	r7, r4
    173c:	d901      	bls.n	1742 <u8g2_send_buffer+0x32>
    173e:	45a8      	cmp	r8, r5
    1740:	d8f2      	bhi.n	1728 <u8g2_send_buffer+0x18>
}
    1742:	bc04      	pop	{r2}
    1744:	4690      	mov	r8, r2
    1746:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1748:	000016ed 	.word	0x000016ed

0000174c <u8g2_ClearBuffer>:
{
    174c:	b510      	push	{r4, lr}
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    174e:	6803      	ldr	r3, [r0, #0]
    1750:	7c1b      	ldrb	r3, [r3, #16]
  cnt *= u8g2->tile_buf_height;
    1752:	2238      	movs	r2, #56	; 0x38
    1754:	5c82      	ldrb	r2, [r0, r2]
    1756:	435a      	muls	r2, r3
  cnt *= 8;
    1758:	00d2      	lsls	r2, r2, #3
  memset(u8g2->tile_buf_ptr, 0, cnt);
    175a:	6b40      	ldr	r0, [r0, #52]	; 0x34
    175c:	2100      	movs	r1, #0
    175e:	4b01      	ldr	r3, [pc, #4]	; (1764 <u8g2_ClearBuffer+0x18>)
    1760:	4798      	blx	r3
}
    1762:	bd10      	pop	{r4, pc}
    1764:	00002cb1 	.word	0x00002cb1

00001768 <u8g2_SendBuffer>:

/* same as u8g2_send_buffer but also send the DISPLAY_REFRESH message (used by SSD1606) */
void u8g2_SendBuffer(u8g2_t *u8g2)
{
    1768:	b510      	push	{r4, lr}
    176a:	0004      	movs	r4, r0
  u8g2_send_buffer(u8g2);
    176c:	4b02      	ldr	r3, [pc, #8]	; (1778 <u8g2_SendBuffer+0x10>)
    176e:	4798      	blx	r3
  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  
    1770:	0020      	movs	r0, r4
    1772:	4b02      	ldr	r3, [pc, #8]	; (177c <u8g2_SendBuffer+0x14>)
    1774:	4798      	blx	r3
}
    1776:	bd10      	pop	{r4, pc}
    1778:	00001711 	.word	0x00001711
    177c:	0000250f 	.word	0x0000250f

00001780 <u8g2_m_19_304_f>:
	#ifdef U8G2_USE_DYNAMIC_ALLOC
	*page_cnt = 19;
	return 0;
	#else
	static uint8_t buf[5776];
	*page_cnt = 19;
    1780:	2313      	movs	r3, #19
    1782:	7003      	strb	r3, [r0, #0]
	return buf;
	#endif
}
    1784:	4800      	ldr	r0, [pc, #0]	; (1788 <u8g2_m_19_304_f+0x8>)
    1786:	4770      	bx	lr
    1788:	20000050 	.word	0x20000050

0000178c <u8g2_Setup_GDEY0154_152x304_f>:
  buf = u8g2_m_48_30_f(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_horizontal_right_lsb, rotation);
}

void u8g2_Setup_GDEY0154_152x304_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    178c:	b570      	push	{r4, r5, r6, lr}
    178e:	b084      	sub	sp, #16
    1790:	0004      	movs	r4, r0
    1792:	000e      	movs	r6, r1
	uint8_t tile_buf_height;
	uint8_t *buf;
	u8g2_SetupDisplay(u8g2, u8x8_d_gdey0154_152x304, u8x8_cad_011, byte_cb, gpio_and_delay_cb);
    1794:	9300      	str	r3, [sp, #0]
    1796:	0013      	movs	r3, r2
    1798:	4a08      	ldr	r2, [pc, #32]	; (17bc <u8g2_Setup_GDEY0154_152x304_f+0x30>)
    179a:	4909      	ldr	r1, [pc, #36]	; (17c0 <u8g2_Setup_GDEY0154_152x304_f+0x34>)
    179c:	4d09      	ldr	r5, [pc, #36]	; (17c4 <u8g2_Setup_GDEY0154_152x304_f+0x38>)
    179e:	47a8      	blx	r5
	buf = u8g2_m_19_304_f(&tile_buf_height);
    17a0:	250f      	movs	r5, #15
    17a2:	446d      	add	r5, sp
    17a4:	0028      	movs	r0, r5
    17a6:	4b08      	ldr	r3, [pc, #32]	; (17c8 <u8g2_Setup_GDEY0154_152x304_f+0x3c>)
    17a8:	4798      	blx	r3
    17aa:	0001      	movs	r1, r0
	u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
    17ac:	782a      	ldrb	r2, [r5, #0]
    17ae:	9600      	str	r6, [sp, #0]
    17b0:	4b06      	ldr	r3, [pc, #24]	; (17cc <u8g2_Setup_GDEY0154_152x304_f+0x40>)
    17b2:	0020      	movs	r0, r4
    17b4:	4c06      	ldr	r4, [pc, #24]	; (17d0 <u8g2_Setup_GDEY0154_152x304_f+0x44>)
    17b6:	47a0      	blx	r4
}
    17b8:	b004      	add	sp, #16
    17ba:	bd70      	pop	{r4, r5, r6, pc}
    17bc:	00002409 	.word	0x00002409
    17c0:	00002675 	.word	0x00002675
    17c4:	0000273d 	.word	0x0000273d
    17c8:	00001781 	.word	0x00001781
    17cc:	000020d9 	.word	0x000020d9
    17d0:	000022ad 	.word	0x000022ad

000017d4 <u8g2_font_get_byte>:
/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
{
  font += offset;
  return u8x8_pgm_read( font );  
    17d4:	5c40      	ldrb	r0, [r0, r1]
}
    17d6:	4770      	bx	lr

000017d8 <u8g2_font_get_word>:

static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
{
    uint16_t pos;
    font += offset;
    17d8:	1841      	adds	r1, r0, r1
    pos = u8x8_pgm_read( font );
    17da:	7808      	ldrb	r0, [r1, #0]
    font++;
    pos <<= 8;
    17dc:	0200      	lsls	r0, r0, #8
    pos += u8x8_pgm_read( font);
    17de:	784b      	ldrb	r3, [r1, #1]
    17e0:	18c0      	adds	r0, r0, r3
    17e2:	b280      	uxth	r0, r0
    return pos;
}
    17e4:	4770      	bx	lr

000017e6 <u8g2_font_calc_vref_font>:
/* callback procedures to correct the y position */

u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
{
  return 0;
}
    17e6:	2000      	movs	r0, #0
    17e8:	4770      	bx	lr
	...

000017ec <u8g2_read_font_info>:
{
    17ec:	b570      	push	{r4, r5, r6, lr}
    17ee:	0004      	movs	r4, r0
    17f0:	000d      	movs	r5, r1
  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
    17f2:	2100      	movs	r1, #0
    17f4:	0028      	movs	r0, r5
    17f6:	4e28      	ldr	r6, [pc, #160]	; (1898 <u8g2_read_font_info+0xac>)
    17f8:	47b0      	blx	r6
    17fa:	7020      	strb	r0, [r4, #0]
  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
    17fc:	2101      	movs	r1, #1
    17fe:	0028      	movs	r0, r5
    1800:	47b0      	blx	r6
    1802:	7060      	strb	r0, [r4, #1]
  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
    1804:	2102      	movs	r1, #2
    1806:	0028      	movs	r0, r5
    1808:	47b0      	blx	r6
    180a:	70a0      	strb	r0, [r4, #2]
  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
    180c:	2103      	movs	r1, #3
    180e:	0028      	movs	r0, r5
    1810:	47b0      	blx	r6
    1812:	70e0      	strb	r0, [r4, #3]
  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
    1814:	2104      	movs	r1, #4
    1816:	0028      	movs	r0, r5
    1818:	47b0      	blx	r6
    181a:	7120      	strb	r0, [r4, #4]
  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
    181c:	2105      	movs	r1, #5
    181e:	0028      	movs	r0, r5
    1820:	47b0      	blx	r6
    1822:	7160      	strb	r0, [r4, #5]
  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
    1824:	2106      	movs	r1, #6
    1826:	0028      	movs	r0, r5
    1828:	47b0      	blx	r6
    182a:	71a0      	strb	r0, [r4, #6]
  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
    182c:	2107      	movs	r1, #7
    182e:	0028      	movs	r0, r5
    1830:	47b0      	blx	r6
    1832:	71e0      	strb	r0, [r4, #7]
  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
    1834:	2108      	movs	r1, #8
    1836:	0028      	movs	r0, r5
    1838:	47b0      	blx	r6
    183a:	7220      	strb	r0, [r4, #8]
  font_info->max_char_width = u8g2_font_get_byte(font, 9);
    183c:	2109      	movs	r1, #9
    183e:	0028      	movs	r0, r5
    1840:	47b0      	blx	r6
    1842:	7260      	strb	r0, [r4, #9]
  font_info->max_char_height = u8g2_font_get_byte(font, 10);
    1844:	210a      	movs	r1, #10
    1846:	0028      	movs	r0, r5
    1848:	47b0      	blx	r6
    184a:	72a0      	strb	r0, [r4, #10]
  font_info->x_offset = u8g2_font_get_byte(font, 11);
    184c:	210b      	movs	r1, #11
    184e:	0028      	movs	r0, r5
    1850:	47b0      	blx	r6
    1852:	72e0      	strb	r0, [r4, #11]
  font_info->y_offset = u8g2_font_get_byte(font, 12);
    1854:	210c      	movs	r1, #12
    1856:	0028      	movs	r0, r5
    1858:	47b0      	blx	r6
    185a:	7320      	strb	r0, [r4, #12]
  font_info->ascent_A = u8g2_font_get_byte(font, 13);
    185c:	210d      	movs	r1, #13
    185e:	0028      	movs	r0, r5
    1860:	47b0      	blx	r6
    1862:	7360      	strb	r0, [r4, #13]
  font_info->descent_g = u8g2_font_get_byte(font, 14);
    1864:	210e      	movs	r1, #14
    1866:	0028      	movs	r0, r5
    1868:	47b0      	blx	r6
    186a:	73a0      	strb	r0, [r4, #14]
  font_info->ascent_para = u8g2_font_get_byte(font, 15);
    186c:	210f      	movs	r1, #15
    186e:	0028      	movs	r0, r5
    1870:	47b0      	blx	r6
    1872:	73e0      	strb	r0, [r4, #15]
  font_info->descent_para = u8g2_font_get_byte(font, 16);
    1874:	2110      	movs	r1, #16
    1876:	0028      	movs	r0, r5
    1878:	47b0      	blx	r6
    187a:	7420      	strb	r0, [r4, #16]
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
    187c:	2111      	movs	r1, #17
    187e:	0028      	movs	r0, r5
    1880:	4e06      	ldr	r6, [pc, #24]	; (189c <u8g2_read_font_info+0xb0>)
    1882:	47b0      	blx	r6
    1884:	8260      	strh	r0, [r4, #18]
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
    1886:	2113      	movs	r1, #19
    1888:	0028      	movs	r0, r5
    188a:	47b0      	blx	r6
    188c:	82a0      	strh	r0, [r4, #20]
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
    188e:	2115      	movs	r1, #21
    1890:	0028      	movs	r0, r5
    1892:	47b0      	blx	r6
    1894:	82e0      	strh	r0, [r4, #22]
}
    1896:	bd70      	pop	{r4, r5, r6, pc}
    1898:	000017d5 	.word	0x000017d5
    189c:	000017d9 	.word	0x000017d9

000018a0 <u8g2_font_decode_get_unsigned_bits>:
{
    18a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    18a2:	0005      	movs	r5, r0
  uint8_t bit_pos = f->decode_bit_pos;
    18a4:	7b06      	ldrb	r6, [r0, #12]
  val = u8x8_pgm_read( f->decode_ptr );  
    18a6:	6807      	ldr	r7, [r0, #0]
    18a8:	7838      	ldrb	r0, [r7, #0]
  val >>= bit_pos;
    18aa:	4130      	asrs	r0, r6
    18ac:	b2c4      	uxtb	r4, r0
  bit_pos_plus_cnt += cnt;
    18ae:	1872      	adds	r2, r6, r1
    18b0:	b2d2      	uxtb	r2, r2
  if ( bit_pos_plus_cnt >= 8 )
    18b2:	2a07      	cmp	r2, #7
    18b4:	d90a      	bls.n	18cc <u8g2_font_decode_get_unsigned_bits+0x2c>
    s -= bit_pos;
    18b6:	2308      	movs	r3, #8
    18b8:	1b9b      	subs	r3, r3, r6
    18ba:	b2db      	uxtb	r3, r3
    f->decode_ptr++;
    18bc:	1c7c      	adds	r4, r7, #1
    18be:	602c      	str	r4, [r5, #0]
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
    18c0:	787c      	ldrb	r4, [r7, #1]
    18c2:	409c      	lsls	r4, r3
    18c4:	4304      	orrs	r4, r0
    18c6:	b2e4      	uxtb	r4, r4
    bit_pos_plus_cnt -= 8;
    18c8:	3a08      	subs	r2, #8
    18ca:	b2d2      	uxtb	r2, r2
  val &= (1U<<cnt)-1;
    18cc:	2301      	movs	r3, #1
    18ce:	408b      	lsls	r3, r1
    18d0:	3b01      	subs	r3, #1
    18d2:	4023      	ands	r3, r4
    18d4:	0018      	movs	r0, r3
  f->decode_bit_pos = bit_pos_plus_cnt;
    18d6:	732a      	strb	r2, [r5, #12]
}
    18d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000018dc <u8g2_font_setup_decode>:
{
    18dc:	b570      	push	{r4, r5, r6, lr}
    18de:	0005      	movs	r5, r0
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    18e0:	0004      	movs	r4, r0
    18e2:	3460      	adds	r4, #96	; 0x60
  decode->decode_ptr = glyph_data;
    18e4:	6601      	str	r1, [r0, #96]	; 0x60
  decode->decode_bit_pos = 0;
    18e6:	2300      	movs	r3, #0
    18e8:	7323      	strb	r3, [r4, #12]
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
    18ea:	3378      	adds	r3, #120	; 0x78
    18ec:	5cc1      	ldrb	r1, [r0, r3]
    18ee:	0020      	movs	r0, r4
    18f0:	4e07      	ldr	r6, [pc, #28]	; (1910 <u8g2_font_setup_decode+0x34>)
    18f2:	47b0      	blx	r6
    18f4:	72a0      	strb	r0, [r4, #10]
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
    18f6:	2379      	movs	r3, #121	; 0x79
    18f8:	5ce9      	ldrb	r1, [r5, r3]
    18fa:	0020      	movs	r0, r4
    18fc:	47b0      	blx	r6
    18fe:	72e0      	strb	r0, [r4, #11]
  decode->fg_color = u8g2->draw_color;
    1900:	2392      	movs	r3, #146	; 0x92
    1902:	5ceb      	ldrb	r3, [r5, r3]
    1904:	73a3      	strb	r3, [r4, #14]
  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
    1906:	425a      	negs	r2, r3
    1908:	4153      	adcs	r3, r2
    190a:	73e3      	strb	r3, [r4, #15]
}
    190c:	bd70      	pop	{r4, r5, r6, pc}
    190e:	46c0      	nop			; (mov r8, r8)
    1910:	000018a1 	.word	0x000018a1

00001914 <u8g2_font_decode_get_signed_bits>:
{
    1914:	b510      	push	{r4, lr}
    1916:	000c      	movs	r4, r1
  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
    1918:	4b04      	ldr	r3, [pc, #16]	; (192c <u8g2_font_decode_get_signed_bits+0x18>)
    191a:	4798      	blx	r3
  cnt--;
    191c:	3c01      	subs	r4, #1
    191e:	b2e4      	uxtb	r4, r4
  d <<= cnt;
    1920:	2301      	movs	r3, #1
    1922:	40a3      	lsls	r3, r4
  v -= d;
    1924:	1ac0      	subs	r0, r0, r3
    1926:	b240      	sxtb	r0, r0
}
    1928:	bd10      	pop	{r4, pc}
    192a:	46c0      	nop			; (mov r8, r8)
    192c:	000018a1 	.word	0x000018a1

00001930 <u8g2_add_vector_y>:
  switch(dir)
    1930:	2b01      	cmp	r3, #1
    1932:	d009      	beq.n	1948 <u8g2_add_vector_y+0x18>
    1934:	2b00      	cmp	r3, #0
    1936:	d004      	beq.n	1942 <u8g2_add_vector_y+0x12>
    1938:	2b02      	cmp	r3, #2
    193a:	d008      	beq.n	194e <u8g2_add_vector_y+0x1e>
      dy -= x;
    193c:	1a40      	subs	r0, r0, r1
    193e:	b280      	uxth	r0, r0
      break;      
    1940:	e001      	b.n	1946 <u8g2_add_vector_y+0x16>
      dy += y;
    1942:	1880      	adds	r0, r0, r2
    1944:	b280      	uxth	r0, r0
}
    1946:	4770      	bx	lr
      dy += x;
    1948:	1840      	adds	r0, r0, r1
    194a:	b280      	uxth	r0, r0
      break;
    194c:	e7fb      	b.n	1946 <u8g2_add_vector_y+0x16>
      dy -= y;
    194e:	1a80      	subs	r0, r0, r2
    1950:	b280      	uxth	r0, r0
      break;
    1952:	e7f8      	b.n	1946 <u8g2_add_vector_y+0x16>

00001954 <u8g2_add_vector_x>:
  switch(dir)
    1954:	2b01      	cmp	r3, #1
    1956:	d009      	beq.n	196c <u8g2_add_vector_x+0x18>
    1958:	2b00      	cmp	r3, #0
    195a:	d004      	beq.n	1966 <u8g2_add_vector_x+0x12>
    195c:	2b02      	cmp	r3, #2
    195e:	d008      	beq.n	1972 <u8g2_add_vector_x+0x1e>
      dx += y;
    1960:	1880      	adds	r0, r0, r2
    1962:	b280      	uxth	r0, r0
      break;      
    1964:	e001      	b.n	196a <u8g2_add_vector_x+0x16>
      dx += x;
    1966:	1840      	adds	r0, r0, r1
    1968:	b280      	uxth	r0, r0
}
    196a:	4770      	bx	lr
      dx -= y;
    196c:	1a80      	subs	r0, r0, r2
    196e:	b280      	uxth	r0, r0
      break;
    1970:	e7fb      	b.n	196a <u8g2_add_vector_x+0x16>
      dx -= x;
    1972:	1a40      	subs	r0, r0, r1
    1974:	b280      	uxth	r0, r0
      break;
    1976:	e7f8      	b.n	196a <u8g2_add_vector_x+0x16>

00001978 <u8g2_font_decode_len>:
{
    1978:	b5f0      	push	{r4, r5, r6, r7, lr}
    197a:	46de      	mov	lr, fp
    197c:	4657      	mov	r7, sl
    197e:	464e      	mov	r6, r9
    1980:	4645      	mov	r5, r8
    1982:	b5e0      	push	{r5, r6, r7, lr}
    1984:	b089      	sub	sp, #36	; 0x24
    1986:	000d      	movs	r5, r1
    1988:	4693      	mov	fp, r2
  lx = decode->x;
    198a:	0003      	movs	r3, r0
    198c:	3360      	adds	r3, #96	; 0x60
    198e:	7a1a      	ldrb	r2, [r3, #8]
    1990:	4692      	mov	sl, r2
  ly = decode->y;
    1992:	7a5b      	ldrb	r3, [r3, #9]
    1994:	4698      	mov	r8, r3
    1996:	4646      	mov	r6, r8
    1998:	46d9      	mov	r9, fp
    199a:	4680      	mov	r8, r0
    199c:	e029      	b.n	19f2 <u8g2_font_decode_len+0x7a>
      current = cnt;
    199e:	9506      	str	r5, [sp, #24]
    x = decode->target_x;
    19a0:	4643      	mov	r3, r8
    19a2:	3360      	adds	r3, #96	; 0x60
    19a4:	8898      	ldrh	r0, [r3, #4]
    y = decode->target_y;
    19a6:	88da      	ldrh	r2, [r3, #6]
    19a8:	4693      	mov	fp, r2
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
    19aa:	4652      	mov	r2, sl
    19ac:	4669      	mov	r1, sp
    19ae:	730a      	strb	r2, [r1, #12]
    19b0:	270c      	movs	r7, #12
    19b2:	57cf      	ldrsb	r7, [r1, r7]
    19b4:	b272      	sxtb	r2, r6
    19b6:	7c1b      	ldrb	r3, [r3, #16]
    19b8:	9303      	str	r3, [sp, #12]
    19ba:	9204      	str	r2, [sp, #16]
    19bc:	9705      	str	r7, [sp, #20]
    19be:	0039      	movs	r1, r7
    19c0:	4f28      	ldr	r7, [pc, #160]	; (1a64 <u8g2_font_decode_len+0xec>)
    19c2:	47b8      	blx	r7
    19c4:	9007      	str	r0, [sp, #28]
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
    19c6:	9b03      	ldr	r3, [sp, #12]
    19c8:	9a04      	ldr	r2, [sp, #16]
    19ca:	9905      	ldr	r1, [sp, #20]
    19cc:	4658      	mov	r0, fp
    19ce:	4f26      	ldr	r7, [pc, #152]	; (1a68 <u8g2_font_decode_len+0xf0>)
    19d0:	47b8      	blx	r7
    if ( is_foreground )
    19d2:	464b      	mov	r3, r9
    19d4:	2b00      	cmp	r3, #0
    19d6:	d116      	bne.n	1a06 <u8g2_font_decode_len+0x8e>
    else if ( decode->is_transparent == 0 )    
    19d8:	4643      	mov	r3, r8
    19da:	3360      	adds	r3, #96	; 0x60
    19dc:	7b5b      	ldrb	r3, [r3, #13]
    19de:	2b00      	cmp	r3, #0
    19e0:	d021      	beq.n	1a26 <u8g2_font_decode_len+0xae>
    if ( cnt < rem )
    19e2:	42a5      	cmp	r5, r4
    19e4:	d32f      	bcc.n	1a46 <u8g2_font_decode_len+0xce>
    cnt -= rem;
    19e6:	1b2d      	subs	r5, r5, r4
    19e8:	b2ed      	uxtb	r5, r5
    ly++;
    19ea:	3601      	adds	r6, #1
    19ec:	b2f6      	uxtb	r6, r6
    lx = 0;
    19ee:	2300      	movs	r3, #0
    19f0:	469a      	mov	sl, r3
    rem = decode->glyph_width;
    19f2:	4643      	mov	r3, r8
    19f4:	3360      	adds	r3, #96	; 0x60
    19f6:	7a9c      	ldrb	r4, [r3, #10]
    rem -= lx;
    19f8:	4653      	mov	r3, sl
    19fa:	1ae4      	subs	r4, r4, r3
    19fc:	b2e4      	uxtb	r4, r4
    if ( cnt < rem )
    19fe:	42a5      	cmp	r5, r4
    1a00:	d3cd      	bcc.n	199e <u8g2_font_decode_len+0x26>
    current = rem;
    1a02:	9406      	str	r4, [sp, #24]
    1a04:	e7cc      	b.n	19a0 <u8g2_font_decode_len+0x28>
      u8g2->draw_color = decode->fg_color;			/* draw_color will be restored later */
    1a06:	4643      	mov	r3, r8
    1a08:	3360      	adds	r3, #96	; 0x60
    1a0a:	7b9a      	ldrb	r2, [r3, #14]
    1a0c:	2392      	movs	r3, #146	; 0x92
    1a0e:	4641      	mov	r1, r8
    1a10:	54ca      	strb	r2, [r1, r3]
      u8g2_DrawHVLine(u8g2, 
    1a12:	466b      	mov	r3, sp
    1a14:	8b1b      	ldrh	r3, [r3, #24]
    1a16:	9a03      	ldr	r2, [sp, #12]
    1a18:	9200      	str	r2, [sp, #0]
    1a1a:	0002      	movs	r2, r0
    1a1c:	9907      	ldr	r1, [sp, #28]
    1a1e:	4640      	mov	r0, r8
    1a20:	4f12      	ldr	r7, [pc, #72]	; (1a6c <u8g2_font_decode_len+0xf4>)
    1a22:	47b8      	blx	r7
    1a24:	e7dd      	b.n	19e2 <u8g2_font_decode_len+0x6a>
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
    1a26:	4643      	mov	r3, r8
    1a28:	3360      	adds	r3, #96	; 0x60
    1a2a:	7bda      	ldrb	r2, [r3, #15]
    1a2c:	2392      	movs	r3, #146	; 0x92
    1a2e:	4641      	mov	r1, r8
    1a30:	54ca      	strb	r2, [r1, r3]
      u8g2_DrawHVLine(u8g2, 
    1a32:	466b      	mov	r3, sp
    1a34:	8b1b      	ldrh	r3, [r3, #24]
    1a36:	9a03      	ldr	r2, [sp, #12]
    1a38:	9200      	str	r2, [sp, #0]
    1a3a:	0002      	movs	r2, r0
    1a3c:	9907      	ldr	r1, [sp, #28]
    1a3e:	4640      	mov	r0, r8
    1a40:	4f0a      	ldr	r7, [pc, #40]	; (1a6c <u8g2_font_decode_len+0xf4>)
    1a42:	47b8      	blx	r7
    1a44:	e7cd      	b.n	19e2 <u8g2_font_decode_len+0x6a>
  lx += cnt;
    1a46:	002a      	movs	r2, r5
    1a48:	4452      	add	r2, sl
  decode->x = lx;
    1a4a:	4643      	mov	r3, r8
    1a4c:	3360      	adds	r3, #96	; 0x60
    1a4e:	721a      	strb	r2, [r3, #8]
  decode->y = ly;  
    1a50:	466a      	mov	r2, sp
    1a52:	7c12      	ldrb	r2, [r2, #16]
    1a54:	725a      	strb	r2, [r3, #9]
}
    1a56:	b009      	add	sp, #36	; 0x24
    1a58:	bc3c      	pop	{r2, r3, r4, r5}
    1a5a:	4690      	mov	r8, r2
    1a5c:	4699      	mov	r9, r3
    1a5e:	46a2      	mov	sl, r4
    1a60:	46ab      	mov	fp, r5
    1a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a64:	00001955 	.word	0x00001955
    1a68:	00001931 	.word	0x00001931
    1a6c:	00001e91 	.word	0x00001e91

00001a70 <u8g2_font_decode_glyph>:
{
    1a70:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a72:	46de      	mov	lr, fp
    1a74:	4657      	mov	r7, sl
    1a76:	464e      	mov	r6, r9
    1a78:	4645      	mov	r5, r8
    1a7a:	b5e0      	push	{r5, r6, r7, lr}
    1a7c:	b087      	sub	sp, #28
    1a7e:	0004      	movs	r4, r0
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    1a80:	0007      	movs	r7, r0
    1a82:	3760      	adds	r7, #96	; 0x60
  u8g2_font_setup_decode(u8g2, glyph_data);     /* set values in u8g2->font_decode data structure */
    1a84:	4b57      	ldr	r3, [pc, #348]	; (1be4 <u8g2_font_decode_glyph+0x174>)
    1a86:	4798      	blx	r3
  h = u8g2->font_decode.glyph_height;
    1a88:	236b      	movs	r3, #107	; 0x6b
    1a8a:	56e3      	ldrsb	r3, [r4, r3]
    1a8c:	4698      	mov	r8, r3
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    1a8e:	237a      	movs	r3, #122	; 0x7a
    1a90:	5ce1      	ldrb	r1, [r4, r3]
    1a92:	0038      	movs	r0, r7
    1a94:	4e54      	ldr	r6, [pc, #336]	; (1be8 <u8g2_font_decode_glyph+0x178>)
    1a96:	47b0      	blx	r6
    1a98:	9002      	str	r0, [sp, #8]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    1a9a:	237b      	movs	r3, #123	; 0x7b
    1a9c:	5ce1      	ldrb	r1, [r4, r3]
    1a9e:	0038      	movs	r0, r7
    1aa0:	47b0      	blx	r6
    1aa2:	0005      	movs	r5, r0
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    1aa4:	237c      	movs	r3, #124	; 0x7c
    1aa6:	5ce1      	ldrb	r1, [r4, r3]
    1aa8:	0038      	movs	r0, r7
    1aaa:	47b0      	blx	r6
    1aac:	9003      	str	r0, [sp, #12]
  if ( decode->glyph_width > 0 )
    1aae:	230a      	movs	r3, #10
    1ab0:	56fb      	ldrsb	r3, [r7, r3]
    1ab2:	469a      	mov	sl, r3
    1ab4:	2b00      	cmp	r3, #0
    1ab6:	dd5a      	ble.n	1b6e <u8g2_font_decode_glyph+0xfe>
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    1ab8:	4445      	add	r5, r8
    1aba:	b2ed      	uxtb	r5, r5
    1abc:	426d      	negs	r5, r5
    1abe:	b26b      	sxtb	r3, r5
    1ac0:	001a      	movs	r2, r3
    1ac2:	7c3e      	ldrb	r6, [r7, #16]
    1ac4:	88b8      	ldrh	r0, [r7, #4]
    1ac6:	0033      	movs	r3, r6
    1ac8:	9205      	str	r2, [sp, #20]
    1aca:	9902      	ldr	r1, [sp, #8]
    1acc:	4d47      	ldr	r5, [pc, #284]	; (1bec <u8g2_font_decode_glyph+0x17c>)
    1ace:	47a8      	blx	r5
    1ad0:	4683      	mov	fp, r0
    1ad2:	9004      	str	r0, [sp, #16]
    1ad4:	003b      	movs	r3, r7
    1ad6:	8098      	strh	r0, [r3, #4]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    1ad8:	88f8      	ldrh	r0, [r7, #6]
    1ada:	0033      	movs	r3, r6
    1adc:	9a05      	ldr	r2, [sp, #20]
    1ade:	9902      	ldr	r1, [sp, #8]
    1ae0:	4d43      	ldr	r5, [pc, #268]	; (1bf0 <u8g2_font_decode_glyph+0x180>)
    1ae2:	47a8      	blx	r5
    1ae4:	0002      	movs	r2, r0
    1ae6:	80f8      	strh	r0, [r7, #6]
      switch(decode->dir)
    1ae8:	2e01      	cmp	r6, #1
    1aea:	d048      	beq.n	1b7e <u8g2_font_decode_glyph+0x10e>
    1aec:	2e00      	cmp	r6, #0
    1aee:	d005      	beq.n	1afc <u8g2_font_decode_glyph+0x8c>
    1af0:	2e02      	cmp	r6, #2
    1af2:	d054      	beq.n	1b9e <u8g2_font_decode_glyph+0x12e>
    1af4:	2e03      	cmp	r6, #3
    1af6:	d066      	beq.n	1bc6 <u8g2_font_decode_glyph+0x156>
      x1 = x0;
    1af8:	465b      	mov	r3, fp
    1afa:	e007      	b.n	1b0c <u8g2_font_decode_glyph+0x9c>
	    x1 += decode->glyph_width;
    1afc:	4653      	mov	r3, sl
    1afe:	4669      	mov	r1, sp
    1b00:	810b      	strh	r3, [r1, #8]
    1b02:	890b      	ldrh	r3, [r1, #8]
    1b04:	445b      	add	r3, fp
    1b06:	b29b      	uxth	r3, r3
	    y1 += h;
    1b08:	4440      	add	r0, r8
    1b0a:	b280      	uxth	r0, r0
      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
    1b0c:	9000      	str	r0, [sp, #0]
    1b0e:	9904      	ldr	r1, [sp, #16]
    1b10:	0020      	movs	r0, r4
    1b12:	4d38      	ldr	r5, [pc, #224]	; (1bf4 <u8g2_font_decode_glyph+0x184>)
    1b14:	47a8      	blx	r5
    1b16:	2800      	cmp	r0, #0
    1b18:	d029      	beq.n	1b6e <u8g2_font_decode_glyph+0xfe>
    decode->x = 0;
    1b1a:	0023      	movs	r3, r4
    1b1c:	3360      	adds	r3, #96	; 0x60
    1b1e:	2200      	movs	r2, #0
    1b20:	721a      	strb	r2, [r3, #8]
    decode->y = 0;
    1b22:	725a      	strb	r2, [r3, #9]
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    1b24:	2376      	movs	r3, #118	; 0x76
    1b26:	5ce1      	ldrb	r1, [r4, r3]
    1b28:	0038      	movs	r0, r7
    1b2a:	4d33      	ldr	r5, [pc, #204]	; (1bf8 <u8g2_font_decode_glyph+0x188>)
    1b2c:	47a8      	blx	r5
    1b2e:	0006      	movs	r6, r0
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
    1b30:	2377      	movs	r3, #119	; 0x77
    1b32:	5ce1      	ldrb	r1, [r4, r3]
    1b34:	0038      	movs	r0, r7
    1b36:	47a8      	blx	r5
    1b38:	9002      	str	r0, [sp, #8]
	u8g2_font_decode_len(u8g2, a, 0);
    1b3a:	2200      	movs	r2, #0
    1b3c:	0031      	movs	r1, r6
    1b3e:	0020      	movs	r0, r4
    1b40:	4d2e      	ldr	r5, [pc, #184]	; (1bfc <u8g2_font_decode_glyph+0x18c>)
    1b42:	47a8      	blx	r5
	u8g2_font_decode_len(u8g2, b, 1);
    1b44:	2201      	movs	r2, #1
    1b46:	9902      	ldr	r1, [sp, #8]
    1b48:	0020      	movs	r0, r4
    1b4a:	47a8      	blx	r5
      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
    1b4c:	2101      	movs	r1, #1
    1b4e:	0038      	movs	r0, r7
    1b50:	4b29      	ldr	r3, [pc, #164]	; (1bf8 <u8g2_font_decode_glyph+0x188>)
    1b52:	4798      	blx	r3
    1b54:	2800      	cmp	r0, #0
    1b56:	d1f0      	bne.n	1b3a <u8g2_font_decode_glyph+0xca>
      if ( decode->y >= h )
    1b58:	0023      	movs	r3, r4
    1b5a:	3360      	adds	r3, #96	; 0x60
    1b5c:	7a5b      	ldrb	r3, [r3, #9]
    1b5e:	b25b      	sxtb	r3, r3
    1b60:	4598      	cmp	r8, r3
    1b62:	dcdf      	bgt.n	1b24 <u8g2_font_decode_glyph+0xb4>
    u8g2->draw_color = decode->fg_color;
    1b64:	0023      	movs	r3, r4
    1b66:	3360      	adds	r3, #96	; 0x60
    1b68:	7b9a      	ldrb	r2, [r3, #14]
    1b6a:	2392      	movs	r3, #146	; 0x92
    1b6c:	54e2      	strb	r2, [r4, r3]
}
    1b6e:	9803      	ldr	r0, [sp, #12]
    1b70:	b007      	add	sp, #28
    1b72:	bc3c      	pop	{r2, r3, r4, r5}
    1b74:	4690      	mov	r8, r2
    1b76:	4699      	mov	r9, r3
    1b78:	46a2      	mov	sl, r4
    1b7a:	46ab      	mov	fp, r5
    1b7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	    x0 -= h;
    1b7e:	465b      	mov	r3, fp
    1b80:	4641      	mov	r1, r8
    1b82:	1a59      	subs	r1, r3, r1
    1b84:	b289      	uxth	r1, r1
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1b86:	3101      	adds	r1, #1
	    x1++;
    1b88:	3301      	adds	r3, #1
    1b8a:	b29b      	uxth	r3, r3
	    y1 += decode->glyph_width;
    1b8c:	4655      	mov	r5, sl
    1b8e:	466e      	mov	r6, sp
    1b90:	8135      	strh	r5, [r6, #8]
    1b92:	8936      	ldrh	r6, [r6, #8]
    1b94:	1980      	adds	r0, r0, r6
    1b96:	b280      	uxth	r0, r0
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1b98:	b289      	uxth	r1, r1
    1b9a:	9104      	str	r1, [sp, #16]
	    break;
    1b9c:	e7b6      	b.n	1b0c <u8g2_font_decode_glyph+0x9c>
	    x0 -= decode->glyph_width;
    1b9e:	4653      	mov	r3, sl
    1ba0:	466a      	mov	r2, sp
    1ba2:	8113      	strh	r3, [r2, #8]
    1ba4:	8911      	ldrh	r1, [r2, #8]
    1ba6:	465b      	mov	r3, fp
    1ba8:	1a59      	subs	r1, r3, r1
    1baa:	b289      	uxth	r1, r1
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bac:	3101      	adds	r1, #1
	    x1++;
    1bae:	3301      	adds	r3, #1
    1bb0:	b29b      	uxth	r3, r3
	    y0 -= h;
    1bb2:	4642      	mov	r2, r8
    1bb4:	1a82      	subs	r2, r0, r2
    1bb6:	b292      	uxth	r2, r2
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bb8:	3201      	adds	r2, #1
	    y1++;
    1bba:	3001      	adds	r0, #1
    1bbc:	b280      	uxth	r0, r0
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bbe:	b292      	uxth	r2, r2
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bc0:	b289      	uxth	r1, r1
    1bc2:	9104      	str	r1, [sp, #16]
	    break;	  
    1bc4:	e7a2      	b.n	1b0c <u8g2_font_decode_glyph+0x9c>
	    x1 += h;
    1bc6:	465b      	mov	r3, fp
    1bc8:	4443      	add	r3, r8
    1bca:	b29b      	uxth	r3, r3
	    y0 -= decode->glyph_width;
    1bcc:	4652      	mov	r2, sl
    1bce:	4669      	mov	r1, sp
    1bd0:	810a      	strh	r2, [r1, #8]
    1bd2:	890a      	ldrh	r2, [r1, #8]
    1bd4:	1a82      	subs	r2, r0, r2
    1bd6:	b292      	uxth	r2, r2
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bd8:	3201      	adds	r2, #1
	    y1++;
    1bda:	3001      	adds	r0, #1
    1bdc:	b280      	uxth	r0, r0
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bde:	b292      	uxth	r2, r2
	    break;	  
    1be0:	e794      	b.n	1b0c <u8g2_font_decode_glyph+0x9c>
    1be2:	46c0      	nop			; (mov r8, r8)
    1be4:	000018dd 	.word	0x000018dd
    1be8:	00001915 	.word	0x00001915
    1bec:	00001955 	.word	0x00001955
    1bf0:	00001931 	.word	0x00001931
    1bf4:	00001fc9 	.word	0x00001fc9
    1bf8:	000018a1 	.word	0x000018a1
    1bfc:	00001979 	.word	0x00001979

00001c00 <u8g2_font_get_glyph_data>:
{
    1c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1c02:	000e      	movs	r6, r1
  font += U8G2_FONT_DATA_STRUCT_SIZE;
    1c04:	6d84      	ldr	r4, [r0, #88]	; 0x58
    1c06:	3417      	adds	r4, #23
  if ( encoding <= 255 )
    1c08:	29ff      	cmp	r1, #255	; 0xff
    1c0a:	d814      	bhi.n	1c36 <u8g2_font_get_glyph_data+0x36>
    if ( encoding >= 'a' )
    1c0c:	2960      	cmp	r1, #96	; 0x60
    1c0e:	d90a      	bls.n	1c26 <u8g2_font_get_glyph_data+0x26>
      font += u8g2->font_info.start_pos_lower_a;
    1c10:	2388      	movs	r3, #136	; 0x88
    1c12:	5ac3      	ldrh	r3, [r0, r3]
    1c14:	18e4      	adds	r4, r4, r3
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    1c16:	7863      	ldrb	r3, [r4, #1]
    1c18:	2b00      	cmp	r3, #0
    1c1a:	d027      	beq.n	1c6c <u8g2_font_get_glyph_data+0x6c>
      if ( u8x8_pgm_read( font ) == encoding )
    1c1c:	7822      	ldrb	r2, [r4, #0]
    1c1e:	4296      	cmp	r6, r2
    1c20:	d007      	beq.n	1c32 <u8g2_font_get_glyph_data+0x32>
      font += u8x8_pgm_read( font + 1 );
    1c22:	18e4      	adds	r4, r4, r3
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    1c24:	e7f7      	b.n	1c16 <u8g2_font_get_glyph_data+0x16>
    else if ( encoding >= 'A' )
    1c26:	2940      	cmp	r1, #64	; 0x40
    1c28:	d9f5      	bls.n	1c16 <u8g2_font_get_glyph_data+0x16>
      font += u8g2->font_info.start_pos_upper_A;
    1c2a:	2386      	movs	r3, #134	; 0x86
    1c2c:	5ac3      	ldrh	r3, [r0, r3]
    1c2e:	18e4      	adds	r4, r4, r3
    1c30:	e7f1      	b.n	1c16 <u8g2_font_get_glyph_data+0x16>
	return font+2;	/* skip encoding and glyph size */
    1c32:	1ca0      	adds	r0, r4, #2
    1c34:	e01b      	b.n	1c6e <u8g2_font_get_glyph_data+0x6e>
    font += u8g2->font_info.start_pos_unicode;
    1c36:	238a      	movs	r3, #138	; 0x8a
    1c38:	5ac0      	ldrh	r0, [r0, r3]
    1c3a:	1824      	adds	r4, r4, r0
    unicode_lookup_table = font; 
    1c3c:	0025      	movs	r5, r4
      font += u8g2_font_get_word(unicode_lookup_table, 0);
    1c3e:	2100      	movs	r1, #0
    1c40:	0028      	movs	r0, r5
    1c42:	4f0c      	ldr	r7, [pc, #48]	; (1c74 <u8g2_font_get_glyph_data+0x74>)
    1c44:	47b8      	blx	r7
    1c46:	1824      	adds	r4, r4, r0
      e = u8g2_font_get_word(unicode_lookup_table, 2);
    1c48:	2102      	movs	r1, #2
    1c4a:	0028      	movs	r0, r5
    1c4c:	47b8      	blx	r7
      unicode_lookup_table+=4;
    1c4e:	3504      	adds	r5, #4
    } while( e < encoding );
    1c50:	4286      	cmp	r6, r0
    1c52:	d8f4      	bhi.n	1c3e <u8g2_font_get_glyph_data+0x3e>
      e = u8x8_pgm_read( font );
    1c54:	7823      	ldrb	r3, [r4, #0]
      e <<= 8;
    1c56:	021b      	lsls	r3, r3, #8
      e |= u8x8_pgm_read( font + 1 );
    1c58:	7862      	ldrb	r2, [r4, #1]
    1c5a:	4313      	orrs	r3, r2
      if ( e == 0 )
    1c5c:	d008      	beq.n	1c70 <u8g2_font_get_glyph_data+0x70>
      if ( e == encoding )
    1c5e:	429e      	cmp	r6, r3
    1c60:	d002      	beq.n	1c68 <u8g2_font_get_glyph_data+0x68>
      font += u8x8_pgm_read( font + 2 );
    1c62:	78a3      	ldrb	r3, [r4, #2]
    1c64:	18e4      	adds	r4, r4, r3
      e = u8x8_pgm_read( font );
    1c66:	e7f5      	b.n	1c54 <u8g2_font_get_glyph_data+0x54>
	return font+3;	/* skip encoding and glyph size */
    1c68:	1ce0      	adds	r0, r4, #3
    1c6a:	e000      	b.n	1c6e <u8g2_font_get_glyph_data+0x6e>
  return NULL;
    1c6c:	2000      	movs	r0, #0
}
    1c6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return NULL;
    1c70:	2000      	movs	r0, #0
    1c72:	e7fc      	b.n	1c6e <u8g2_font_get_glyph_data+0x6e>
    1c74:	000017d9 	.word	0x000017d9

00001c78 <u8g2_font_draw_glyph>:
{
    1c78:	b510      	push	{r4, lr}
    1c7a:	0004      	movs	r4, r0
  u8g2->font_decode.target_x = x;
    1c7c:	2064      	movs	r0, #100	; 0x64
    1c7e:	5221      	strh	r1, [r4, r0]
  u8g2->font_decode.target_y = y;
    1c80:	2166      	movs	r1, #102	; 0x66
    1c82:	5262      	strh	r2, [r4, r1]
  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
    1c84:	0019      	movs	r1, r3
    1c86:	0020      	movs	r0, r4
    1c88:	4b05      	ldr	r3, [pc, #20]	; (1ca0 <u8g2_font_draw_glyph+0x28>)
    1c8a:	4798      	blx	r3
  if ( glyph_data != NULL )
    1c8c:	2800      	cmp	r0, #0
    1c8e:	d005      	beq.n	1c9c <u8g2_font_draw_glyph+0x24>
    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
    1c90:	0001      	movs	r1, r0
    1c92:	0020      	movs	r0, r4
    1c94:	4b03      	ldr	r3, [pc, #12]	; (1ca4 <u8g2_font_draw_glyph+0x2c>)
    1c96:	4798      	blx	r3
    1c98:	b280      	uxth	r0, r0
}
    1c9a:	bd10      	pop	{r4, pc}
  u8g2_uint_t dx = 0;
    1c9c:	2000      	movs	r0, #0
    1c9e:	e7fc      	b.n	1c9a <u8g2_font_draw_glyph+0x22>
    1ca0:	00001c01 	.word	0x00001c01
    1ca4:	00001a71 	.word	0x00001a71

00001ca8 <u8g2_DrawGlyph>:
{
    1ca8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1caa:	0004      	movs	r4, r0
    1cac:	000d      	movs	r5, r1
    1cae:	0016      	movs	r6, r2
    1cb0:	001f      	movs	r7, r3
  switch(u8g2->font_decode.dir)
    1cb2:	2370      	movs	r3, #112	; 0x70
    1cb4:	5cc3      	ldrb	r3, [r0, r3]
    1cb6:	2b01      	cmp	r3, #1
    1cb8:	d011      	beq.n	1cde <u8g2_DrawGlyph+0x36>
    1cba:	2b00      	cmp	r3, #0
    1cbc:	d00a      	beq.n	1cd4 <u8g2_DrawGlyph+0x2c>
    1cbe:	2b02      	cmp	r3, #2
    1cc0:	d012      	beq.n	1ce8 <u8g2_DrawGlyph+0x40>
    1cc2:	2b03      	cmp	r3, #3
    1cc4:	d015      	beq.n	1cf2 <u8g2_DrawGlyph+0x4a>
  return u8g2_font_draw_glyph(u8g2, x, y, encoding);
    1cc6:	003b      	movs	r3, r7
    1cc8:	0032      	movs	r2, r6
    1cca:	0029      	movs	r1, r5
    1ccc:	0020      	movs	r0, r4
    1cce:	4c0b      	ldr	r4, [pc, #44]	; (1cfc <u8g2_DrawGlyph+0x54>)
    1cd0:	47a0      	blx	r4
}
    1cd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      y += u8g2->font_calc_vref(u8g2);
    1cd4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1cd6:	4798      	blx	r3
    1cd8:	1836      	adds	r6, r6, r0
    1cda:	b2b6      	uxth	r6, r6
      break;
    1cdc:	e7f3      	b.n	1cc6 <u8g2_DrawGlyph+0x1e>
      x -= u8g2->font_calc_vref(u8g2);
    1cde:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1ce0:	4798      	blx	r3
    1ce2:	1a2d      	subs	r5, r5, r0
    1ce4:	b2ad      	uxth	r5, r5
      break;
    1ce6:	e7ee      	b.n	1cc6 <u8g2_DrawGlyph+0x1e>
      y -= u8g2->font_calc_vref(u8g2);
    1ce8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1cea:	4798      	blx	r3
    1cec:	1a36      	subs	r6, r6, r0
    1cee:	b2b6      	uxth	r6, r6
      break;
    1cf0:	e7e9      	b.n	1cc6 <u8g2_DrawGlyph+0x1e>
      x += u8g2->font_calc_vref(u8g2);
    1cf2:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1cf4:	4798      	blx	r3
    1cf6:	182d      	adds	r5, r5, r0
    1cf8:	b2ad      	uxth	r5, r5
      break;
    1cfa:	e7e4      	b.n	1cc6 <u8g2_DrawGlyph+0x1e>
    1cfc:	00001c79 	.word	0x00001c79

00001d00 <u8g2_draw_string>:
{
    1d00:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d02:	46ce      	mov	lr, r9
    1d04:	4647      	mov	r7, r8
    1d06:	b580      	push	{r7, lr}
    1d08:	b083      	sub	sp, #12
    1d0a:	0004      	movs	r4, r0
    1d0c:	000f      	movs	r7, r1
    1d0e:	9201      	str	r2, [sp, #4]
    1d10:	001d      	movs	r5, r3
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
    1d12:	4b1c      	ldr	r3, [pc, #112]	; (1d84 <u8g2_draw_string+0x84>)
    1d14:	4798      	blx	r3
  sum = 0;
    1d16:	2300      	movs	r3, #0
    1d18:	4698      	mov	r8, r3
    1d1a:	e004      	b.n	1d26 <u8g2_draw_string+0x26>
	  x += delta;
    1d1c:	183f      	adds	r7, r7, r0
    1d1e:	b2bf      	uxth	r7, r7
      sum += delta;    
    1d20:	4440      	add	r0, r8
    1d22:	b283      	uxth	r3, r0
    1d24:	4698      	mov	r8, r3
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    1d26:	7829      	ldrb	r1, [r5, #0]
    1d28:	0020      	movs	r0, r4
    1d2a:	6863      	ldr	r3, [r4, #4]
    1d2c:	4798      	blx	r3
    if ( e == 0x0ffff )
    1d2e:	4b16      	ldr	r3, [pc, #88]	; (1d88 <u8g2_draw_string+0x88>)
    1d30:	4298      	cmp	r0, r3
    1d32:	d020      	beq.n	1d76 <u8g2_draw_string+0x76>
    str++;
    1d34:	3501      	adds	r5, #1
    if ( e != 0x0fffe )
    1d36:	4b15      	ldr	r3, [pc, #84]	; (1d8c <u8g2_draw_string+0x8c>)
    1d38:	4298      	cmp	r0, r3
    1d3a:	d0f4      	beq.n	1d26 <u8g2_draw_string+0x26>
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
    1d3c:	0003      	movs	r3, r0
    1d3e:	9a01      	ldr	r2, [sp, #4]
    1d40:	0039      	movs	r1, r7
    1d42:	0020      	movs	r0, r4
    1d44:	4e12      	ldr	r6, [pc, #72]	; (1d90 <u8g2_draw_string+0x90>)
    1d46:	47b0      	blx	r6
      switch(u8g2->font_decode.dir)
    1d48:	2370      	movs	r3, #112	; 0x70
    1d4a:	5ce3      	ldrb	r3, [r4, r3]
    1d4c:	2b01      	cmp	r3, #1
    1d4e:	d00a      	beq.n	1d66 <u8g2_draw_string+0x66>
    1d50:	2b00      	cmp	r3, #0
    1d52:	d0e3      	beq.n	1d1c <u8g2_draw_string+0x1c>
    1d54:	2b02      	cmp	r3, #2
    1d56:	d00b      	beq.n	1d70 <u8g2_draw_string+0x70>
    1d58:	2b03      	cmp	r3, #3
    1d5a:	d1e1      	bne.n	1d20 <u8g2_draw_string+0x20>
	  y -= delta;
    1d5c:	9b01      	ldr	r3, [sp, #4]
    1d5e:	1a1e      	subs	r6, r3, r0
    1d60:	b2b3      	uxth	r3, r6
    1d62:	9301      	str	r3, [sp, #4]
	  break;
    1d64:	e7dc      	b.n	1d20 <u8g2_draw_string+0x20>
	  y += delta;
    1d66:	9b01      	ldr	r3, [sp, #4]
    1d68:	181e      	adds	r6, r3, r0
    1d6a:	b2b3      	uxth	r3, r6
    1d6c:	9301      	str	r3, [sp, #4]
	  break;
    1d6e:	e7d7      	b.n	1d20 <u8g2_draw_string+0x20>
	  x -= delta;
    1d70:	1a3f      	subs	r7, r7, r0
    1d72:	b2bf      	uxth	r7, r7
	  break;
    1d74:	e7d4      	b.n	1d20 <u8g2_draw_string+0x20>
}
    1d76:	4640      	mov	r0, r8
    1d78:	b003      	add	sp, #12
    1d7a:	bc0c      	pop	{r2, r3}
    1d7c:	4690      	mov	r8, r2
    1d7e:	4699      	mov	r9, r3
    1d80:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d82:	46c0      	nop			; (mov r8, r8)
    1d84:	00002315 	.word	0x00002315
    1d88:	0000ffff 	.word	0x0000ffff
    1d8c:	0000fffe 	.word	0x0000fffe
    1d90:	00001ca9 	.word	0x00001ca9

00001d94 <u8g2_DrawStr>:
{
    1d94:	b510      	push	{r4, lr}
  u8g2->u8x8.next_cb = u8x8_ascii_next;
    1d96:	4c02      	ldr	r4, [pc, #8]	; (1da0 <u8g2_DrawStr+0xc>)
    1d98:	6044      	str	r4, [r0, #4]
  return u8g2_draw_string(u8g2, x, y, str);
    1d9a:	4c02      	ldr	r4, [pc, #8]	; (1da4 <u8g2_DrawStr+0x10>)
    1d9c:	47a0      	blx	r4
}
    1d9e:	bd10      	pop	{r4, pc}
    1da0:	000022fd 	.word	0x000022fd
    1da4:	00001d01 	.word	0x00001d01

00001da8 <u8g2_UpdateRefHeight>:
{
    1da8:	b530      	push	{r4, r5, lr}
  if ( u8g2->font == NULL )
    1daa:	6d83      	ldr	r3, [r0, #88]	; 0x58
    1dac:	2b00      	cmp	r3, #0
    1dae:	d01d      	beq.n	1dec <u8g2_UpdateRefHeight+0x44>
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
    1db0:	2381      	movs	r3, #129	; 0x81
    1db2:	56c1      	ldrsb	r1, [r0, r3]
    1db4:	330d      	adds	r3, #13
    1db6:	54c1      	strb	r1, [r0, r3]
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
    1db8:	3b0c      	subs	r3, #12
    1dba:	56c2      	ldrsb	r2, [r0, r3]
    1dbc:	330d      	adds	r3, #13
    1dbe:	54c2      	strb	r2, [r0, r3]
  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
    1dc0:	3b02      	subs	r3, #2
    1dc2:	5cc3      	ldrb	r3, [r0, r3]
    1dc4:	2b00      	cmp	r3, #0
    1dc6:	d011      	beq.n	1dec <u8g2_UpdateRefHeight+0x44>
  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
    1dc8:	2b01      	cmp	r3, #1
    1dca:	d010      	beq.n	1dee <u8g2_UpdateRefHeight+0x46>
    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
    1dcc:	237e      	movs	r3, #126	; 0x7e
    1dce:	56c3      	ldrsb	r3, [r0, r3]
    1dd0:	2480      	movs	r4, #128	; 0x80
    1dd2:	5704      	ldrsb	r4, [r0, r4]
    1dd4:	191d      	adds	r5, r3, r4
    1dd6:	42a9      	cmp	r1, r5
    1dd8:	da04      	bge.n	1de4 <u8g2_UpdateRefHeight+0x3c>
      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
    1dda:	b2db      	uxtb	r3, r3
    1ddc:	b2e1      	uxtb	r1, r4
    1dde:	185b      	adds	r3, r3, r1
    1de0:	218e      	movs	r1, #142	; 0x8e
    1de2:	5443      	strb	r3, [r0, r1]
    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
    1de4:	42a2      	cmp	r2, r4
    1de6:	dd01      	ble.n	1dec <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.y_offset;
    1de8:	238f      	movs	r3, #143	; 0x8f
    1dea:	54c4      	strb	r4, [r0, r3]
}
    1dec:	bd30      	pop	{r4, r5, pc}
    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
    1dee:	3382      	adds	r3, #130	; 0x82
    1df0:	56c3      	ldrsb	r3, [r0, r3]
    1df2:	4299      	cmp	r1, r3
    1df4:	da01      	bge.n	1dfa <u8g2_UpdateRefHeight+0x52>
      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
    1df6:	218e      	movs	r1, #142	; 0x8e
    1df8:	5443      	strb	r3, [r0, r1]
    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
    1dfa:	2384      	movs	r3, #132	; 0x84
    1dfc:	56c3      	ldrsb	r3, [r0, r3]
    1dfe:	429a      	cmp	r2, r3
    1e00:	ddf4      	ble.n	1dec <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.descent_para;
    1e02:	228f      	movs	r2, #143	; 0x8f
    1e04:	5483      	strb	r3, [r0, r2]
    1e06:	e7f1      	b.n	1dec <u8g2_UpdateRefHeight+0x44>

00001e08 <u8g2_SetFontPosBaseline>:

void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
{
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
    1e08:	4b01      	ldr	r3, [pc, #4]	; (1e10 <u8g2_SetFontPosBaseline+0x8>)
    1e0a:	65c3      	str	r3, [r0, #92]	; 0x5c
}
    1e0c:	4770      	bx	lr
    1e0e:	46c0      	nop			; (mov r8, r8)
    1e10:	000017e7 	.word	0x000017e7

00001e14 <u8g2_SetFont>:
}

/*===============================================*/

void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
{
    1e14:	b510      	push	{r4, lr}
    1e16:	0004      	movs	r4, r0
  if ( u8g2->font != font )
    1e18:	6d83      	ldr	r3, [r0, #88]	; 0x58
    1e1a:	428b      	cmp	r3, r1
    1e1c:	d006      	beq.n	1e2c <u8g2_SetFont+0x18>
  {
//#ifdef  __unix__
//	u8g2->last_font_data = NULL;
//	u8g2->last_unicode = 0x0ffff;
//#endif 
    u8g2->font = font;
    1e1e:	6581      	str	r1, [r0, #88]	; 0x58
    u8g2_read_font_info(&(u8g2->font_info), font);
    1e20:	3074      	adds	r0, #116	; 0x74
    1e22:	4b03      	ldr	r3, [pc, #12]	; (1e30 <u8g2_SetFont+0x1c>)
    1e24:	4798      	blx	r3
    u8g2_UpdateRefHeight(u8g2);
    1e26:	0020      	movs	r0, r4
    1e28:	4b02      	ldr	r3, [pc, #8]	; (1e34 <u8g2_SetFont+0x20>)
    1e2a:	4798      	blx	r3
    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
  }
}
    1e2c:	bd10      	pop	{r4, pc}
    1e2e:	46c0      	nop			; (mov r8, r8)
    1e30:	000017ed 	.word	0x000017ed
    1e34:	00001da9 	.word	0x00001da9

00001e38 <u8g2_clip_intersection2>:
  will return 0 if there is no intersection and if a > b

*/

static uint8_t u8g2_clip_intersection2(u8g2_uint_t *ap, u8g2_uint_t *len, u8g2_uint_t c, u8g2_uint_t d)
{
    1e38:	b530      	push	{r4, r5, lr}
  u8g2_uint_t a = *ap;
    1e3a:	8805      	ldrh	r5, [r0, #0]
  u8g2_uint_t b;
  b  = a;
  b += *len;
    1e3c:	880c      	ldrh	r4, [r1, #0]
    1e3e:	192c      	adds	r4, r5, r4
    1e40:	b2a4      	uxth	r4, r4
  /* be removed completly (be aware about memory curruption for wrong */
  /* arguments) or return 0 for a>b (will lead to skipped lines for wrong */
  /* arguments) */  
  
  /* removing the following if clause completly may lead to memory corruption of a>b */
  if ( a > b )
    1e42:	42a5      	cmp	r5, r4
    1e44:	d903      	bls.n	1e4e <u8g2_clip_intersection2+0x16>
  {    
    /* replacing this if with a simple "return 0;" will not handle the case with negative a */    
    if ( a < d )
    1e46:	429d      	cmp	r5, r3
    1e48:	d210      	bcs.n	1e6c <u8g2_clip_intersection2+0x34>
    {
      b = d;
      b--;
    1e4a:	1e5c      	subs	r4, r3, #1
    1e4c:	b2a4      	uxth	r4, r4
    }
  }
  
  /* from now on, the asumption a <= b is ok */
  
  if ( a >= d )
    1e4e:	429d      	cmp	r5, r3
    1e50:	d20e      	bcs.n	1e70 <u8g2_clip_intersection2+0x38>
    return 0;
  if ( b <= c )
    1e52:	4294      	cmp	r4, r2
    1e54:	d90e      	bls.n	1e74 <u8g2_clip_intersection2+0x3c>
    return 0;
  if ( a < c )		
    1e56:	4295      	cmp	r5, r2
    1e58:	d300      	bcc.n	1e5c <u8g2_clip_intersection2+0x24>
    1e5a:	002a      	movs	r2, r5
    a = c;
  if ( b > d )
    1e5c:	429c      	cmp	r4, r3
    1e5e:	d800      	bhi.n	1e62 <u8g2_clip_intersection2+0x2a>
    1e60:	0023      	movs	r3, r4
    b = d;
  
  *ap = a;
    1e62:	8002      	strh	r2, [r0, #0]
  b -= a;
    1e64:	1a9b      	subs	r3, r3, r2
  *len = b;
    1e66:	800b      	strh	r3, [r1, #0]
  return 1;
    1e68:	2001      	movs	r0, #1
    1e6a:	e002      	b.n	1e72 <u8g2_clip_intersection2+0x3a>
      a = c;
    1e6c:	0015      	movs	r5, r2
    1e6e:	e7ee      	b.n	1e4e <u8g2_clip_intersection2+0x16>
    return 0;
    1e70:	2000      	movs	r0, #0
}
    1e72:	bd30      	pop	{r4, r5, pc}
    return 0;
    1e74:	2000      	movs	r0, #0
    1e76:	e7fc      	b.n	1e72 <u8g2_clip_intersection2+0x3a>

00001e78 <u8g2_draw_hv_line_2dir>:
  This function first adjusts the y position to the local buffer. Then it
  will clip the line and call u8g2_draw_low_level_hv_line()

*/
void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    1e78:	b530      	push	{r4, r5, lr}
    1e7a:	b083      	sub	sp, #12
    1e7c:	ac06      	add	r4, sp, #24
    1e7e:	7825      	ldrb	r5, [r4, #0]

  /* clipping happens before the display rotation */

  /* transform to pixel buffer coordinates */
  y -= u8g2->pixel_curr_row;
    1e80:	8fc4      	ldrh	r4, [r0, #62]	; 0x3e
    1e82:	1b12      	subs	r2, r2, r4
    1e84:	b292      	uxth	r2, r2
  
  u8g2->ll_hvline(u8g2, x, y, len, dir);
    1e86:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    1e88:	9500      	str	r5, [sp, #0]
    1e8a:	47a0      	blx	r4
}
    1e8c:	b003      	add	sp, #12
    1e8e:	bd30      	pop	{r4, r5, pc}

00001e90 <u8g2_DrawHVLine>:
  This function should be called by the user.
  
  "dir" may have 4 directions: 0 (left to right), 1, 2, 3 (down up)
*/
void u8g2_DrawHVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    1e90:	b570      	push	{r4, r5, r6, lr}
    1e92:	b084      	sub	sp, #16
    1e94:	0004      	movs	r4, r0
    1e96:	a808      	add	r0, sp, #32
    1e98:	7805      	ldrb	r5, [r0, #0]
    1e9a:	200e      	movs	r0, #14
    1e9c:	4468      	add	r0, sp
    1e9e:	8001      	strh	r1, [r0, #0]
    1ea0:	a903      	add	r1, sp, #12
    1ea2:	800a      	strh	r2, [r1, #0]
    1ea4:	220a      	movs	r2, #10
    1ea6:	446a      	add	r2, sp
    1ea8:	8013      	strh	r3, [r2, #0]
  /* Make a call to the callback function (e.g. u8g2_draw_l90_r0). */
  /* The callback may rotate the hv line */
  /* after rotation this will call u8g2_draw_hv_line_4dir() */
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  if ( u8g2->is_page_clip_window_intersection != 0 )
    1eaa:	238c      	movs	r3, #140	; 0x8c
    1eac:	5ce3      	ldrb	r3, [r4, r3]
    1eae:	2b00      	cmp	r3, #0
    1eb0:	d015      	beq.n	1ede <u8g2_DrawHVLine+0x4e>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
    if ( len != 0 )
    1eb2:	8813      	ldrh	r3, [r2, #0]
    1eb4:	2b00      	cmp	r3, #0
    1eb6:	d012      	beq.n	1ede <u8g2_DrawHVLine+0x4e>
    {
    
      /* convert to two directions */    
      if ( len > 1 )
    1eb8:	2b01      	cmp	r3, #1
    1eba:	d903      	bls.n	1ec4 <u8g2_DrawHVLine+0x34>
      {
	if ( dir == 2 )
    1ebc:	2d02      	cmp	r5, #2
    1ebe:	d010      	beq.n	1ee2 <u8g2_DrawHVLine+0x52>
	{
	  x -= len;
	  x++;
	}
	else if ( dir == 3 )
    1ec0:	2d03      	cmp	r5, #3
    1ec2:	d014      	beq.n	1eee <u8g2_DrawHVLine+0x5e>
	{
	  y -= len;
	  y++;
	}
      }
      dir &= 1;  
    1ec4:	2301      	movs	r3, #1
    1ec6:	401d      	ands	r5, r3
      
      /* clip against the user window */
      if ( dir == 0 )
    1ec8:	d132      	bne.n	1f30 <u8g2_DrawHVLine+0xa0>
      {
	if ( y < u8g2->user_y0 )
    1eca:	334b      	adds	r3, #75	; 0x4b
    1ecc:	5ae2      	ldrh	r2, [r4, r3]
    1ece:	ab03      	add	r3, sp, #12
    1ed0:	881b      	ldrh	r3, [r3, #0]
    1ed2:	429a      	cmp	r2, r3
    1ed4:	d803      	bhi.n	1ede <u8g2_DrawHVLine+0x4e>
	  return;
	if ( y >= u8g2->user_y1 )
    1ed6:	224e      	movs	r2, #78	; 0x4e
    1ed8:	5aa2      	ldrh	r2, [r4, r2]
    1eda:	4293      	cmp	r3, r2
    1edc:	d30e      	bcc.n	1efc <u8g2_DrawHVLine+0x6c>
      }
      
      
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    }
}
    1ede:	b004      	add	sp, #16
    1ee0:	bd70      	pop	{r4, r5, r6, pc}
	  x -= len;
    1ee2:	8802      	ldrh	r2, [r0, #0]
    1ee4:	1ad3      	subs	r3, r2, r3
    1ee6:	b29b      	uxth	r3, r3
	  x++;
    1ee8:	3301      	adds	r3, #1
    1eea:	8003      	strh	r3, [r0, #0]
    1eec:	e7ea      	b.n	1ec4 <u8g2_DrawHVLine+0x34>
	  y -= len;
    1eee:	a903      	add	r1, sp, #12
    1ef0:	880a      	ldrh	r2, [r1, #0]
    1ef2:	1ad3      	subs	r3, r2, r3
    1ef4:	b29b      	uxth	r3, r3
	  y++;
    1ef6:	3301      	adds	r3, #1
    1ef8:	800b      	strh	r3, [r1, #0]
    1efa:	e7e3      	b.n	1ec4 <u8g2_DrawHVLine+0x34>
	if ( u8g2_clip_intersection2(&x, &len, u8g2->user_x0, u8g2->user_x1) == 0 )
    1efc:	234a      	movs	r3, #74	; 0x4a
    1efe:	5ae3      	ldrh	r3, [r4, r3]
    1f00:	2248      	movs	r2, #72	; 0x48
    1f02:	5aa2      	ldrh	r2, [r4, r2]
    1f04:	210a      	movs	r1, #10
    1f06:	4469      	add	r1, sp
    1f08:	200e      	movs	r0, #14
    1f0a:	4468      	add	r0, sp
    1f0c:	4e14      	ldr	r6, [pc, #80]	; (1f60 <u8g2_DrawHVLine+0xd0>)
    1f0e:	47b0      	blx	r6
    1f10:	2800      	cmp	r0, #0
    1f12:	d0e4      	beq.n	1ede <u8g2_DrawHVLine+0x4e>
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    1f14:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1f16:	689e      	ldr	r6, [r3, #8]
    1f18:	230a      	movs	r3, #10
    1f1a:	446b      	add	r3, sp
    1f1c:	881b      	ldrh	r3, [r3, #0]
    1f1e:	aa03      	add	r2, sp, #12
    1f20:	8812      	ldrh	r2, [r2, #0]
    1f22:	210e      	movs	r1, #14
    1f24:	4469      	add	r1, sp
    1f26:	8809      	ldrh	r1, [r1, #0]
    1f28:	9500      	str	r5, [sp, #0]
    1f2a:	0020      	movs	r0, r4
    1f2c:	47b0      	blx	r6
    1f2e:	e7d6      	b.n	1ede <u8g2_DrawHVLine+0x4e>
	if ( x < u8g2->user_x0 )
    1f30:	2348      	movs	r3, #72	; 0x48
    1f32:	5ae2      	ldrh	r2, [r4, r3]
    1f34:	3b3a      	subs	r3, #58	; 0x3a
    1f36:	446b      	add	r3, sp
    1f38:	881b      	ldrh	r3, [r3, #0]
    1f3a:	429a      	cmp	r2, r3
    1f3c:	d8cf      	bhi.n	1ede <u8g2_DrawHVLine+0x4e>
	if ( x >= u8g2->user_x1 )
    1f3e:	224a      	movs	r2, #74	; 0x4a
    1f40:	5aa2      	ldrh	r2, [r4, r2]
    1f42:	4293      	cmp	r3, r2
    1f44:	d2cb      	bcs.n	1ede <u8g2_DrawHVLine+0x4e>
	if ( u8g2_clip_intersection2(&y, &len, u8g2->user_y0, u8g2->user_y1) == 0 )
    1f46:	234e      	movs	r3, #78	; 0x4e
    1f48:	5ae3      	ldrh	r3, [r4, r3]
    1f4a:	224c      	movs	r2, #76	; 0x4c
    1f4c:	5aa2      	ldrh	r2, [r4, r2]
    1f4e:	210a      	movs	r1, #10
    1f50:	4469      	add	r1, sp
    1f52:	a803      	add	r0, sp, #12
    1f54:	4e02      	ldr	r6, [pc, #8]	; (1f60 <u8g2_DrawHVLine+0xd0>)
    1f56:	47b0      	blx	r6
    1f58:	2800      	cmp	r0, #0
    1f5a:	d1db      	bne.n	1f14 <u8g2_DrawHVLine+0x84>
    1f5c:	e7bf      	b.n	1ede <u8g2_DrawHVLine+0x4e>
    1f5e:	46c0      	nop			; (mov r8, r8)
    1f60:	00001e39 	.word	0x00001e39

00001f64 <u8g2_DrawPixel>:
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 1);
}

void u8g2_DrawPixel(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y)
{
    1f64:	b510      	push	{r4, lr}
    1f66:	b082      	sub	sp, #8
#ifdef U8G2_WITH_INTERSECTION
  if ( y < u8g2->user_y0 )
    1f68:	234c      	movs	r3, #76	; 0x4c
    1f6a:	5ac3      	ldrh	r3, [r0, r3]
    1f6c:	4293      	cmp	r3, r2
    1f6e:	d80b      	bhi.n	1f88 <u8g2_DrawPixel+0x24>
    return;
  if ( y >= u8g2->user_y1 )
    1f70:	234e      	movs	r3, #78	; 0x4e
    1f72:	5ac3      	ldrh	r3, [r0, r3]
    1f74:	429a      	cmp	r2, r3
    1f76:	d207      	bcs.n	1f88 <u8g2_DrawPixel+0x24>
    return;
  if ( x < u8g2->user_x0 )
    1f78:	2348      	movs	r3, #72	; 0x48
    1f7a:	5ac3      	ldrh	r3, [r0, r3]
    1f7c:	428b      	cmp	r3, r1
    1f7e:	d803      	bhi.n	1f88 <u8g2_DrawPixel+0x24>
    return;
  if ( x >= u8g2->user_x1 )
    1f80:	234a      	movs	r3, #74	; 0x4a
    1f82:	5ac3      	ldrh	r3, [r0, r3]
    1f84:	4299      	cmp	r1, r3
    1f86:	d301      	bcc.n	1f8c <u8g2_DrawPixel+0x28>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
}
    1f88:	b002      	add	sp, #8
    1f8a:	bd10      	pop	{r4, pc}
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
    1f8c:	2300      	movs	r3, #0
    1f8e:	9300      	str	r3, [sp, #0]
    1f90:	3301      	adds	r3, #1
    1f92:	4c01      	ldr	r4, [pc, #4]	; (1f98 <u8g2_DrawPixel+0x34>)
    1f94:	47a0      	blx	r4
    1f96:	e7f7      	b.n	1f88 <u8g2_DrawPixel+0x24>
    1f98:	00001e91 	.word	0x00001e91

00001f9c <u8g2_is_intersection_decision_tree>:
  a1 and v1 are excluded
  v0 == v1 is not support end return 1
*/
uint8_t u8g2_is_intersection_decision_tree(u8g2_uint_t a0, u8g2_uint_t a1, u8g2_uint_t v0, u8g2_uint_t v1)
{
  if ( v0 < a1 )		// v0 <= a1
    1f9c:	428a      	cmp	r2, r1
    1f9e:	d205      	bcs.n	1fac <u8g2_is_intersection_decision_tree+0x10>
  {
    if ( v1 > a0 )	// v1 >= a0
    1fa0:	4283      	cmp	r3, r0
    1fa2:	d80b      	bhi.n	1fbc <u8g2_is_intersection_decision_tree+0x20>
    {
      return 1;
    }
    else
    {
      if ( v0 > v1 )	// v0 > v1
    1fa4:	429a      	cmp	r2, r3
    1fa6:	d90b      	bls.n	1fc0 <u8g2_is_intersection_decision_tree+0x24>
      {
	return 1;
    1fa8:	2001      	movs	r0, #1
    1faa:	e008      	b.n	1fbe <u8g2_is_intersection_decision_tree+0x22>
      }
    }
  }
  else
  {
    if ( v1 > a0 )	// v1 >= a0
    1fac:	4283      	cmp	r3, r0
    1fae:	d909      	bls.n	1fc4 <u8g2_is_intersection_decision_tree+0x28>
    {
      if ( v0 > v1 )	// v0 > v1
    1fb0:	429a      	cmp	r2, r3
    1fb2:	d801      	bhi.n	1fb8 <u8g2_is_intersection_decision_tree+0x1c>
      {
	return 1;
      }
      else
      {
	return 0;
    1fb4:	2000      	movs	r0, #0
    1fb6:	e002      	b.n	1fbe <u8g2_is_intersection_decision_tree+0x22>
	return 1;
    1fb8:	2001      	movs	r0, #1
    1fba:	e000      	b.n	1fbe <u8g2_is_intersection_decision_tree+0x22>
      return 1;
    1fbc:	2001      	movs	r0, #1
    else
    {
      return 0;
    }
  }
}
    1fbe:	4770      	bx	lr
	return 0;
    1fc0:	2000      	movs	r0, #0
    1fc2:	e7fc      	b.n	1fbe <u8g2_is_intersection_decision_tree+0x22>
      return 0;
    1fc4:	2000      	movs	r0, #0
    1fc6:	e7fa      	b.n	1fbe <u8g2_is_intersection_decision_tree+0x22>

00001fc8 <u8g2_IsIntersection>:



/* upper limits are not included (asymetric boundaries) */
uint8_t u8g2_IsIntersection(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)
{
    1fc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1fca:	0006      	movs	r6, r0
    1fcc:	000c      	movs	r4, r1
    1fce:	001d      	movs	r5, r3
    1fd0:	ab06      	add	r3, sp, #24
    1fd2:	881b      	ldrh	r3, [r3, #0]
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    1fd4:	214e      	movs	r1, #78	; 0x4e
    1fd6:	5a41      	ldrh	r1, [r0, r1]
    1fd8:	204c      	movs	r0, #76	; 0x4c
    1fda:	5a30      	ldrh	r0, [r6, r0]
    1fdc:	4f05      	ldr	r7, [pc, #20]	; (1ff4 <u8g2_IsIntersection+0x2c>)
    1fde:	47b8      	blx	r7
    1fe0:	2800      	cmp	r0, #0
    1fe2:	d006      	beq.n	1ff2 <u8g2_IsIntersection+0x2a>
    return 0; 
  
  return u8g2_is_intersection_decision_tree(u8g2->user_x0, u8g2->user_x1, x0, x1);
    1fe4:	234a      	movs	r3, #74	; 0x4a
    1fe6:	5af1      	ldrh	r1, [r6, r3]
    1fe8:	3b02      	subs	r3, #2
    1fea:	5af0      	ldrh	r0, [r6, r3]
    1fec:	002b      	movs	r3, r5
    1fee:	0022      	movs	r2, r4
    1ff0:	47b8      	blx	r7
}
    1ff2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1ff4:	00001f9d 	.word	0x00001f9d

00001ff8 <u8g2_DrawLine>:

#include "u8g2.h"


void u8g2_DrawLine(u8g2_t *u8g2, u8g2_uint_t x1, u8g2_uint_t y1, u8g2_uint_t x2, u8g2_uint_t y2)
{
    1ff8:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ffa:	46de      	mov	lr, fp
    1ffc:	4657      	mov	r7, sl
    1ffe:	464e      	mov	r6, r9
    2000:	b5c0      	push	{r6, r7, lr}
    2002:	b082      	sub	sp, #8
    2004:	9000      	str	r0, [sp, #0]
    2006:	0017      	movs	r7, r2
    2008:	001e      	movs	r6, r3
    200a:	ab0a      	add	r3, sp, #40	; 0x28
    200c:	881d      	ldrh	r5, [r3, #0]

  uint8_t swapxy = 0;
  
  /* no intersection check at the moment, should be added... */

  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    200e:	42b1      	cmp	r1, r6
    2010:	d929      	bls.n	2066 <u8g2_DrawLine+0x6e>
    2012:	1b8b      	subs	r3, r1, r6
    2014:	b29b      	uxth	r3, r3
    2016:	4699      	mov	r9, r3
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    2018:	42af      	cmp	r7, r5
    201a:	d928      	bls.n	206e <u8g2_DrawLine+0x76>
    201c:	1b7b      	subs	r3, r7, r5
    201e:	b29b      	uxth	r3, r3
    2020:	469b      	mov	fp, r3

  if ( dy > dx ) 
    2022:	45d9      	cmp	r9, fp
    2024:	d327      	bcc.n	2076 <u8g2_DrawLine+0x7e>
    2026:	465b      	mov	r3, fp
    2028:	46cb      	mov	fp, r9
    202a:	4699      	mov	r9, r3
    202c:	002b      	movs	r3, r5
    202e:	0035      	movs	r5, r6
    2030:	001e      	movs	r6, r3
    2032:	003b      	movs	r3, r7
    2034:	000f      	movs	r7, r1
    2036:	0019      	movs	r1, r3
  uint8_t swapxy = 0;
    2038:	2300      	movs	r3, #0
    203a:	469a      	mov	sl, r3
    swapxy = 1;
    tmp = dx; dx =dy; dy = tmp;
    tmp = x1; x1 =y1; y1 = tmp;
    tmp = x2; x2 =y2; y2 = tmp;
  }
  if ( x1 > x2 ) 
    203c:	42af      	cmp	r7, r5
    203e:	d805      	bhi.n	204c <u8g2_DrawLine+0x54>
    2040:	0033      	movs	r3, r6
    2042:	000e      	movs	r6, r1
    2044:	0019      	movs	r1, r3
    2046:	002b      	movs	r3, r5
    2048:	003d      	movs	r5, r7
    204a:	001f      	movs	r7, r3
  {
    tmp = x1; x1 =x2; x2 = tmp;
    tmp = y1; y1 =y2; y2 = tmp;
  }
  err = dx >> 1;
    204c:	465b      	mov	r3, fp
    204e:	085c      	lsrs	r4, r3, #1
    2050:	b224      	sxth	r4, r4
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    2052:	428e      	cmp	r6, r1
    2054:	d212      	bcs.n	207c <u8g2_DrawLine+0x84>
    2056:	2301      	movs	r3, #1
    2058:	9301      	str	r3, [sp, #4]

#ifndef  U8G2_16BIT
  if ( x2 == 255 )
    x2--;
#else
  if ( x2 == 0xffff )
    205a:	4b1d      	ldr	r3, [pc, #116]	; (20d0 <u8g2_DrawLine+0xd8>)
    205c:	429f      	cmp	r7, r3
    205e:	d11e      	bne.n	209e <u8g2_DrawLine+0xa6>
    x2--;
    2060:	3f01      	subs	r7, #1
    2062:	b2bf      	uxth	r7, r7
#endif

  for( x = x1; x <= x2; x++ )
    2064:	e01b      	b.n	209e <u8g2_DrawLine+0xa6>
  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    2066:	1a73      	subs	r3, r6, r1
    2068:	b29b      	uxth	r3, r3
    206a:	4699      	mov	r9, r3
    206c:	e7d4      	b.n	2018 <u8g2_DrawLine+0x20>
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    206e:	1beb      	subs	r3, r5, r7
    2070:	b29b      	uxth	r3, r3
    2072:	469b      	mov	fp, r3
    2074:	e7d5      	b.n	2022 <u8g2_DrawLine+0x2a>
    swapxy = 1;
    2076:	2301      	movs	r3, #1
    2078:	469a      	mov	sl, r3
    207a:	e7df      	b.n	203c <u8g2_DrawLine+0x44>
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    207c:	2301      	movs	r3, #1
    207e:	425b      	negs	r3, r3
    2080:	9301      	str	r3, [sp, #4]
    2082:	e7ea      	b.n	205a <u8g2_DrawLine+0x62>
  {
    if ( swapxy == 0 ) 
      u8g2_DrawPixel(u8g2, x, y); 
    else 
      u8g2_DrawPixel(u8g2, y, x); 
    2084:	002a      	movs	r2, r5
    2086:	0031      	movs	r1, r6
    2088:	9800      	ldr	r0, [sp, #0]
    208a:	4b12      	ldr	r3, [pc, #72]	; (20d4 <u8g2_DrawLine+0xdc>)
    208c:	4798      	blx	r3
    err -= (u8g2_uint_t)dy;
    208e:	464b      	mov	r3, r9
    2090:	1ae4      	subs	r4, r4, r3
    2092:	b2a3      	uxth	r3, r4
    2094:	b21c      	sxth	r4, r3
    if ( err < 0 ) 
    2096:	2c00      	cmp	r4, #0
    2098:	db0c      	blt.n	20b4 <u8g2_DrawLine+0xbc>
  for( x = x1; x <= x2; x++ )
    209a:	3501      	adds	r5, #1
    209c:	b2ad      	uxth	r5, r5
    209e:	42af      	cmp	r7, r5
    20a0:	d30f      	bcc.n	20c2 <u8g2_DrawLine+0xca>
    if ( swapxy == 0 ) 
    20a2:	4653      	mov	r3, sl
    20a4:	2b00      	cmp	r3, #0
    20a6:	d1ed      	bne.n	2084 <u8g2_DrawLine+0x8c>
      u8g2_DrawPixel(u8g2, x, y); 
    20a8:	0032      	movs	r2, r6
    20aa:	0029      	movs	r1, r5
    20ac:	9800      	ldr	r0, [sp, #0]
    20ae:	4b09      	ldr	r3, [pc, #36]	; (20d4 <u8g2_DrawLine+0xdc>)
    20b0:	4798      	blx	r3
    20b2:	e7ec      	b.n	208e <u8g2_DrawLine+0x96>
    {
      y += (u8g2_uint_t)ystep;
    20b4:	466a      	mov	r2, sp
    20b6:	8892      	ldrh	r2, [r2, #4]
    20b8:	18b6      	adds	r6, r6, r2
    20ba:	b2b6      	uxth	r6, r6
      err += (u8g2_uint_t)dx;
    20bc:	445b      	add	r3, fp
    20be:	b21c      	sxth	r4, r3
    20c0:	e7eb      	b.n	209a <u8g2_DrawLine+0xa2>
    }
  }
}
    20c2:	b002      	add	sp, #8
    20c4:	bc1c      	pop	{r2, r3, r4}
    20c6:	4691      	mov	r9, r2
    20c8:	469a      	mov	sl, r3
    20ca:	46a3      	mov	fp, r4
    20cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    20ce:	46c0      	nop			; (mov r8, r8)
    20d0:	0000ffff 	.word	0x0000ffff
    20d4:	00001f65 	.word	0x00001f65

000020d8 <u8g2_ll_hvline_vertical_top_lsb>:
		1: vertical line (top to bottom)
  asumption: 
    all clipping done
*/
void u8g2_ll_hvline_vertical_top_lsb(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    20d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    20da:	46c6      	mov	lr, r8
    20dc:	b500      	push	{lr}
    20de:	4688      	mov	r8, r1
    20e0:	ac06      	add	r4, sp, #24
    20e2:	7827      	ldrb	r7, [r4, #0]
  //assert(y >= u8g2->buf_y0);
  //assert(y < u8g2_GetU8x8(u8g2)->display_info->tile_height*8);
  
  /* bytes are vertical, lsb on top (y=0), msb at bottom (y=7) */
  bit_pos = y;		/* overflow truncate is ok here... */
  bit_pos &= 7; 	/* ... because only the lowest 3 bits are needed */
    20e4:	2407      	movs	r4, #7
    20e6:	4014      	ands	r4, r2
  mask = 1;
  mask <<= bit_pos;
    20e8:	2501      	movs	r5, #1
    20ea:	40a5      	lsls	r5, r4
    20ec:	b2ed      	uxtb	r5, r5

  or_mask = 0;
  xor_mask = 0;
  if ( u8g2->draw_color <= 1 )
    20ee:	2692      	movs	r6, #146	; 0x92
    20f0:	5d86      	ldrb	r6, [r0, r6]
    20f2:	46b4      	mov	ip, r6
    20f4:	2e01      	cmp	r6, #1
    20f6:	d91f      	bls.n	2138 <u8g2_ll_hvline_vertical_top_lsb+0x60>
  or_mask = 0;
    20f8:	2600      	movs	r6, #0
    or_mask  = mask;
  if ( u8g2->draw_color != 1 )
    20fa:	4661      	mov	r1, ip
    20fc:	2901      	cmp	r1, #1
    20fe:	d01d      	beq.n	213c <u8g2_ll_hvline_vertical_top_lsb+0x64>
    xor_mask = mask;


  offset = y;		/* y might be 8 or 16 bit, but we need 16 bit, so use a 16 bit variable */
  offset &= ~7;
    2100:	2107      	movs	r1, #7
    2102:	438a      	bics	r2, r1
    2104:	4694      	mov	ip, r2
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
    2106:	6802      	ldr	r2, [r0, #0]
    2108:	7c12      	ldrb	r2, [r2, #16]
    210a:	4661      	mov	r1, ip
    210c:	434a      	muls	r2, r1
    210e:	b292      	uxth	r2, r2
  ptr = u8g2->tile_buf_ptr;
  ptr += offset;
  ptr += x;
    2110:	4442      	add	r2, r8
    2112:	0011      	movs	r1, r2
    2114:	6b42      	ldr	r2, [r0, #52]	; 0x34
    2116:	4694      	mov	ip, r2
    2118:	4461      	add	r1, ip
  
  if ( dir == 0 )
    211a:	2f00      	cmp	r7, #0
    211c:	d118      	bne.n	2150 <u8g2_ll_hvline_vertical_top_lsb+0x78>
      do
      {
#ifdef __unix
	assert(ptr < max_ptr);
#endif
	*ptr |= or_mask;
    211e:	780a      	ldrb	r2, [r1, #0]
    2120:	4332      	orrs	r2, r6
    2122:	b2d2      	uxtb	r2, r2
	*ptr ^= xor_mask;
    2124:	406a      	eors	r2, r5
    2126:	700a      	strb	r2, [r1, #0]
	ptr++;
    2128:	3101      	adds	r1, #1
	len--;
    212a:	3b01      	subs	r3, #1
    212c:	b29b      	uxth	r3, r3
      } while( len != 0 );
    212e:	2b00      	cmp	r3, #0
    2130:	d1f5      	bne.n	211e <u8g2_ll_hvline_vertical_top_lsb+0x46>
	or_mask <<= 1;
	xor_mask <<= 1;
      }
    } while( len != 0 );
  }
}
    2132:	bc04      	pop	{r2}
    2134:	4690      	mov	r8, r2
    2136:	bdf0      	pop	{r4, r5, r6, r7, pc}
    or_mask  = mask;
    2138:	002e      	movs	r6, r5
    213a:	e7de      	b.n	20fa <u8g2_ll_hvline_vertical_top_lsb+0x22>
  xor_mask = 0;
    213c:	2500      	movs	r5, #0
    213e:	e7df      	b.n	2100 <u8g2_ll_hvline_vertical_top_lsb+0x28>
	  or_mask  = 1;
    2140:	2601      	movs	r6, #1
    2142:	e017      	b.n	2174 <u8g2_ll_hvline_vertical_top_lsb+0x9c>
	or_mask <<= 1;
    2144:	0076      	lsls	r6, r6, #1
    2146:	b2f6      	uxtb	r6, r6
	xor_mask <<= 1;
    2148:	006d      	lsls	r5, r5, #1
    214a:	b2ed      	uxtb	r5, r5
    } while( len != 0 );
    214c:	2b00      	cmp	r3, #0
    214e:	d0f0      	beq.n	2132 <u8g2_ll_hvline_vertical_top_lsb+0x5a>
      *ptr |= or_mask;
    2150:	780a      	ldrb	r2, [r1, #0]
    2152:	4332      	orrs	r2, r6
    2154:	b2d2      	uxtb	r2, r2
      *ptr ^= xor_mask;
    2156:	406a      	eors	r2, r5
    2158:	700a      	strb	r2, [r1, #0]
      bit_pos++;
    215a:	3401      	adds	r4, #1
      bit_pos &= 7;
    215c:	2207      	movs	r2, #7
    215e:	4014      	ands	r4, r2
      len--;
    2160:	3b01      	subs	r3, #1
    2162:	b29b      	uxth	r3, r3
      if ( bit_pos == 0 )
    2164:	2c00      	cmp	r4, #0
    2166:	d1ed      	bne.n	2144 <u8g2_ll_hvline_vertical_top_lsb+0x6c>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    2168:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
    216a:	1889      	adds	r1, r1, r2
	if ( u8g2->draw_color <= 1 )
    216c:	2292      	movs	r2, #146	; 0x92
    216e:	5c82      	ldrb	r2, [r0, r2]
    2170:	2a01      	cmp	r2, #1
    2172:	d9e5      	bls.n	2140 <u8g2_ll_hvline_vertical_top_lsb+0x68>
	if ( u8g2->draw_color != 1 )
    2174:	2a01      	cmp	r2, #1
    2176:	d0e9      	beq.n	214c <u8g2_ll_hvline_vertical_top_lsb+0x74>
	  xor_mask = 1;
    2178:	2501      	movs	r5, #1
    217a:	e7e7      	b.n	214c <u8g2_ll_hvline_vertical_top_lsb+0x74>

0000217c <u8g2_update_dimension_common>:
    u8g2_uint_t buf_y0;
    u8g2_uint_t buf_y1; 	
*/

static void u8g2_update_dimension_common(u8g2_t *u8g2)
{
    217c:	b5f0      	push	{r4, r5, r6, r7, lr}
  const u8x8_display_info_t *display_info = u8g2_GetU8x8(u8g2)->display_info;
    217e:	6801      	ldr	r1, [r0, #0]
  u8g2_uint_t t;
  
  t = u8g2->tile_buf_height;
    2180:	2338      	movs	r3, #56	; 0x38
    2182:	5cc4      	ldrb	r4, [r0, r3]
    2184:	b2a3      	uxth	r3, r4
  t *= 8;
    2186:	00da      	lsls	r2, r3, #3
  u8g2->pixel_buf_height = t;
    2188:	8782      	strh	r2, [r0, #60]	; 0x3c
  
  t = display_info->tile_width;
    218a:	7c0a      	ldrb	r2, [r1, #16]
#ifndef U8G2_16BIT
  if ( t >= 32 )
    t = 31;
#endif
  t *= 8;
    218c:	00d2      	lsls	r2, r2, #3
  u8g2->pixel_buf_width = t;
    218e:	8742      	strh	r2, [r0, #58]	; 0x3a
  
  t = u8g2->tile_curr_row;
    2190:	2239      	movs	r2, #57	; 0x39
    2192:	5c86      	ldrb	r6, [r0, r2]
    2194:	b2b7      	uxth	r7, r6
  t *= 8;
    2196:	00fa      	lsls	r2, r7, #3
  u8g2->pixel_curr_row = t;
    2198:	87c2      	strh	r2, [r0, #62]	; 0x3e
  
  t = u8g2->tile_buf_height;
  /* handle the case, where the buffer is larger than the (remaining) part of the display */
  if ( t + u8g2->tile_curr_row > display_info->tile_height )
    219a:	19a4      	adds	r4, r4, r6
    219c:	7c4d      	ldrb	r5, [r1, #17]
    219e:	42ac      	cmp	r4, r5
    21a0:	dd01      	ble.n	21a6 <u8g2_update_dimension_common+0x2a>
    t = display_info->tile_height - u8g2->tile_curr_row;
    21a2:	1beb      	subs	r3, r5, r7
    21a4:	b29b      	uxth	r3, r3
  t *= 8;
    21a6:	00db      	lsls	r3, r3, #3
    21a8:	b29b      	uxth	r3, r3
  
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
    21aa:	2440      	movs	r4, #64	; 0x40
    21ac:	5302      	strh	r2, [r0, r4]
  u8g2->buf_y1 = u8g2->buf_y0;
  u8g2->buf_y1 += t;
    21ae:	18d3      	adds	r3, r2, r3
    21b0:	2242      	movs	r2, #66	; 0x42
    21b2:	5283      	strh	r3, [r0, r2]

  
#ifdef U8G2_16BIT
  u8g2->width = display_info->pixel_width;
    21b4:	8a8a      	ldrh	r2, [r1, #20]
    21b6:	2344      	movs	r3, #68	; 0x44
    21b8:	52c2      	strh	r2, [r0, r3]
  u8g2->height = display_info->pixel_height;
    21ba:	8aca      	ldrh	r2, [r1, #22]
    21bc:	3302      	adds	r3, #2
    21be:	52c2      	strh	r2, [r0, r3]
  if ( display_info->pixel_width <= 240 )
    u8g2->width = display_info->pixel_width;
  u8g2->height = display_info->pixel_height;
#endif

}
    21c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000021c4 <u8g2_update_dimension_r0>:

/*==========================================================*/


void u8g2_update_dimension_r0(u8g2_t *u8g2)
{
    21c4:	b510      	push	{r4, lr}
  u8g2_update_dimension_common(u8g2);  
    21c6:	4b01      	ldr	r3, [pc, #4]	; (21cc <u8g2_update_dimension_r0+0x8>)
    21c8:	4798      	blx	r3
}
    21ca:	bd10      	pop	{r4, pc}
    21cc:	0000217d 	.word	0x0000217d

000021d0 <u8g2_apply_clip_window>:
{
    21d0:	b530      	push	{r4, r5, lr}
    21d2:	b083      	sub	sp, #12
    21d4:	0004      	movs	r4, r0
  if ( u8g2_IsIntersection(u8g2, u8g2->clip_x0, u8g2->clip_y0, u8g2->clip_x1, u8g2->clip_y1) == 0 ) 
    21d6:	2352      	movs	r3, #82	; 0x52
    21d8:	5ac3      	ldrh	r3, [r0, r3]
    21da:	2254      	movs	r2, #84	; 0x54
    21dc:	5a82      	ldrh	r2, [r0, r2]
    21de:	2150      	movs	r1, #80	; 0x50
    21e0:	5a41      	ldrh	r1, [r0, r1]
    21e2:	2056      	movs	r0, #86	; 0x56
    21e4:	5a20      	ldrh	r0, [r4, r0]
    21e6:	9000      	str	r0, [sp, #0]
    21e8:	0020      	movs	r0, r4
    21ea:	4d16      	ldr	r5, [pc, #88]	; (2244 <u8g2_apply_clip_window+0x74>)
    21ec:	47a8      	blx	r5
    21ee:	2800      	cmp	r0, #0
    21f0:	d023      	beq.n	223a <u8g2_apply_clip_window+0x6a>
    u8g2->is_page_clip_window_intersection = 1;
    21f2:	2201      	movs	r2, #1
    21f4:	238c      	movs	r3, #140	; 0x8c
    21f6:	54e2      	strb	r2, [r4, r3]
    if ( u8g2->user_x0 < u8g2->clip_x0 )
    21f8:	3b44      	subs	r3, #68	; 0x44
    21fa:	5ae2      	ldrh	r2, [r4, r3]
    21fc:	3308      	adds	r3, #8
    21fe:	5ae3      	ldrh	r3, [r4, r3]
    2200:	429a      	cmp	r2, r3
    2202:	d201      	bcs.n	2208 <u8g2_apply_clip_window+0x38>
      u8g2->user_x0 = u8g2->clip_x0;
    2204:	2248      	movs	r2, #72	; 0x48
    2206:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_x1 > u8g2->clip_x1 )
    2208:	234a      	movs	r3, #74	; 0x4a
    220a:	5ae2      	ldrh	r2, [r4, r3]
    220c:	3308      	adds	r3, #8
    220e:	5ae3      	ldrh	r3, [r4, r3]
    2210:	429a      	cmp	r2, r3
    2212:	d901      	bls.n	2218 <u8g2_apply_clip_window+0x48>
      u8g2->user_x1 = u8g2->clip_x1;
    2214:	224a      	movs	r2, #74	; 0x4a
    2216:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
    2218:	234c      	movs	r3, #76	; 0x4c
    221a:	5ae2      	ldrh	r2, [r4, r3]
    221c:	3308      	adds	r3, #8
    221e:	5ae3      	ldrh	r3, [r4, r3]
    2220:	429a      	cmp	r2, r3
    2222:	d201      	bcs.n	2228 <u8g2_apply_clip_window+0x58>
      u8g2->user_y0 = u8g2->clip_y0;
    2224:	224c      	movs	r2, #76	; 0x4c
    2226:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_y1 > u8g2->clip_y1 )
    2228:	234e      	movs	r3, #78	; 0x4e
    222a:	5ae2      	ldrh	r2, [r4, r3]
    222c:	3308      	adds	r3, #8
    222e:	5ae3      	ldrh	r3, [r4, r3]
    2230:	429a      	cmp	r2, r3
    2232:	d905      	bls.n	2240 <u8g2_apply_clip_window+0x70>
      u8g2->user_y1 = u8g2->clip_y1;
    2234:	224e      	movs	r2, #78	; 0x4e
    2236:	52a3      	strh	r3, [r4, r2]
}
    2238:	e002      	b.n	2240 <u8g2_apply_clip_window+0x70>
    u8g2->is_page_clip_window_intersection = 0;
    223a:	2200      	movs	r2, #0
    223c:	238c      	movs	r3, #140	; 0x8c
    223e:	54e2      	strb	r2, [r4, r3]
}
    2240:	b003      	add	sp, #12
    2242:	bd30      	pop	{r4, r5, pc}
    2244:	00001fc9 	.word	0x00001fc9

00002248 <u8g2_update_page_win_r0>:

void u8g2_update_page_win_r0(u8g2_t *u8g2)
{
    2248:	b510      	push	{r4, lr}
  u8g2->user_x0 = 0;
    224a:	2200      	movs	r2, #0
    224c:	2348      	movs	r3, #72	; 0x48
    224e:	52c2      	strh	r2, [r0, r3]
  u8g2->user_x1 = u8g2->width;			/* pixel_buf_width replaced with width */
    2250:	3b04      	subs	r3, #4
    2252:	5ac2      	ldrh	r2, [r0, r3]
    2254:	3306      	adds	r3, #6
    2256:	52c2      	strh	r2, [r0, r3]
  
  u8g2->user_y0 = u8g2->buf_y0;
    2258:	3b0a      	subs	r3, #10
    225a:	5ac2      	ldrh	r2, [r0, r3]
    225c:	330c      	adds	r3, #12
    225e:	52c2      	strh	r2, [r0, r3]
  u8g2->user_y1 = u8g2->buf_y1;
    2260:	3b0a      	subs	r3, #10
    2262:	5ac2      	ldrh	r2, [r0, r3]
    2264:	330c      	adds	r3, #12
    2266:	52c2      	strh	r2, [r0, r3]
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_apply_clip_window(u8g2);
    2268:	4b01      	ldr	r3, [pc, #4]	; (2270 <u8g2_update_page_win_r0+0x28>)
    226a:	4798      	blx	r3
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
}
    226c:	bd10      	pop	{r4, pc}
    226e:	46c0      	nop			; (mov r8, r8)
    2270:	000021d1 	.word	0x000021d1

00002274 <u8g2_draw_l90_r0>:
/*============================================*/
extern void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir);


void u8g2_draw_l90_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    2274:	b510      	push	{r4, lr}
    2276:	b082      	sub	sp, #8
    2278:	ac04      	add	r4, sp, #16
    227a:	7824      	ldrb	r4, [r4, #0]
#ifdef __unix
  assert( dir <= 1 );
#endif
  u8g2_draw_hv_line_2dir(u8g2, x, y, len, dir);
    227c:	9400      	str	r4, [sp, #0]
    227e:	4c02      	ldr	r4, [pc, #8]	; (2288 <u8g2_draw_l90_r0+0x14>)
    2280:	47a0      	blx	r4
}
    2282:	b002      	add	sp, #8
    2284:	bd10      	pop	{r4, pc}
    2286:	46c0      	nop			; (mov r8, r8)
    2288:	00001e79 	.word	0x00001e79

0000228c <u8g2_SetMaxClipWindow>:
{
    228c:	b510      	push	{r4, lr}
  u8g2->clip_x0 = 0;
    228e:	2300      	movs	r3, #0
    2290:	2250      	movs	r2, #80	; 0x50
    2292:	5283      	strh	r3, [r0, r2]
  u8g2->clip_y0 = 0;
    2294:	3204      	adds	r2, #4
    2296:	5283      	strh	r3, [r0, r2]
  u8g2->clip_x1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    2298:	3b01      	subs	r3, #1
    229a:	3a02      	subs	r2, #2
    229c:	5283      	strh	r3, [r0, r2]
  u8g2->clip_y1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    229e:	3204      	adds	r2, #4
    22a0:	5283      	strh	r3, [r0, r2]
  u8g2->cb->update_page_win(u8g2);
    22a2:	6b03      	ldr	r3, [r0, #48]	; 0x30
    22a4:	685b      	ldr	r3, [r3, #4]
    22a6:	4798      	blx	r3
}
    22a8:	bd10      	pop	{r4, pc}
	...

000022ac <u8g2_SetupBuffer>:
{
    22ac:	b570      	push	{r4, r5, r6, lr}
    22ae:	0004      	movs	r4, r0
    22b0:	9804      	ldr	r0, [sp, #16]
  u8g2->font = NULL;
    22b2:	2500      	movs	r5, #0
    22b4:	65a5      	str	r5, [r4, #88]	; 0x58
  u8g2->ll_hvline = ll_hvline_cb;
    22b6:	62e3      	str	r3, [r4, #44]	; 0x2c
  u8g2->tile_buf_ptr = buf;
    22b8:	6361      	str	r1, [r4, #52]	; 0x34
  u8g2->tile_buf_height = tile_buf_height;
    22ba:	2338      	movs	r3, #56	; 0x38
    22bc:	54e2      	strb	r2, [r4, r3]
  u8g2->tile_curr_row = 0;
    22be:	3301      	adds	r3, #1
    22c0:	54e5      	strb	r5, [r4, r3]
  u8g2->font_decode.is_transparent = 0; /* issue 443 */
    22c2:	3334      	adds	r3, #52	; 0x34
    22c4:	54e5      	strb	r5, [r4, r3]
  u8g2->bitmap_transparency = 0;
    22c6:	3324      	adds	r3, #36	; 0x24
    22c8:	54e5      	strb	r5, [r4, r3]
  u8g2->font_height_mode = 0; /* issue 2046 */
    22ca:	3b04      	subs	r3, #4
    22cc:	54e5      	strb	r5, [r4, r3]
  u8g2->draw_color = 1;
    22ce:	3b8c      	subs	r3, #140	; 0x8c
    22d0:	2292      	movs	r2, #146	; 0x92
    22d2:	54a3      	strb	r3, [r4, r2]
  u8g2->is_auto_page_clear = 1;
    22d4:	3201      	adds	r2, #1
    22d6:	54a3      	strb	r3, [r4, r2]
  u8g2->cb = u8g2_cb;
    22d8:	6320      	str	r0, [r4, #48]	; 0x30
  u8g2->cb->update_dimension(u8g2);
    22da:	6803      	ldr	r3, [r0, #0]
    22dc:	0020      	movs	r0, r4
    22de:	4798      	blx	r3
  u8g2_SetMaxClipWindow(u8g2);		/* assign a clip window and call the update() procedure */
    22e0:	0020      	movs	r0, r4
    22e2:	4b04      	ldr	r3, [pc, #16]	; (22f4 <u8g2_SetupBuffer+0x48>)
    22e4:	4798      	blx	r3
  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
    22e6:	0020      	movs	r0, r4
    22e8:	4b03      	ldr	r3, [pc, #12]	; (22f8 <u8g2_SetupBuffer+0x4c>)
    22ea:	4798      	blx	r3
  u8g2->font_decode.dir = 0;
    22ec:	2370      	movs	r3, #112	; 0x70
    22ee:	54e5      	strb	r5, [r4, r3]
}
    22f0:	bd70      	pop	{r4, r5, r6, pc}
    22f2:	46c0      	nop			; (mov r8, r8)
    22f4:	0000228d 	.word	0x0000228d
    22f8:	00001e09 	.word	0x00001e09

000022fc <u8x8_ascii_next>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
}

uint16_t u8x8_ascii_next(U8X8_UNUSED u8x8_t *u8x8, uint8_t b)
{
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    22fc:	2900      	cmp	r1, #0
    22fe:	d101      	bne.n	2304 <u8x8_ascii_next+0x8>
    return 0x0ffff;	/* end of string detected*/
    2300:	4803      	ldr	r0, [pc, #12]	; (2310 <u8x8_ascii_next+0x14>)
  return b;
}
    2302:	4770      	bx	lr
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    2304:	290a      	cmp	r1, #10
    2306:	d001      	beq.n	230c <u8x8_ascii_next+0x10>
  return b;
    2308:	b288      	uxth	r0, r1
    230a:	e7fa      	b.n	2302 <u8x8_ascii_next+0x6>
    return 0x0ffff;	/* end of string detected*/
    230c:	4800      	ldr	r0, [pc, #0]	; (2310 <u8x8_ascii_next+0x14>)
    230e:	e7f8      	b.n	2302 <u8x8_ascii_next+0x6>
    2310:	0000ffff 	.word	0x0000ffff

00002314 <u8x8_utf8_init>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
    2314:	2200      	movs	r2, #0
    2316:	2326      	movs	r3, #38	; 0x26
    2318:	54c2      	strb	r2, [r0, r3]
}
    231a:	4770      	bx	lr

0000231c <u8x8_byte_SetDC>:
*/

#include "u8x8.h"

uint8_t u8x8_byte_SetDC(u8x8_t *u8x8, uint8_t dc)
{
    231c:	b510      	push	{r4, lr}
    231e:	000a      	movs	r2, r1
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SET_DC, dc, NULL);
    2320:	6904      	ldr	r4, [r0, #16]
    2322:	2300      	movs	r3, #0
    2324:	2120      	movs	r1, #32
    2326:	47a0      	blx	r4
}
    2328:	bd10      	pop	{r4, pc}

0000232a <u8x8_byte_SendBytes>:

uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    232a:	b510      	push	{r4, lr}
    232c:	0013      	movs	r3, r2
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SEND, cnt, (void *)data);
    232e:	6904      	ldr	r4, [r0, #16]
    2330:	000a      	movs	r2, r1
    2332:	2117      	movs	r1, #23
    2334:	47a0      	blx	r4
}
    2336:	bd10      	pop	{r4, pc}

00002338 <u8x8_byte_SendByte>:

uint8_t u8x8_byte_SendByte(u8x8_t *u8x8, uint8_t byte)
{
    2338:	b500      	push	{lr}
    233a:	b083      	sub	sp, #12
    233c:	466b      	mov	r3, sp
    233e:	1dda      	adds	r2, r3, #7
    2340:	7011      	strb	r1, [r2, #0]
  return u8x8_byte_SendBytes(u8x8, 1, &byte);
    2342:	2101      	movs	r1, #1
    2344:	4b01      	ldr	r3, [pc, #4]	; (234c <u8x8_byte_SendByte+0x14>)
    2346:	4798      	blx	r3
}
    2348:	b003      	add	sp, #12
    234a:	bd00      	pop	{pc}
    234c:	0000232b 	.word	0x0000232b

00002350 <u8x8_cad_SendCmd>:
*/

#include "u8x8.h"

uint8_t u8x8_cad_SendCmd(u8x8_t *u8x8, uint8_t cmd)
{
    2350:	b510      	push	{r4, lr}
    2352:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_CMD, cmd, NULL);
    2354:	68c4      	ldr	r4, [r0, #12]
    2356:	2300      	movs	r3, #0
    2358:	2115      	movs	r1, #21
    235a:	47a0      	blx	r4
}
    235c:	bd10      	pop	{r4, pc}

0000235e <u8x8_cad_SendArg>:

uint8_t u8x8_cad_SendArg(u8x8_t *u8x8, uint8_t arg)
{
    235e:	b510      	push	{r4, lr}
    2360:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_ARG, arg, NULL);
    2362:	68c4      	ldr	r4, [r0, #12]
    2364:	2300      	movs	r3, #0
    2366:	2116      	movs	r1, #22
    2368:	47a0      	blx	r4
}
    236a:	bd10      	pop	{r4, pc}

0000236c <u8x8_cad_SendData>:
  }
  return 1;
}

uint8_t u8x8_cad_SendData(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    236c:	b510      	push	{r4, lr}
    236e:	0013      	movs	r3, r2
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, cnt, data);
    2370:	68c4      	ldr	r4, [r0, #12]
    2372:	000a      	movs	r2, r1
    2374:	2117      	movs	r1, #23
    2376:	47a0      	blx	r4
}
    2378:	bd10      	pop	{r4, pc}

0000237a <u8x8_cad_StartTransfer>:

uint8_t u8x8_cad_StartTransfer(u8x8_t *u8x8)
{
    237a:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
    237c:	68c4      	ldr	r4, [r0, #12]
    237e:	2300      	movs	r3, #0
    2380:	2200      	movs	r2, #0
    2382:	2118      	movs	r1, #24
    2384:	47a0      	blx	r4
}
    2386:	bd10      	pop	{r4, pc}

00002388 <u8x8_cad_EndTransfer>:

uint8_t u8x8_cad_EndTransfer(u8x8_t *u8x8)
{
    2388:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
    238a:	68c4      	ldr	r4, [r0, #12]
    238c:	2300      	movs	r3, #0
    238e:	2200      	movs	r2, #0
    2390:	2119      	movs	r1, #25
    2392:	47a0      	blx	r4
}
    2394:	bd10      	pop	{r4, pc}
	...

00002398 <u8x8_cad_SendSequence>:
  254 milli	delay by milliseconds
  255		end of sequence
*/

void u8x8_cad_SendSequence(u8x8_t *u8x8, uint8_t const *data)
{
    2398:	b570      	push	{r4, r5, r6, lr}
    239a:	b082      	sub	sp, #8
    239c:	0006      	movs	r6, r0
    239e:	000c      	movs	r4, r1
  uint8_t cmd;
  uint8_t v;

  for(;;)
  {
    cmd = *data;
    23a0:	7821      	ldrb	r1, [r4, #0]
    data++;
    23a2:	1c65      	adds	r5, r4, #1
    switch( cmd )
    23a4:	2917      	cmp	r1, #23
    23a6:	d018      	beq.n	23da <u8x8_cad_SendSequence+0x42>
    23a8:	d90c      	bls.n	23c4 <u8x8_cad_SendSequence+0x2c>
    23aa:	2919      	cmp	r1, #25
    23ac:	d91f      	bls.n	23ee <u8x8_cad_SendSequence+0x56>
    23ae:	29fe      	cmp	r1, #254	; 0xfe
    23b0:	d124      	bne.n	23fc <u8x8_cad_SendSequence+0x64>
      case U8X8_MSG_CAD_START_TRANSFER:
      case U8X8_MSG_CAD_END_TRANSFER:
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
	  break;
      case 0x0fe:
	  v = *data;
    23b2:	782a      	ldrb	r2, [r5, #0]
    23b4:	466b      	mov	r3, sp
    23b6:	71da      	strb	r2, [r3, #7]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
    23b8:	2129      	movs	r1, #41	; 0x29
    23ba:	0030      	movs	r0, r6
    23bc:	4b10      	ldr	r3, [pc, #64]	; (2400 <u8x8_cad_SendSequence+0x68>)
    23be:	4798      	blx	r3
	  data++;
    23c0:	3402      	adds	r4, #2
	  break;
    23c2:	e7ed      	b.n	23a0 <u8x8_cad_SendSequence+0x8>
    switch( cmd )
    23c4:	2915      	cmp	r1, #21
    23c6:	d319      	bcc.n	23fc <u8x8_cad_SendSequence+0x64>
	  v = *data;
    23c8:	782a      	ldrb	r2, [r5, #0]
    23ca:	466b      	mov	r3, sp
    23cc:	71da      	strb	r2, [r3, #7]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
    23ce:	2300      	movs	r3, #0
    23d0:	0030      	movs	r0, r6
    23d2:	68f5      	ldr	r5, [r6, #12]
    23d4:	47a8      	blx	r5
	  data++;
    23d6:	3402      	adds	r4, #2
	  break;
    23d8:	e7e2      	b.n	23a0 <u8x8_cad_SendSequence+0x8>
	  v = *data;
    23da:	7863      	ldrb	r3, [r4, #1]
    23dc:	466a      	mov	r2, sp
    23de:	3207      	adds	r2, #7
    23e0:	7013      	strb	r3, [r2, #0]
	  u8x8_cad_SendData(u8x8, 1, &v);
    23e2:	2101      	movs	r1, #1
    23e4:	0030      	movs	r0, r6
    23e6:	4b07      	ldr	r3, [pc, #28]	; (2404 <u8x8_cad_SendSequence+0x6c>)
    23e8:	4798      	blx	r3
	  data++;
    23ea:	3402      	adds	r4, #2
	  break;
    23ec:	e7d8      	b.n	23a0 <u8x8_cad_SendSequence+0x8>
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
    23ee:	2300      	movs	r3, #0
    23f0:	2200      	movs	r2, #0
    23f2:	0030      	movs	r0, r6
    23f4:	68f4      	ldr	r4, [r6, #12]
    23f6:	47a0      	blx	r4
    data++;
    23f8:	002c      	movs	r4, r5
	  break;
    23fa:	e7d1      	b.n	23a0 <u8x8_cad_SendSequence+0x8>
      default:
	return;
    }
  }
}
    23fc:	b002      	add	sp, #8
    23fe:	bd70      	pop	{r4, r5, r6, pc}
    2400:	00002705 	.word	0x00002705
    2404:	0000236d 	.word	0x0000236d

00002408 <u8x8_cad_011>:
  convert to bytes by using 
    dc = 0 for commands 
    dc = 1 for args and data
*/
uint8_t u8x8_cad_011(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2408:	b5f0      	push	{r4, r5, r6, r7, lr}
    240a:	b083      	sub	sp, #12
    240c:	0004      	movs	r4, r0
    240e:	000d      	movs	r5, r1
    2410:	0016      	movs	r6, r2
    2412:	9301      	str	r3, [sp, #4]
  switch(msg)
    2414:	000b      	movs	r3, r1
    2416:	3b14      	subs	r3, #20
    2418:	b2da      	uxtb	r2, r3
    241a:	2a05      	cmp	r2, #5
    241c:	d820      	bhi.n	2460 <u8x8_cad_011+0x58>
    241e:	0093      	lsls	r3, r2, #2
    2420:	4a10      	ldr	r2, [pc, #64]	; (2464 <u8x8_cad_011+0x5c>)
    2422:	58d3      	ldr	r3, [r2, r3]
    2424:	469f      	mov	pc, r3
  {
    case U8X8_MSG_CAD_SEND_CMD:
      u8x8_byte_SetDC(u8x8, 0);
    2426:	2100      	movs	r1, #0
    2428:	4b0f      	ldr	r3, [pc, #60]	; (2468 <u8x8_cad_011+0x60>)
    242a:	4798      	blx	r3
      u8x8_byte_SendByte(u8x8, arg_int);
    242c:	0031      	movs	r1, r6
    242e:	0020      	movs	r0, r4
    2430:	4b0e      	ldr	r3, [pc, #56]	; (246c <u8x8_cad_011+0x64>)
    2432:	4798      	blx	r3
    case U8X8_MSG_CAD_END_TRANSFER:
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    default:
      return 0;
  }
  return 1;
    2434:	2001      	movs	r0, #1
      break;
    2436:	e011      	b.n	245c <u8x8_cad_011+0x54>
      u8x8_byte_SetDC(u8x8, 1);
    2438:	2101      	movs	r1, #1
    243a:	4b0b      	ldr	r3, [pc, #44]	; (2468 <u8x8_cad_011+0x60>)
    243c:	4798      	blx	r3
      u8x8_byte_SendByte(u8x8, arg_int);
    243e:	0031      	movs	r1, r6
    2440:	0020      	movs	r0, r4
    2442:	4b0a      	ldr	r3, [pc, #40]	; (246c <u8x8_cad_011+0x64>)
    2444:	4798      	blx	r3
  return 1;
    2446:	2001      	movs	r0, #1
      break;
    2448:	e008      	b.n	245c <u8x8_cad_011+0x54>
      u8x8_byte_SetDC(u8x8, 1);
    244a:	2101      	movs	r1, #1
    244c:	4b06      	ldr	r3, [pc, #24]	; (2468 <u8x8_cad_011+0x60>)
    244e:	4798      	blx	r3
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    2450:	6927      	ldr	r7, [r4, #16]
    2452:	9b01      	ldr	r3, [sp, #4]
    2454:	0032      	movs	r2, r6
    2456:	0029      	movs	r1, r5
    2458:	0020      	movs	r0, r4
    245a:	47b8      	blx	r7
}
    245c:	b003      	add	sp, #12
    245e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return 0;
    2460:	2000      	movs	r0, #0
    2462:	e7fb      	b.n	245c <u8x8_cad_011+0x54>
    2464:	00003f94 	.word	0x00003f94
    2468:	0000231d 	.word	0x0000231d
    246c:	00002339 	.word	0x00002339

00002470 <u8x8_d_helper_display_setup_memory>:
  
*/
void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8, const u8x8_display_info_t *display_info)
{
      /* 1) set display info struct */
      u8x8->display_info = display_info;
    2470:	6001      	str	r1, [r0, #0]
      u8x8->x_offset = u8x8->display_info->default_x_offset;
    2472:	7c8a      	ldrb	r2, [r1, #18]
    2474:	2322      	movs	r3, #34	; 0x22
    2476:	54c2      	strb	r2, [r0, r3]
}
    2478:	4770      	bx	lr
	...

0000247c <u8x8_d_helper_display_init>:
  this is a helper function for the U8X8_MSG_DISPLAY_INIT function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_init(u8x8_t *u8x8)
{
    247c:	b570      	push	{r4, r5, r6, lr}
    247e:	0004      	movs	r4, r0
      /* 2) apply port directions to the GPIO lines and apply default values for the IO lines*/
      u8x8_gpio_Init(u8x8);
    2480:	2300      	movs	r3, #0
    2482:	2200      	movs	r2, #0
    2484:	2128      	movs	r1, #40	; 0x28
    2486:	6945      	ldr	r5, [r0, #20]
    2488:	47a8      	blx	r5
      u8x8_cad_Init(u8x8);              /* this will also call U8X8_MSG_BYTE_INIT, byte init will NOT call GPIO_INIT */
    248a:	2300      	movs	r3, #0
    248c:	2200      	movs	r2, #0
    248e:	2114      	movs	r1, #20
    2490:	0020      	movs	r0, r4
    2492:	68e5      	ldr	r5, [r4, #12]
    2494:	47a8      	blx	r5

      /* 3) do reset */
      u8x8_gpio_SetReset(u8x8, 1);
    2496:	2201      	movs	r2, #1
    2498:	214b      	movs	r1, #75	; 0x4b
    249a:	0020      	movs	r0, r4
    249c:	4d0c      	ldr	r5, [pc, #48]	; (24d0 <u8x8_d_helper_display_init+0x54>)
    249e:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    24a0:	6823      	ldr	r3, [r4, #0]
    24a2:	791a      	ldrb	r2, [r3, #4]
    24a4:	2129      	movs	r1, #41	; 0x29
    24a6:	0020      	movs	r0, r4
    24a8:	47a8      	blx	r5
      u8x8_gpio_SetReset(u8x8, 0);
    24aa:	2200      	movs	r2, #0
    24ac:	214b      	movs	r1, #75	; 0x4b
    24ae:	0020      	movs	r0, r4
    24b0:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    24b2:	6823      	ldr	r3, [r4, #0]
    24b4:	791a      	ldrb	r2, [r3, #4]
    24b6:	2129      	movs	r1, #41	; 0x29
    24b8:	0020      	movs	r0, r4
    24ba:	47a8      	blx	r5
      u8x8_gpio_SetReset(u8x8, 1);
    24bc:	2201      	movs	r2, #1
    24be:	214b      	movs	r1, #75	; 0x4b
    24c0:	0020      	movs	r0, r4
    24c2:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->post_reset_wait_ms);
    24c4:	6823      	ldr	r3, [r4, #0]
    24c6:	795a      	ldrb	r2, [r3, #5]
    24c8:	2129      	movs	r1, #41	; 0x29
    24ca:	0020      	movs	r0, r4
    24cc:	47a8      	blx	r5
}    
    24ce:	bd70      	pop	{r4, r5, r6, pc}
    24d0:	00002705 	.word	0x00002705

000024d4 <u8x8_DrawTile>:

/*==========================================*/
/* official functions */

uint8_t u8x8_DrawTile(u8x8_t *u8x8, uint8_t x, uint8_t y, uint8_t cnt, uint8_t *tile_ptr)
{
    24d4:	b510      	push	{r4, lr}
    24d6:	b082      	sub	sp, #8
  u8x8_tile_t tile;
  tile.x_pos = x;
    24d8:	466c      	mov	r4, sp
    24da:	7161      	strb	r1, [r4, #5]
  tile.y_pos = y;
    24dc:	71a2      	strb	r2, [r4, #6]
  tile.cnt = cnt;
    24de:	7123      	strb	r3, [r4, #4]
  tile.tile_ptr = tile_ptr;
    24e0:	9b04      	ldr	r3, [sp, #16]
    24e2:	9300      	str	r3, [sp, #0]
  return u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_DRAW_TILE, 1, (void *)&tile);
    24e4:	6884      	ldr	r4, [r0, #8]
    24e6:	466b      	mov	r3, sp
    24e8:	2201      	movs	r2, #1
    24ea:	210f      	movs	r1, #15
    24ec:	47a0      	blx	r4
}
    24ee:	b002      	add	sp, #8
    24f0:	bd10      	pop	{r4, pc}

000024f2 <u8x8_SetupMemory>:

/* should be implemented as macro */
void u8x8_SetupMemory(u8x8_t *u8x8)
{
    24f2:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    24f4:	6884      	ldr	r4, [r0, #8]
    24f6:	2300      	movs	r3, #0
    24f8:	2200      	movs	r2, #0
    24fa:	2109      	movs	r1, #9
    24fc:	47a0      	blx	r4
}
    24fe:	bd10      	pop	{r4, pc}

00002500 <u8x8_InitDisplay>:
  In some cases it is not required to init the display (for example if the display is already running, but the controller comes out of deep sleep mode).
  Then InitDisplay can be skipped, but u8x8_InitInterface()  (== u8x8_gpio_Init() and u8x8_cad_Init()) need to be executed.

*/
void u8x8_InitDisplay(u8x8_t *u8x8)
{
    2500:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);       /* this will call u8x8_d_helper_display_init() and send the init seqence to the display */
    2502:	6884      	ldr	r4, [r0, #8]
    2504:	2300      	movs	r3, #0
    2506:	2200      	movs	r2, #0
    2508:	210a      	movs	r1, #10
    250a:	47a0      	blx	r4
  /* u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, 0, NULL);  */ /* It would make sense to call flip mode 0 here after U8X8_MSG_DISPLAY_INIT */
}
    250c:	bd10      	pop	{r4, pc}

0000250e <u8x8_RefreshDisplay>:
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_CONTRAST, value, NULL);  
}

void u8x8_RefreshDisplay(u8x8_t *u8x8)
{
    250e:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    2510:	6884      	ldr	r4, [r0, #8]
    2512:	2300      	movs	r3, #0
    2514:	2200      	movs	r2, #0
    2516:	2110      	movs	r1, #16
    2518:	47a0      	blx	r4
}
    251a:	bd10      	pop	{r4, pc}

0000251c <u8x8_convert_tile_for_ssd1607>:

static uint8_t *u8x8_convert_tile_for_ssd1607(uint8_t *t)
{
	uint8_t i;
	static uint8_t buf[8];
	uint8_t *pbuf = buf;
    251c:	4a06      	ldr	r2, [pc, #24]	; (2538 <u8x8_convert_tile_for_ssd1607+0x1c>)

	for( i = 0; i < 8; i++ )
    251e:	2300      	movs	r3, #0
    2520:	e005      	b.n	252e <u8x8_convert_tile_for_ssd1607+0x12>
	{
		*pbuf++ = (*t++);
    2522:	7801      	ldrb	r1, [r0, #0]
    2524:	7011      	strb	r1, [r2, #0]
	for( i = 0; i < 8; i++ )
    2526:	3301      	adds	r3, #1
    2528:	b2db      	uxtb	r3, r3
		*pbuf++ = (*t++);
    252a:	3201      	adds	r2, #1
    252c:	3001      	adds	r0, #1
	for( i = 0; i < 8; i++ )
    252e:	2b07      	cmp	r3, #7
    2530:	d9f7      	bls.n	2522 <u8x8_convert_tile_for_ssd1607+0x6>
	}
	return buf;
}
    2532:	4801      	ldr	r0, [pc, #4]	; (2538 <u8x8_convert_tile_for_ssd1607+0x1c>)
    2534:	4770      	bx	lr
    2536:	46c0      	nop			; (mov r8, r8)
    2538:	200016e0 	.word	0x200016e0

0000253c <u8x8_d_gdey0154_152x304_first_init>:
{
    253c:	b530      	push	{r4, r5, lr}
    253e:	b087      	sub	sp, #28
    2540:	0005      	movs	r5, r0
	u8x8_cad_StartTransfer(u8x8);
    2542:	4b17      	ldr	r3, [pc, #92]	; (25a0 <u8x8_d_gdey0154_152x304_first_init+0x64>)
    2544:	4798      	blx	r3
	u8x8_cad_SendCmd(u8x8, 0x10);
    2546:	2110      	movs	r1, #16
    2548:	0028      	movs	r0, r5
    254a:	4b16      	ldr	r3, [pc, #88]	; (25a4 <u8x8_d_gdey0154_152x304_first_init+0x68>)
    254c:	4798      	blx	r3
	uint8_t dat[19] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    254e:	2213      	movs	r2, #19
    2550:	2100      	movs	r1, #0
    2552:	a801      	add	r0, sp, #4
    2554:	4b14      	ldr	r3, [pc, #80]	; (25a8 <u8x8_d_gdey0154_152x304_first_init+0x6c>)
    2556:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    2558:	2400      	movs	r4, #0
    255a:	e006      	b.n	256a <u8x8_d_gdey0154_152x304_first_init+0x2e>
		u8x8_cad_SendData(u8x8, 19, dat);
    255c:	aa01      	add	r2, sp, #4
    255e:	2113      	movs	r1, #19
    2560:	0028      	movs	r0, r5
    2562:	4b12      	ldr	r3, [pc, #72]	; (25ac <u8x8_d_gdey0154_152x304_first_init+0x70>)
    2564:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    2566:	3401      	adds	r4, #1
    2568:	b2a4      	uxth	r4, r4
    256a:	2330      	movs	r3, #48	; 0x30
    256c:	33ff      	adds	r3, #255	; 0xff
    256e:	429c      	cmp	r4, r3
    2570:	d9f4      	bls.n	255c <u8x8_d_gdey0154_152x304_first_init+0x20>
	u8x8_cad_SendCmd(u8x8, 0x13);
    2572:	2113      	movs	r1, #19
    2574:	0028      	movs	r0, r5
    2576:	4b0b      	ldr	r3, [pc, #44]	; (25a4 <u8x8_d_gdey0154_152x304_first_init+0x68>)
    2578:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    257a:	2400      	movs	r4, #0
    257c:	e006      	b.n	258c <u8x8_d_gdey0154_152x304_first_init+0x50>
		u8x8_cad_SendData(u8x8, 19, dat);
    257e:	aa01      	add	r2, sp, #4
    2580:	2113      	movs	r1, #19
    2582:	0028      	movs	r0, r5
    2584:	4b09      	ldr	r3, [pc, #36]	; (25ac <u8x8_d_gdey0154_152x304_first_init+0x70>)
    2586:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    2588:	3401      	adds	r4, #1
    258a:	b2a4      	uxth	r4, r4
    258c:	2330      	movs	r3, #48	; 0x30
    258e:	33ff      	adds	r3, #255	; 0xff
    2590:	429c      	cmp	r4, r3
    2592:	d9f4      	bls.n	257e <u8x8_d_gdey0154_152x304_first_init+0x42>
	u8x8_cad_EndTransfer(u8x8);
    2594:	0028      	movs	r0, r5
    2596:	4b06      	ldr	r3, [pc, #24]	; (25b0 <u8x8_d_gdey0154_152x304_first_init+0x74>)
    2598:	4798      	blx	r3
}
    259a:	b007      	add	sp, #28
    259c:	bd30      	pop	{r4, r5, pc}
    259e:	46c0      	nop			; (mov r8, r8)
    25a0:	0000237b 	.word	0x0000237b
    25a4:	00002351 	.word	0x00002351
    25a8:	00002cb1 	.word	0x00002cb1
    25ac:	0000236d 	.word	0x0000236d
    25b0:	00002389 	.word	0x00002389

000025b4 <u8x8_d_ssd1607_draw_tile>:

static void u8x8_d_ssd1607_draw_tile(u8x8_t *u8x8, uint8_t arg_int, void *arg_ptr) U8X8_NOINLINE;
static void u8x8_d_ssd1607_draw_tile(u8x8_t *u8x8, uint8_t arg_int, void *arg_ptr)
{
    25b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    25b6:	46ce      	mov	lr, r9
    25b8:	4647      	mov	r7, r8
    25ba:	b580      	push	{r7, lr}
    25bc:	0006      	movs	r6, r0
    25be:	000f      	movs	r7, r1
    25c0:	4690      	mov	r8, r2
	uint16_t x;
	uint16_t c, page;
	uint8_t *ptr;
	u8x8_cad_StartTransfer(u8x8);
    25c2:	4b26      	ldr	r3, [pc, #152]	; (265c <u8x8_d_ssd1607_draw_tile+0xa8>)
    25c4:	4798      	blx	r3

	page = u8x8->display_info->tile_height;
    25c6:	6833      	ldr	r3, [r6, #0]
    25c8:	7c5c      	ldrb	r4, [r3, #17]
	page --;
    25ca:	3c01      	subs	r4, #1
    25cc:	b2a4      	uxth	r4, r4
	page -= (((u8x8_tile_t *)arg_ptr)->y_pos);
    25ce:	4643      	mov	r3, r8
    25d0:	799b      	ldrb	r3, [r3, #6]
    25d2:	1ae4      	subs	r4, r4, r3
    25d4:	b2a4      	uxth	r4, r4
	
	x = ((u8x8_tile_t *)arg_ptr)->x_pos;
	x *= 8;
	x += u8x8->x_offset;
	
	u8x8_cad_SendCmd(u8x8, 0x91);			//Partial Window (PTL)
    25d6:	2191      	movs	r1, #145	; 0x91
    25d8:	0030      	movs	r0, r6
    25da:	4b21      	ldr	r3, [pc, #132]	; (2660 <u8x8_d_ssd1607_draw_tile+0xac>)
    25dc:	4699      	mov	r9, r3
    25de:	4798      	blx	r3
	u8x8_cad_SendCmd(u8x8, 0x90);			//Partial In (PTIN)
    25e0:	2190      	movs	r1, #144	; 0x90
    25e2:	0030      	movs	r0, r6
    25e4:	47c8      	blx	r9
	
	u8x8_cad_SendArg(u8x8, page << 3);		//HRST[7:3]
    25e6:	00e4      	lsls	r4, r4, #3
    25e8:	b2e4      	uxtb	r4, r4
    25ea:	0021      	movs	r1, r4
    25ec:	0030      	movs	r0, r6
    25ee:	4d1d      	ldr	r5, [pc, #116]	; (2664 <u8x8_d_ssd1607_draw_tile+0xb0>)
    25f0:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, page << 3);		//HRED[7:3]
    25f2:	0021      	movs	r1, r4
    25f4:	0030      	movs	r0, r6
    25f6:	47a8      	blx	r5

	u8x8_cad_SendArg(u8x8, 0x00);			//VRST[8]
    25f8:	2100      	movs	r1, #0
    25fa:	0030      	movs	r0, r6
    25fc:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, 0x00);			//VRST[7:0]
    25fe:	2100      	movs	r1, #0
    2600:	0030      	movs	r0, r6
    2602:	47a8      	blx	r5

	u8x8_cad_SendArg(u8x8, 0x01);			//VRED[8]
    2604:	2101      	movs	r1, #1
    2606:	0030      	movs	r0, r6
    2608:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, 0x30);			//VRED[7:0]
    260a:	2130      	movs	r1, #48	; 0x30
    260c:	0030      	movs	r0, r6
    260e:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, 1);				//PT_SCAN
    2610:	2101      	movs	r1, #1
    2612:	0030      	movs	r0, r6
    2614:	47a8      	blx	r5
	u8x8_cad_SendCmd(u8x8, 0x10 );
    2616:	2110      	movs	r1, #16
    2618:	0030      	movs	r0, r6
    261a:	47c8      	blx	r9
	
	do
	{
		c = ((u8x8_tile_t *)arg_ptr)->cnt;
    261c:	4643      	mov	r3, r8
    261e:	791c      	ldrb	r4, [r3, #4]
		
		ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;
    2620:	681d      	ldr	r5, [r3, #0]
		do
		{
			u8x8_cad_SendData(u8x8, 8, u8x8_convert_tile_for_ssd1607(ptr));
    2622:	0028      	movs	r0, r5
    2624:	4b10      	ldr	r3, [pc, #64]	; (2668 <u8x8_d_ssd1607_draw_tile+0xb4>)
    2626:	4798      	blx	r3
    2628:	0002      	movs	r2, r0
    262a:	2108      	movs	r1, #8
    262c:	0030      	movs	r0, r6
    262e:	4b0f      	ldr	r3, [pc, #60]	; (266c <u8x8_d_ssd1607_draw_tile+0xb8>)
    2630:	4798      	blx	r3
			ptr += 8;
    2632:	3508      	adds	r5, #8
			x += 8;
			c--;
    2634:	3c01      	subs	r4, #1
    2636:	b2a4      	uxth	r4, r4
		} while( c > 0 );
    2638:	2c00      	cmp	r4, #0
    263a:	d1f2      	bne.n	2622 <u8x8_d_ssd1607_draw_tile+0x6e>
		arg_int--;
    263c:	3f01      	subs	r7, #1
    263e:	b2ff      	uxtb	r7, r7
	} while( arg_int > 0 );
    2640:	2f00      	cmp	r7, #0
    2642:	d1eb      	bne.n	261c <u8x8_d_ssd1607_draw_tile+0x68>
	u8x8_cad_SendCmd(u8x8, 0x92);		//Partial Out (PTOUT)
    2644:	2192      	movs	r1, #146	; 0x92
    2646:	0030      	movs	r0, r6
    2648:	4b05      	ldr	r3, [pc, #20]	; (2660 <u8x8_d_ssd1607_draw_tile+0xac>)
    264a:	4798      	blx	r3
	u8x8_cad_EndTransfer(u8x8);
    264c:	0030      	movs	r0, r6
    264e:	4b08      	ldr	r3, [pc, #32]	; (2670 <u8x8_d_ssd1607_draw_tile+0xbc>)
    2650:	4798      	blx	r3
}
    2652:	bc0c      	pop	{r2, r3}
    2654:	4690      	mov	r8, r2
    2656:	4699      	mov	r9, r3
    2658:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    265a:	46c0      	nop			; (mov r8, r8)
    265c:	0000237b 	.word	0x0000237b
    2660:	00002351 	.word	0x00002351
    2664:	0000235f 	.word	0x0000235f
    2668:	0000251d 	.word	0x0000251d
    266c:	0000236d 	.word	0x0000236d
    2670:	00002389 	.word	0x00002389

00002674 <u8x8_d_gdey0154_152x304>:
	U8X8_END_TRANSFER(),             	/* disable chip */
	U8X8_END()             			/* end of sequence */
};

uint8_t u8x8_d_gdey0154_152x304(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2674:	b570      	push	{r4, r5, r6, lr}
    2676:	0004      	movs	r4, r0
    2678:	0010      	movs	r0, r2
	switch(msg)
    267a:	3909      	subs	r1, #9
    267c:	b2cd      	uxtb	r5, r1
    267e:	2d07      	cmp	r5, #7
    2680:	d803      	bhi.n	268a <u8x8_d_gdey0154_152x304+0x16>
    2682:	00a9      	lsls	r1, r5, #2
    2684:	4a15      	ldr	r2, [pc, #84]	; (26dc <u8x8_d_gdey0154_152x304+0x68>)
    2686:	5852      	ldr	r2, [r2, r1]
    2688:	4697      	mov	pc, r2
		break;
		case U8X8_MSG_DISPLAY_REFRESH:
		u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1607_to_display_seq);
		break;
		default:
		return 0;
    268a:	2000      	movs	r0, #0
    268c:	e024      	b.n	26d8 <u8x8_d_gdey0154_152x304+0x64>
		u8x8_d_helper_display_setup_memory(u8x8, &u8x8_ssd1607_200x200_display_info);
    268e:	4914      	ldr	r1, [pc, #80]	; (26e0 <u8x8_d_gdey0154_152x304+0x6c>)
    2690:	0020      	movs	r0, r4
    2692:	4b14      	ldr	r3, [pc, #80]	; (26e4 <u8x8_d_gdey0154_152x304+0x70>)
    2694:	4798      	blx	r3
	}
	return 1;
    2696:	2001      	movs	r0, #1
		break;
    2698:	e01e      	b.n	26d8 <u8x8_d_gdey0154_152x304+0x64>
		u8x8_d_helper_display_init(u8x8);
    269a:	0020      	movs	r0, r4
    269c:	4b12      	ldr	r3, [pc, #72]	; (26e8 <u8x8_d_gdey0154_152x304+0x74>)
    269e:	4798      	blx	r3
		u8x8_cad_SendSequence(u8x8, u8x8_d_gdey0154_152x304_init_seq);
    26a0:	4912      	ldr	r1, [pc, #72]	; (26ec <u8x8_d_gdey0154_152x304+0x78>)
    26a2:	0020      	movs	r0, r4
    26a4:	4b12      	ldr	r3, [pc, #72]	; (26f0 <u8x8_d_gdey0154_152x304+0x7c>)
    26a6:	4798      	blx	r3
		delay_ms(20);
    26a8:	2014      	movs	r0, #20
    26aa:	4d12      	ldr	r5, [pc, #72]	; (26f4 <u8x8_d_gdey0154_152x304+0x80>)
    26ac:	47a8      	blx	r5
		u8x8_d_gdey0154_152x304_first_init(u8x8);
    26ae:	0020      	movs	r0, r4
    26b0:	4b11      	ldr	r3, [pc, #68]	; (26f8 <u8x8_d_gdey0154_152x304+0x84>)
    26b2:	4798      	blx	r3
		delay_ms(20);
    26b4:	2014      	movs	r0, #20
    26b6:	47a8      	blx	r5
	return 1;
    26b8:	2001      	movs	r0, #1
		break;
    26ba:	e00d      	b.n	26d8 <u8x8_d_gdey0154_152x304+0x64>
		u8x8_d_ssd1607_draw_tile(u8x8, arg_int, arg_ptr);
    26bc:	001a      	movs	r2, r3
    26be:	0001      	movs	r1, r0
    26c0:	0020      	movs	r0, r4
    26c2:	4b0e      	ldr	r3, [pc, #56]	; (26fc <u8x8_d_gdey0154_152x304+0x88>)
    26c4:	4798      	blx	r3
	return 1;
    26c6:	2001      	movs	r0, #1
		break;
    26c8:	e006      	b.n	26d8 <u8x8_d_gdey0154_152x304+0x64>
		u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1607_to_display_seq);
    26ca:	490d      	ldr	r1, [pc, #52]	; (2700 <u8x8_d_gdey0154_152x304+0x8c>)
    26cc:	0020      	movs	r0, r4
    26ce:	4b08      	ldr	r3, [pc, #32]	; (26f0 <u8x8_d_gdey0154_152x304+0x7c>)
    26d0:	4798      	blx	r3
	return 1;
    26d2:	2001      	movs	r0, #1
		break;
    26d4:	e000      	b.n	26d8 <u8x8_d_gdey0154_152x304+0x64>
	return 1;
    26d6:	2001      	movs	r0, #1
}
    26d8:	bd70      	pop	{r4, r5, r6, pc}
    26da:	46c0      	nop			; (mov r8, r8)
    26dc:	00003fac 	.word	0x00003fac
    26e0:	0000400c 	.word	0x0000400c
    26e4:	00002471 	.word	0x00002471
    26e8:	0000247d 	.word	0x0000247d
    26ec:	00003fcc 	.word	0x00003fcc
    26f0:	00002399 	.word	0x00002399
    26f4:	000001c1 	.word	0x000001c1
    26f8:	0000253d 	.word	0x0000253d
    26fc:	000025b5 	.word	0x000025b5
    2700:	00004004 	.word	0x00004004

00002704 <u8x8_gpio_call>:

#include "u8x8.h"


void u8x8_gpio_call(u8x8_t *u8x8, uint8_t msg, uint8_t arg)
{
    2704:	b510      	push	{r4, lr}
  u8x8->gpio_and_delay_cb(u8x8, msg, arg, NULL);
    2706:	6944      	ldr	r4, [r0, #20]
    2708:	2300      	movs	r3, #0
    270a:	47a0      	blx	r4
}
    270c:	bd10      	pop	{r4, pc}

0000270e <u8x8_dummy_cb>:
/* universal dummy callback, which will be default for all callbacks */
uint8_t u8x8_dummy_cb(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
  /* the dummy callback will not handle any message and will fail for all messages */
  return 0;
}
    270e:	2000      	movs	r0, #0
    2710:	4770      	bx	lr
	...

00002714 <u8x8_SetupDefaults>:
  Args:
    u8x8	An empty u8x8 structure
*/
void u8x8_SetupDefaults(u8x8_t *u8x8)
{
    u8x8->display_info = NULL;
    2714:	2300      	movs	r3, #0
    2716:	6003      	str	r3, [r0, #0]
    u8x8->display_cb = u8x8_dummy_cb;
    2718:	4a07      	ldr	r2, [pc, #28]	; (2738 <u8x8_SetupDefaults+0x24>)
    271a:	6082      	str	r2, [r0, #8]
    u8x8->cad_cb = u8x8_dummy_cb;
    271c:	60c2      	str	r2, [r0, #12]
    u8x8->byte_cb = u8x8_dummy_cb;
    271e:	6102      	str	r2, [r0, #16]
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    2720:	6142      	str	r2, [r0, #20]
    u8x8->is_font_inverse_mode = 0;
    2722:	2223      	movs	r2, #35	; 0x23
    2724:	5483      	strb	r3, [r0, r2]
    //u8x8->device_address = 0;
    u8x8->utf8_state = 0;		/* also reset by u8x8_utf8_init */
    2726:	3203      	adds	r2, #3
    2728:	5483      	strb	r3, [r0, r2]
    u8x8->bus_clock = 0;		/* issue 769 */
    272a:	6183      	str	r3, [r0, #24]
    u8x8->i2c_address = 255;
    272c:	33ff      	adds	r3, #255	; 0xff
    272e:	3a02      	subs	r2, #2
    2730:	5483      	strb	r3, [r0, r2]
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    2732:	3204      	adds	r2, #4
    2734:	5483      	strb	r3, [r0, r2]
    uint8_t i;
    for( i = 0; i < U8X8_PIN_CNT; i++ )
      u8x8->pins[i] = U8X8_PIN_NONE;
  }
#endif
}
    2736:	4770      	bx	lr
    2738:	0000270f 	.word	0x0000270f

0000273c <u8x8_Setup>:
    byte_cb			Display controller/communication specific callback funtion
    gpio_and_delay_cb	Environment specific callback function

*/
void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    273c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    273e:	0004      	movs	r4, r0
    2740:	000f      	movs	r7, r1
    2742:	0016      	movs	r6, r2
    2744:	001d      	movs	r5, r3
  /* setup defaults and reset pins to U8X8_PIN_NONE */
  u8x8_SetupDefaults(u8x8);
    2746:	4b05      	ldr	r3, [pc, #20]	; (275c <u8x8_Setup+0x20>)
    2748:	4798      	blx	r3

  /* setup specific callbacks */
  u8x8->display_cb = display_cb;
    274a:	60a7      	str	r7, [r4, #8]
  u8x8->cad_cb = cad_cb;
    274c:	60e6      	str	r6, [r4, #12]
  u8x8->byte_cb = byte_cb;
    274e:	6125      	str	r5, [r4, #16]
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    2750:	9b06      	ldr	r3, [sp, #24]
    2752:	6163      	str	r3, [r4, #20]

  /* setup display info */
  u8x8_SetupMemory(u8x8);
    2754:	0020      	movs	r0, r4
    2756:	4b02      	ldr	r3, [pc, #8]	; (2760 <u8x8_Setup+0x24>)
    2758:	4798      	blx	r3
}
    275a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    275c:	00002715 	.word	0x00002715
    2760:	000024f3 	.word	0x000024f3

00002764 <rtc_int_enable>:
	"Sat"
};



void rtc_int_enable(rtc_date *RTCx){
    2764:	b570      	push	{r4, r5, r6, lr}
	rtc_config_3[1] |= (1 << TIE);
    2766:	4d0c      	ldr	r5, [pc, #48]	; (2798 <rtc_int_enable+0x34>)
    2768:	786b      	ldrb	r3, [r5, #1]
    276a:	2210      	movs	r2, #16
    276c:	4313      	orrs	r3, r2
    276e:	706b      	strb	r3, [r5, #1]
	rtc_config_2[1] |= (1 << TD) | (1 << TE);
    2770:	4e0a      	ldr	r6, [pc, #40]	; (279c <rtc_int_enable+0x38>)
    2772:	7873      	ldrb	r3, [r6, #1]
    2774:	2211      	movs	r2, #17
    2776:	4313      	orrs	r3, r2
    2778:	7073      	strb	r3, [r6, #1]
	
	RTC_write_batch(RTC_ADDR, rtc_config_1,sizeof(rtc_config_1));
    277a:	2203      	movs	r2, #3
    277c:	4908      	ldr	r1, [pc, #32]	; (27a0 <rtc_int_enable+0x3c>)
    277e:	2032      	movs	r0, #50	; 0x32
    2780:	4c08      	ldr	r4, [pc, #32]	; (27a4 <rtc_int_enable+0x40>)
    2782:	47a0      	blx	r4
	RTC_write_batch(RTC_ADDR, rtc_config_2,sizeof(rtc_config_2));
    2784:	2202      	movs	r2, #2
    2786:	0031      	movs	r1, r6
    2788:	2032      	movs	r0, #50	; 0x32
    278a:	47a0      	blx	r4
	RTC_write_batch(RTC_ADDR, rtc_config_3,sizeof(rtc_config_3));
    278c:	2202      	movs	r2, #2
    278e:	0029      	movs	r1, r5
    2790:	2032      	movs	r0, #50	; 0x32
    2792:	47a0      	blx	r4
	
	
}
    2794:	bd70      	pop	{r4, r5, r6, pc}
    2796:	46c0      	nop			; (mov r8, r8)
    2798:	20000008 	.word	0x20000008
    279c:	20000004 	.word	0x20000004
    27a0:	20000000 	.word	0x20000000
    27a4:	000011f9 	.word	0x000011f9

000027a8 <BCDtoDEC>:
	rtc_raw[7]=DECtoBCD(RTCx->year);
	RTC_write_batch(RTC_ADDR, rtc_raw,sizeof(rtc_raw));
}

uint8_t BCDtoDEC(uint8_t val)
{
    27a8:	0001      	movs	r1, r0
	return ((val / 0x10) * 10) + (val % 0x10);
    27aa:	0902      	lsrs	r2, r0, #4
    27ac:	0093      	lsls	r3, r2, #2
    27ae:	18d2      	adds	r2, r2, r3
    27b0:	0053      	lsls	r3, r2, #1
    27b2:	b2db      	uxtb	r3, r3
    27b4:	200f      	movs	r0, #15
    27b6:	4008      	ands	r0, r1
    27b8:	1818      	adds	r0, r3, r0
    27ba:	b2c0      	uxtb	r0, r0
}
    27bc:	4770      	bx	lr
	...

000027c0 <rtc_sync>:
void rtc_sync(rtc_date *RTCx){
    27c0:	b530      	push	{r4, r5, lr}
    27c2:	b083      	sub	sp, #12
    27c4:	0004      	movs	r4, r0
	RTC_read_batch(RTC_ADDR, rtc_raw, sizeof(rtc_raw));
    27c6:	2207      	movs	r2, #7
    27c8:	4669      	mov	r1, sp
    27ca:	2032      	movs	r0, #50	; 0x32
    27cc:	4b0f      	ldr	r3, [pc, #60]	; (280c <rtc_sync+0x4c>)
    27ce:	4798      	blx	r3
	RTCx->second=BCDtoDEC(rtc_raw[0]);
    27d0:	466b      	mov	r3, sp
    27d2:	7818      	ldrb	r0, [r3, #0]
    27d4:	4d0e      	ldr	r5, [pc, #56]	; (2810 <rtc_sync+0x50>)
    27d6:	47a8      	blx	r5
    27d8:	7020      	strb	r0, [r4, #0]
	RTCx->minute=BCDtoDEC(rtc_raw[1]);
    27da:	466b      	mov	r3, sp
    27dc:	7858      	ldrb	r0, [r3, #1]
    27de:	47a8      	blx	r5
    27e0:	7060      	strb	r0, [r4, #1]
	RTCx->hour=BCDtoDEC(rtc_raw[2]);
    27e2:	466b      	mov	r3, sp
    27e4:	7898      	ldrb	r0, [r3, #2]
    27e6:	47a8      	blx	r5
    27e8:	70a0      	strb	r0, [r4, #2]
	RTCx->dayofweek=rtc_raw[3];
    27ea:	466b      	mov	r3, sp
    27ec:	78db      	ldrb	r3, [r3, #3]
    27ee:	7223      	strb	r3, [r4, #8]
	RTCx->date=BCDtoDEC(rtc_raw[4]);
    27f0:	466b      	mov	r3, sp
    27f2:	7918      	ldrb	r0, [r3, #4]
    27f4:	47a8      	blx	r5
    27f6:	70e0      	strb	r0, [r4, #3]
	RTCx->month=BCDtoDEC(rtc_raw[5]);
    27f8:	466b      	mov	r3, sp
    27fa:	7958      	ldrb	r0, [r3, #5]
    27fc:	47a8      	blx	r5
    27fe:	7120      	strb	r0, [r4, #4]
	RTCx->year=BCDtoDEC(rtc_raw[6]);
    2800:	466b      	mov	r3, sp
    2802:	7998      	ldrb	r0, [r3, #6]
    2804:	47a8      	blx	r5
    2806:	80e0      	strh	r0, [r4, #6]
}
    2808:	b003      	add	sp, #12
    280a:	bd30      	pop	{r4, r5, pc}
    280c:	0000122d 	.word	0x0000122d
    2810:	000027a9 	.word	0x000027a9

00002814 <DECtoBCD>:

// BCDtoDEC -- convert decimal to binary-coded decimal (BCD)
uint8_t DECtoBCD(uint8_t val)
{
    2814:	b570      	push	{r4, r5, r6, lr}
    2816:	0005      	movs	r5, r0
	return ((val / 10) * 0x10) + (val % 10);
    2818:	210a      	movs	r1, #10
    281a:	4b05      	ldr	r3, [pc, #20]	; (2830 <DECtoBCD+0x1c>)
    281c:	4798      	blx	r3
    281e:	0100      	lsls	r0, r0, #4
    2820:	b2c4      	uxtb	r4, r0
    2822:	210a      	movs	r1, #10
    2824:	0028      	movs	r0, r5
    2826:	4b03      	ldr	r3, [pc, #12]	; (2834 <DECtoBCD+0x20>)
    2828:	4798      	blx	r3
    282a:	1864      	adds	r4, r4, r1
    282c:	b2e0      	uxtb	r0, r4
}
    282e:	bd70      	pop	{r4, r5, r6, pc}
    2830:	00002afd 	.word	0x00002afd
    2834:	00002c09 	.word	0x00002c09

00002838 <rtc_set>:
void rtc_set(rtc_date *RTCx){
    2838:	b530      	push	{r4, r5, lr}
    283a:	b083      	sub	sp, #12
    283c:	0004      	movs	r4, r0
	rtc_raw[0] = 0;
    283e:	2300      	movs	r3, #0
    2840:	466a      	mov	r2, sp
    2842:	7013      	strb	r3, [r2, #0]
	rtc_raw[1]=DECtoBCD(RTCx->second);
    2844:	7800      	ldrb	r0, [r0, #0]
    2846:	4d11      	ldr	r5, [pc, #68]	; (288c <rtc_set+0x54>)
    2848:	47a8      	blx	r5
    284a:	466b      	mov	r3, sp
    284c:	7058      	strb	r0, [r3, #1]
	rtc_raw[2]=DECtoBCD(RTCx->minute);
    284e:	7860      	ldrb	r0, [r4, #1]
    2850:	47a8      	blx	r5
    2852:	466b      	mov	r3, sp
    2854:	7098      	strb	r0, [r3, #2]
	rtc_raw[3]=DECtoBCD(RTCx->hour);
    2856:	78a0      	ldrb	r0, [r4, #2]
    2858:	47a8      	blx	r5
    285a:	466b      	mov	r3, sp
    285c:	70d8      	strb	r0, [r3, #3]
	rtc_raw[4]=RTCx->dayofweek;
    285e:	7a23      	ldrb	r3, [r4, #8]
    2860:	466a      	mov	r2, sp
    2862:	7113      	strb	r3, [r2, #4]
	rtc_raw[5]=DECtoBCD(RTCx->date);
    2864:	78e0      	ldrb	r0, [r4, #3]
    2866:	47a8      	blx	r5
    2868:	466b      	mov	r3, sp
    286a:	7158      	strb	r0, [r3, #5]
	rtc_raw[6]=DECtoBCD(RTCx->month);
    286c:	7920      	ldrb	r0, [r4, #4]
    286e:	47a8      	blx	r5
    2870:	466b      	mov	r3, sp
    2872:	7198      	strb	r0, [r3, #6]
	rtc_raw[7]=DECtoBCD(RTCx->year);
    2874:	79a0      	ldrb	r0, [r4, #6]
    2876:	47a8      	blx	r5
    2878:	466b      	mov	r3, sp
    287a:	71d8      	strb	r0, [r3, #7]
	RTC_write_batch(RTC_ADDR, rtc_raw,sizeof(rtc_raw));
    287c:	2208      	movs	r2, #8
    287e:	4669      	mov	r1, sp
    2880:	2032      	movs	r0, #50	; 0x32
    2882:	4b03      	ldr	r3, [pc, #12]	; (2890 <rtc_set+0x58>)
    2884:	4798      	blx	r3
}
    2886:	b003      	add	sp, #12
    2888:	bd30      	pop	{r4, r5, pc}
    288a:	46c0      	nop			; (mov r8, r8)
    288c:	00002815 	.word	0x00002815
    2890:	000011f9 	.word	0x000011f9

00002894 <main>:
	.second = 00
};


int main(void)
{
    2894:	b5f0      	push	{r4, r5, r6, r7, lr}
    2896:	b085      	sub	sp, #20
	/* Initializes MCU, drivers and middleware */
	//atmel_start_init();
	mcu_init();
    2898:	4b72      	ldr	r3, [pc, #456]	; (2a64 <main+0x1d0>)
    289a:	4798      	blx	r3
	
	rtc_set(&sys_rtc);
    289c:	4c72      	ldr	r4, [pc, #456]	; (2a68 <main+0x1d4>)
    289e:	0020      	movs	r0, r4
    28a0:	4b72      	ldr	r3, [pc, #456]	; (2a6c <main+0x1d8>)
    28a2:	4798      	blx	r3
	rtc_int_enable(&sys_rtc);
    28a4:	0020      	movs	r0, r4
    28a6:	4b72      	ldr	r3, [pc, #456]	; (2a70 <main+0x1dc>)
    28a8:	4798      	blx	r3

	u8g2_Setup_GDEY0154_152x304_f(&lcd, U8G2_R0, screenSpi, screenSpi);
    28aa:	4a72      	ldr	r2, [pc, #456]	; (2a74 <main+0x1e0>)
    28ac:	4c72      	ldr	r4, [pc, #456]	; (2a78 <main+0x1e4>)
    28ae:	0013      	movs	r3, r2
    28b0:	4972      	ldr	r1, [pc, #456]	; (2a7c <main+0x1e8>)
    28b2:	0020      	movs	r0, r4
    28b4:	4d72      	ldr	r5, [pc, #456]	; (2a80 <main+0x1ec>)
    28b6:	47a8      	blx	r5
	
	
	u8g2_InitDisplay(&lcd);
    28b8:	0020      	movs	r0, r4
    28ba:	4b72      	ldr	r3, [pc, #456]	; (2a84 <main+0x1f0>)
    28bc:	4798      	blx	r3
	u8g2_ClearBuffer(&lcd);
    28be:	0020      	movs	r0, r4
    28c0:	4b71      	ldr	r3, [pc, #452]	; (2a88 <main+0x1f4>)
    28c2:	4798      	blx	r3
	
	
	
	
	
	u8g2_DrawLine(&lcd, 70, 1, 70 , 90);
    28c4:	265a      	movs	r6, #90	; 0x5a
    28c6:	9600      	str	r6, [sp, #0]
    28c8:	2346      	movs	r3, #70	; 0x46
    28ca:	2201      	movs	r2, #1
    28cc:	2146      	movs	r1, #70	; 0x46
    28ce:	0020      	movs	r0, r4
    28d0:	4d6e      	ldr	r5, [pc, #440]	; (2a8c <main+0x1f8>)
    28d2:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 140, 1, 140 , 90);
    28d4:	9600      	str	r6, [sp, #0]
    28d6:	238c      	movs	r3, #140	; 0x8c
    28d8:	2201      	movs	r2, #1
    28da:	218c      	movs	r1, #140	; 0x8c
    28dc:	0020      	movs	r0, r4
    28de:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 210, 1, 210 , 90);
    28e0:	9600      	str	r6, [sp, #0]
    28e2:	23d2      	movs	r3, #210	; 0xd2
    28e4:	2201      	movs	r2, #1
    28e6:	21d2      	movs	r1, #210	; 0xd2
    28e8:	0020      	movs	r0, r4
    28ea:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 280, 1, 280 , 90);
    28ec:	218c      	movs	r1, #140	; 0x8c
    28ee:	0049      	lsls	r1, r1, #1
    28f0:	9600      	str	r6, [sp, #0]
    28f2:	000b      	movs	r3, r1
    28f4:	2201      	movs	r2, #1
    28f6:	0020      	movs	r0, r4
    28f8:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 1, 90, 320 , 90);
    28fa:	9600      	str	r6, [sp, #0]
    28fc:	23a0      	movs	r3, #160	; 0xa0
    28fe:	005b      	lsls	r3, r3, #1
    2900:	225a      	movs	r2, #90	; 0x5a
    2902:	2101      	movs	r1, #1
    2904:	0020      	movs	r0, r4
    2906:	47a8      	blx	r5
	
	
	u8g2_SetFont(&lcd, u8g2_font_open_iconic_weather_6x_t);
    2908:	4961      	ldr	r1, [pc, #388]	; (2a90 <main+0x1fc>)
    290a:	0020      	movs	r0, r4
    290c:	4e61      	ldr	r6, [pc, #388]	; (2a94 <main+0x200>)
    290e:	47b0      	blx	r6
	u8g2_DrawGlyph(&lcd, 10, 51, 69);
    2910:	2345      	movs	r3, #69	; 0x45
    2912:	2233      	movs	r2, #51	; 0x33
    2914:	210a      	movs	r1, #10
    2916:	0020      	movs	r0, r4
    2918:	4d5f      	ldr	r5, [pc, #380]	; (2a98 <main+0x204>)
    291a:	47a8      	blx	r5
	u8g2_DrawGlyph(&lcd, 81, 51, 64);
    291c:	2340      	movs	r3, #64	; 0x40
    291e:	2233      	movs	r2, #51	; 0x33
    2920:	2151      	movs	r1, #81	; 0x51
    2922:	0020      	movs	r0, r4
    2924:	47a8      	blx	r5
	u8g2_DrawGlyph(&lcd, 151, 51, 65);
    2926:	2341      	movs	r3, #65	; 0x41
    2928:	2233      	movs	r2, #51	; 0x33
    292a:	2197      	movs	r1, #151	; 0x97
    292c:	0020      	movs	r0, r4
    292e:	47a8      	blx	r5
	u8g2_DrawGlyph(&lcd, 221, 51, 67);
    2930:	2343      	movs	r3, #67	; 0x43
    2932:	2233      	movs	r2, #51	; 0x33
    2934:	21dd      	movs	r1, #221	; 0xdd
    2936:	0020      	movs	r0, r4
    2938:	47a8      	blx	r5
	
	
	
	
	u8g2_SetFont(&lcd, u8g2_font_ncenB14_tr);
    293a:	4958      	ldr	r1, [pc, #352]	; (2a9c <main+0x208>)
    293c:	0020      	movs	r0, r4
    293e:	47b0      	blx	r6
	
	u8g2_DrawStr(&lcd, 10, 70, (void *)"+13°C");
    2940:	4b57      	ldr	r3, [pc, #348]	; (2aa0 <main+0x20c>)
    2942:	2246      	movs	r2, #70	; 0x46
    2944:	210a      	movs	r1, #10
    2946:	0020      	movs	r0, r4
    2948:	4d56      	ldr	r5, [pc, #344]	; (2aa4 <main+0x210>)
    294a:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10, 86, (void *)"734P");
    294c:	4b56      	ldr	r3, [pc, #344]	; (2aa8 <main+0x214>)
    294e:	2256      	movs	r2, #86	; 0x56
    2950:	210a      	movs	r1, #10
    2952:	0020      	movs	r0, r4
    2954:	47a8      	blx	r5
	
	u8g2_DrawStr(&lcd, 10+70, 70, (void *)"+16°C");
    2956:	4b55      	ldr	r3, [pc, #340]	; (2aac <main+0x218>)
    2958:	2246      	movs	r2, #70	; 0x46
    295a:	2150      	movs	r1, #80	; 0x50
    295c:	0020      	movs	r0, r4
    295e:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10+70, 86, (void *)"736P");
    2960:	4b53      	ldr	r3, [pc, #332]	; (2ab0 <main+0x21c>)
    2962:	2256      	movs	r2, #86	; 0x56
    2964:	2150      	movs	r1, #80	; 0x50
    2966:	0020      	movs	r0, r4
    2968:	47a8      	blx	r5
	
	u8g2_DrawStr(&lcd, 10+140, 70, (void *)"+14°C");
    296a:	4b52      	ldr	r3, [pc, #328]	; (2ab4 <main+0x220>)
    296c:	2246      	movs	r2, #70	; 0x46
    296e:	2196      	movs	r1, #150	; 0x96
    2970:	0020      	movs	r0, r4
    2972:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10+140, 86, (void *)"737P");
    2974:	4f50      	ldr	r7, [pc, #320]	; (2ab8 <main+0x224>)
    2976:	003b      	movs	r3, r7
    2978:	2256      	movs	r2, #86	; 0x56
    297a:	2196      	movs	r1, #150	; 0x96
    297c:	0020      	movs	r0, r4
    297e:	47a8      	blx	r5

	u8g2_DrawStr(&lcd, 10+210, 70, (void *)"+10°C");
    2980:	4b4e      	ldr	r3, [pc, #312]	; (2abc <main+0x228>)
    2982:	2246      	movs	r2, #70	; 0x46
    2984:	21dc      	movs	r1, #220	; 0xdc
    2986:	0020      	movs	r0, r4
    2988:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10+210, 86, (void *)"737P");
    298a:	003b      	movs	r3, r7
    298c:	2256      	movs	r2, #86	; 0x56
    298e:	21dc      	movs	r1, #220	; 0xdc
    2990:	0020      	movs	r0, r4
    2992:	47a8      	blx	r5
	
	u8g2_DrawStr(&lcd, 15, 110, (void *)"Thursday 25-04-2024");
    2994:	4b4a      	ldr	r3, [pc, #296]	; (2ac0 <main+0x22c>)
    2996:	226e      	movs	r2, #110	; 0x6e
    2998:	210f      	movs	r1, #15
    299a:	0020      	movs	r0, r4
    299c:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 15, 132, (void *)"Now 13.6C , 735mm, 63%");
    299e:	4b49      	ldr	r3, [pc, #292]	; (2ac4 <main+0x230>)
    29a0:	2284      	movs	r2, #132	; 0x84
    29a2:	210f      	movs	r1, #15
    29a4:	0020      	movs	r0, r4
    29a6:	47a8      	blx	r5
	
	u8g2_SetFont(&lcd, u8g2_font_5x8_tf);
    29a8:	4947      	ldr	r1, [pc, #284]	; (2ac8 <main+0x234>)
    29aa:	0020      	movs	r0, r4
    29ac:	47b0      	blx	r6
	u8g2_DrawStr(&lcd, 260, 134, (void *)"ID M430");
    29ae:	2682      	movs	r6, #130	; 0x82
    29b0:	0076      	lsls	r6, r6, #1
    29b2:	4b46      	ldr	r3, [pc, #280]	; (2acc <main+0x238>)
    29b4:	2286      	movs	r2, #134	; 0x86
    29b6:	0031      	movs	r1, r6
    29b8:	0020      	movs	r0, r4
    29ba:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 260, 142, (void *)"RF-79dB");
    29bc:	4b44      	ldr	r3, [pc, #272]	; (2ad0 <main+0x23c>)
    29be:	228e      	movs	r2, #142	; 0x8e
    29c0:	0031      	movs	r1, r6
    29c2:	0020      	movs	r0, r4
    29c4:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 260, 150, (void *)"B 3.94V");
    29c6:	4b43      	ldr	r3, [pc, #268]	; (2ad4 <main+0x240>)
    29c8:	2296      	movs	r2, #150	; 0x96
    29ca:	0031      	movs	r1, r6
    29cc:	0020      	movs	r0, r4
    29ce:	47a8      	blx	r5

	//u8g2_DrawRFrame(&lcd, 50 , 120, 20, 20, 3);
	//u8g2_DrawCircle(&lcd, 200, 120, 25, U8G2_DRAW_ALL);
	
	u8g2_SendBuffer(&lcd);
    29d0:	0020      	movs	r0, r4
    29d2:	4b41      	ldr	r3, [pc, #260]	; (2ad8 <main+0x244>)
    29d4:	4798      	blx	r3
	delay_ms(50);
    29d6:	2032      	movs	r0, #50	; 0x32
    29d8:	4b40      	ldr	r3, [pc, #256]	; (2adc <main+0x248>)
    29da:	4798      	blx	r3
	
	
	while(!gpio_get_pin_level(EP_BUSY)){
    29dc:	e007      	b.n	29ee <main+0x15a>
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    29de:	2280      	movs	r2, #128	; 0x80
    29e0:	02d2      	lsls	r2, r2, #11
    29e2:	23c0      	movs	r3, #192	; 0xc0
    29e4:	05db      	lsls	r3, r3, #23
    29e6:	61da      	str	r2, [r3, #28]
		gpio_toggle_pin_level(GLD);
		delay_ms(50);
    29e8:	2032      	movs	r0, #50	; 0x32
    29ea:	4b3c      	ldr	r3, [pc, #240]	; (2adc <main+0x248>)
    29ec:	4798      	blx	r3
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
    29ee:	a803      	add	r0, sp, #12
    29f0:	4b3b      	ldr	r3, [pc, #236]	; (2ae0 <main+0x24c>)
    29f2:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    29f4:	23c0      	movs	r3, #192	; 0xc0
    29f6:	05db      	lsls	r3, r3, #23
    29f8:	681c      	ldr	r4, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    29fa:	4a3a      	ldr	r2, [pc, #232]	; (2ae4 <main+0x250>)
    29fc:	6a12      	ldr	r2, [r2, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    29fe:	691b      	ldr	r3, [r3, #16]

	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT_IOBUS, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    2a00:	4053      	eors	r3, r2
    2a02:	401c      	ands	r4, r3
    2a04:	4054      	eors	r4, r2

	CRITICAL_SECTION_LEAVE();
    2a06:	a803      	add	r0, sp, #12
    2a08:	4b37      	ldr	r3, [pc, #220]	; (2ae8 <main+0x254>)
    2a0a:	4798      	blx	r3
	while(!gpio_get_pin_level(EP_BUSY)){
    2a0c:	03a3      	lsls	r3, r4, #14
    2a0e:	d5e6      	bpl.n	29de <main+0x14a>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    2a10:	23c0      	movs	r3, #192	; 0xc0
    2a12:	05db      	lsls	r3, r3, #23
    2a14:	2280      	movs	r2, #128	; 0x80
    2a16:	0112      	lsls	r2, r2, #4
    2a18:	615a      	str	r2, [r3, #20]
    2a1a:	2280      	movs	r2, #128	; 0x80
    2a1c:	0512      	lsls	r2, r2, #20
    2a1e:	615a      	str	r2, [r3, #20]
    2a20:	2280      	movs	r2, #128	; 0x80
    2a22:	02d2      	lsls	r2, r2, #11
    2a24:	615a      	str	r2, [r3, #20]
	
	
	//SPI0 - SERCOM0
	//I2C0 - SERCOM3
	while (1) {
		if(RTC_IRQ_Ready()){
    2a26:	4b31      	ldr	r3, [pc, #196]	; (2aec <main+0x258>)
    2a28:	4798      	blx	r3
    2a2a:	2800      	cmp	r0, #0
    2a2c:	d0fb      	beq.n	2a26 <main+0x192>
			rtc_sync(&sys_rtc);
    2a2e:	480e      	ldr	r0, [pc, #56]	; (2a68 <main+0x1d4>)
    2a30:	4b2f      	ldr	r3, [pc, #188]	; (2af0 <main+0x25c>)
    2a32:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    2a34:	24c0      	movs	r4, #192	; 0xc0
    2a36:	05e4      	lsls	r4, r4, #23
    2a38:	2580      	movs	r5, #128	; 0x80
    2a3a:	02ed      	lsls	r5, r5, #11
    2a3c:	61a5      	str	r5, [r4, #24]
			gpio_set_pin_level(GLD, true);
			delay_ms(1);
    2a3e:	2001      	movs	r0, #1
    2a40:	4b26      	ldr	r3, [pc, #152]	; (2adc <main+0x248>)
    2a42:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    2a44:	6165      	str	r5, [r4, #20]
			gpio_set_pin_level(GLD, false);
			
			
			SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;// | SCB_SCR_SLEEPONEXIT_Msk;  
    2a46:	4a2b      	ldr	r2, [pc, #172]	; (2af4 <main+0x260>)
    2a48:	6913      	ldr	r3, [r2, #16]
    2a4a:	2104      	movs	r1, #4
    2a4c:	430b      	orrs	r3, r1
    2a4e:	6113      	str	r3, [r2, #16]
			NVMCTRL->CTRLB.reg |= NVMCTRL_CTRLB_SLEEPPRM_DISABLED;        
    2a50:	4a29      	ldr	r2, [pc, #164]	; (2af8 <main+0x264>)
    2a52:	6851      	ldr	r1, [r2, #4]
    2a54:	23c0      	movs	r3, #192	; 0xc0
    2a56:	009b      	lsls	r3, r3, #2
    2a58:	430b      	orrs	r3, r1
    2a5a:	6053      	str	r3, [r2, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    2a5c:	f3bf 8f4f 	dsb	sy
			
			
			__DSB();
			__WFI();
    2a60:	bf30      	wfi
    2a62:	e7e0      	b.n	2a26 <main+0x192>
    2a64:	000015b1 	.word	0x000015b1
    2a68:	2000000c 	.word	0x2000000c
    2a6c:	00002839 	.word	0x00002839
    2a70:	00002765 	.word	0x00002765
    2a74:	00001661 	.word	0x00001661
    2a78:	2000172c 	.word	0x2000172c
    2a7c:	00003f88 	.word	0x00003f88
    2a80:	0000178d 	.word	0x0000178d
    2a84:	00002501 	.word	0x00002501
    2a88:	0000174d 	.word	0x0000174d
    2a8c:	00001ff9 	.word	0x00001ff9
    2a90:	00003d34 	.word	0x00003d34
    2a94:	00001e15 	.word	0x00001e15
    2a98:	00001ca9 	.word	0x00001ca9
    2a9c:	0000350c 	.word	0x0000350c
    2aa0:	00004024 	.word	0x00004024
    2aa4:	00001d95 	.word	0x00001d95
    2aa8:	0000402c 	.word	0x0000402c
    2aac:	00004034 	.word	0x00004034
    2ab0:	0000403c 	.word	0x0000403c
    2ab4:	00004044 	.word	0x00004044
    2ab8:	0000404c 	.word	0x0000404c
    2abc:	00004054 	.word	0x00004054
    2ac0:	0000405c 	.word	0x0000405c
    2ac4:	00004070 	.word	0x00004070
    2ac8:	00002e58 	.word	0x00002e58
    2acc:	00004088 	.word	0x00004088
    2ad0:	00004090 	.word	0x00004090
    2ad4:	00004098 	.word	0x00004098
    2ad8:	00001769 	.word	0x00001769
    2adc:	000001c1 	.word	0x000001c1
    2ae0:	00000191 	.word	0x00000191
    2ae4:	41004400 	.word	0x41004400
    2ae8:	0000019f 	.word	0x0000019f
    2aec:	000011cd 	.word	0x000011cd
    2af0:	000027c1 	.word	0x000027c1
    2af4:	e000ed00 	.word	0xe000ed00
    2af8:	41004000 	.word	0x41004000

00002afc <__udivsi3>:
    2afc:	2200      	movs	r2, #0
    2afe:	0843      	lsrs	r3, r0, #1
    2b00:	428b      	cmp	r3, r1
    2b02:	d374      	bcc.n	2bee <__udivsi3+0xf2>
    2b04:	0903      	lsrs	r3, r0, #4
    2b06:	428b      	cmp	r3, r1
    2b08:	d35f      	bcc.n	2bca <__udivsi3+0xce>
    2b0a:	0a03      	lsrs	r3, r0, #8
    2b0c:	428b      	cmp	r3, r1
    2b0e:	d344      	bcc.n	2b9a <__udivsi3+0x9e>
    2b10:	0b03      	lsrs	r3, r0, #12
    2b12:	428b      	cmp	r3, r1
    2b14:	d328      	bcc.n	2b68 <__udivsi3+0x6c>
    2b16:	0c03      	lsrs	r3, r0, #16
    2b18:	428b      	cmp	r3, r1
    2b1a:	d30d      	bcc.n	2b38 <__udivsi3+0x3c>
    2b1c:	22ff      	movs	r2, #255	; 0xff
    2b1e:	0209      	lsls	r1, r1, #8
    2b20:	ba12      	rev	r2, r2
    2b22:	0c03      	lsrs	r3, r0, #16
    2b24:	428b      	cmp	r3, r1
    2b26:	d302      	bcc.n	2b2e <__udivsi3+0x32>
    2b28:	1212      	asrs	r2, r2, #8
    2b2a:	0209      	lsls	r1, r1, #8
    2b2c:	d065      	beq.n	2bfa <__udivsi3+0xfe>
    2b2e:	0b03      	lsrs	r3, r0, #12
    2b30:	428b      	cmp	r3, r1
    2b32:	d319      	bcc.n	2b68 <__udivsi3+0x6c>
    2b34:	e000      	b.n	2b38 <__udivsi3+0x3c>
    2b36:	0a09      	lsrs	r1, r1, #8
    2b38:	0bc3      	lsrs	r3, r0, #15
    2b3a:	428b      	cmp	r3, r1
    2b3c:	d301      	bcc.n	2b42 <__udivsi3+0x46>
    2b3e:	03cb      	lsls	r3, r1, #15
    2b40:	1ac0      	subs	r0, r0, r3
    2b42:	4152      	adcs	r2, r2
    2b44:	0b83      	lsrs	r3, r0, #14
    2b46:	428b      	cmp	r3, r1
    2b48:	d301      	bcc.n	2b4e <__udivsi3+0x52>
    2b4a:	038b      	lsls	r3, r1, #14
    2b4c:	1ac0      	subs	r0, r0, r3
    2b4e:	4152      	adcs	r2, r2
    2b50:	0b43      	lsrs	r3, r0, #13
    2b52:	428b      	cmp	r3, r1
    2b54:	d301      	bcc.n	2b5a <__udivsi3+0x5e>
    2b56:	034b      	lsls	r3, r1, #13
    2b58:	1ac0      	subs	r0, r0, r3
    2b5a:	4152      	adcs	r2, r2
    2b5c:	0b03      	lsrs	r3, r0, #12
    2b5e:	428b      	cmp	r3, r1
    2b60:	d301      	bcc.n	2b66 <__udivsi3+0x6a>
    2b62:	030b      	lsls	r3, r1, #12
    2b64:	1ac0      	subs	r0, r0, r3
    2b66:	4152      	adcs	r2, r2
    2b68:	0ac3      	lsrs	r3, r0, #11
    2b6a:	428b      	cmp	r3, r1
    2b6c:	d301      	bcc.n	2b72 <__udivsi3+0x76>
    2b6e:	02cb      	lsls	r3, r1, #11
    2b70:	1ac0      	subs	r0, r0, r3
    2b72:	4152      	adcs	r2, r2
    2b74:	0a83      	lsrs	r3, r0, #10
    2b76:	428b      	cmp	r3, r1
    2b78:	d301      	bcc.n	2b7e <__udivsi3+0x82>
    2b7a:	028b      	lsls	r3, r1, #10
    2b7c:	1ac0      	subs	r0, r0, r3
    2b7e:	4152      	adcs	r2, r2
    2b80:	0a43      	lsrs	r3, r0, #9
    2b82:	428b      	cmp	r3, r1
    2b84:	d301      	bcc.n	2b8a <__udivsi3+0x8e>
    2b86:	024b      	lsls	r3, r1, #9
    2b88:	1ac0      	subs	r0, r0, r3
    2b8a:	4152      	adcs	r2, r2
    2b8c:	0a03      	lsrs	r3, r0, #8
    2b8e:	428b      	cmp	r3, r1
    2b90:	d301      	bcc.n	2b96 <__udivsi3+0x9a>
    2b92:	020b      	lsls	r3, r1, #8
    2b94:	1ac0      	subs	r0, r0, r3
    2b96:	4152      	adcs	r2, r2
    2b98:	d2cd      	bcs.n	2b36 <__udivsi3+0x3a>
    2b9a:	09c3      	lsrs	r3, r0, #7
    2b9c:	428b      	cmp	r3, r1
    2b9e:	d301      	bcc.n	2ba4 <__udivsi3+0xa8>
    2ba0:	01cb      	lsls	r3, r1, #7
    2ba2:	1ac0      	subs	r0, r0, r3
    2ba4:	4152      	adcs	r2, r2
    2ba6:	0983      	lsrs	r3, r0, #6
    2ba8:	428b      	cmp	r3, r1
    2baa:	d301      	bcc.n	2bb0 <__udivsi3+0xb4>
    2bac:	018b      	lsls	r3, r1, #6
    2bae:	1ac0      	subs	r0, r0, r3
    2bb0:	4152      	adcs	r2, r2
    2bb2:	0943      	lsrs	r3, r0, #5
    2bb4:	428b      	cmp	r3, r1
    2bb6:	d301      	bcc.n	2bbc <__udivsi3+0xc0>
    2bb8:	014b      	lsls	r3, r1, #5
    2bba:	1ac0      	subs	r0, r0, r3
    2bbc:	4152      	adcs	r2, r2
    2bbe:	0903      	lsrs	r3, r0, #4
    2bc0:	428b      	cmp	r3, r1
    2bc2:	d301      	bcc.n	2bc8 <__udivsi3+0xcc>
    2bc4:	010b      	lsls	r3, r1, #4
    2bc6:	1ac0      	subs	r0, r0, r3
    2bc8:	4152      	adcs	r2, r2
    2bca:	08c3      	lsrs	r3, r0, #3
    2bcc:	428b      	cmp	r3, r1
    2bce:	d301      	bcc.n	2bd4 <__udivsi3+0xd8>
    2bd0:	00cb      	lsls	r3, r1, #3
    2bd2:	1ac0      	subs	r0, r0, r3
    2bd4:	4152      	adcs	r2, r2
    2bd6:	0883      	lsrs	r3, r0, #2
    2bd8:	428b      	cmp	r3, r1
    2bda:	d301      	bcc.n	2be0 <__udivsi3+0xe4>
    2bdc:	008b      	lsls	r3, r1, #2
    2bde:	1ac0      	subs	r0, r0, r3
    2be0:	4152      	adcs	r2, r2
    2be2:	0843      	lsrs	r3, r0, #1
    2be4:	428b      	cmp	r3, r1
    2be6:	d301      	bcc.n	2bec <__udivsi3+0xf0>
    2be8:	004b      	lsls	r3, r1, #1
    2bea:	1ac0      	subs	r0, r0, r3
    2bec:	4152      	adcs	r2, r2
    2bee:	1a41      	subs	r1, r0, r1
    2bf0:	d200      	bcs.n	2bf4 <__udivsi3+0xf8>
    2bf2:	4601      	mov	r1, r0
    2bf4:	4152      	adcs	r2, r2
    2bf6:	4610      	mov	r0, r2
    2bf8:	4770      	bx	lr
    2bfa:	e7ff      	b.n	2bfc <__udivsi3+0x100>
    2bfc:	b501      	push	{r0, lr}
    2bfe:	2000      	movs	r0, #0
    2c00:	f000 f806 	bl	2c10 <__aeabi_idiv0>
    2c04:	bd02      	pop	{r1, pc}
    2c06:	46c0      	nop			; (mov r8, r8)

00002c08 <__aeabi_uidivmod>:
    2c08:	2900      	cmp	r1, #0
    2c0a:	d0f7      	beq.n	2bfc <__udivsi3+0x100>
    2c0c:	e776      	b.n	2afc <__udivsi3>
    2c0e:	4770      	bx	lr

00002c10 <__aeabi_idiv0>:
    2c10:	4770      	bx	lr
    2c12:	46c0      	nop			; (mov r8, r8)

00002c14 <__ffssi2>:
    2c14:	b510      	push	{r4, lr}
    2c16:	2300      	movs	r3, #0
    2c18:	2800      	cmp	r0, #0
    2c1a:	d002      	beq.n	2c22 <__ffssi2+0xe>
    2c1c:	f000 f804 	bl	2c28 <__ctzsi2>
    2c20:	1c43      	adds	r3, r0, #1
    2c22:	0018      	movs	r0, r3
    2c24:	bd10      	pop	{r4, pc}
    2c26:	46c0      	nop			; (mov r8, r8)

00002c28 <__ctzsi2>:
    2c28:	4241      	negs	r1, r0
    2c2a:	4008      	ands	r0, r1
    2c2c:	211c      	movs	r1, #28
    2c2e:	2301      	movs	r3, #1
    2c30:	041b      	lsls	r3, r3, #16
    2c32:	4298      	cmp	r0, r3
    2c34:	d301      	bcc.n	2c3a <__ctzsi2+0x12>
    2c36:	0c00      	lsrs	r0, r0, #16
    2c38:	3910      	subs	r1, #16
    2c3a:	0a1b      	lsrs	r3, r3, #8
    2c3c:	4298      	cmp	r0, r3
    2c3e:	d301      	bcc.n	2c44 <__ctzsi2+0x1c>
    2c40:	0a00      	lsrs	r0, r0, #8
    2c42:	3908      	subs	r1, #8
    2c44:	091b      	lsrs	r3, r3, #4
    2c46:	4298      	cmp	r0, r3
    2c48:	d301      	bcc.n	2c4e <__ctzsi2+0x26>
    2c4a:	0900      	lsrs	r0, r0, #4
    2c4c:	3904      	subs	r1, #4
    2c4e:	a202      	add	r2, pc, #8	; (adr r2, 2c58 <__ctzsi2+0x30>)
    2c50:	5c10      	ldrb	r0, [r2, r0]
    2c52:	1a40      	subs	r0, r0, r1
    2c54:	4770      	bx	lr
    2c56:	46c0      	nop			; (mov r8, r8)
    2c58:	1d1d1c1b 	.word	0x1d1d1c1b
    2c5c:	1e1e1e1e 	.word	0x1e1e1e1e
    2c60:	1f1f1f1f 	.word	0x1f1f1f1f
    2c64:	1f1f1f1f 	.word	0x1f1f1f1f

00002c68 <__libc_init_array>:
    2c68:	b570      	push	{r4, r5, r6, lr}
    2c6a:	2600      	movs	r6, #0
    2c6c:	4d0c      	ldr	r5, [pc, #48]	; (2ca0 <__libc_init_array+0x38>)
    2c6e:	4c0d      	ldr	r4, [pc, #52]	; (2ca4 <__libc_init_array+0x3c>)
    2c70:	1b64      	subs	r4, r4, r5
    2c72:	10a4      	asrs	r4, r4, #2
    2c74:	42a6      	cmp	r6, r4
    2c76:	d109      	bne.n	2c8c <__libc_init_array+0x24>
    2c78:	2600      	movs	r6, #0
    2c7a:	f001 fa11 	bl	40a0 <_init>
    2c7e:	4d0a      	ldr	r5, [pc, #40]	; (2ca8 <__libc_init_array+0x40>)
    2c80:	4c0a      	ldr	r4, [pc, #40]	; (2cac <__libc_init_array+0x44>)
    2c82:	1b64      	subs	r4, r4, r5
    2c84:	10a4      	asrs	r4, r4, #2
    2c86:	42a6      	cmp	r6, r4
    2c88:	d105      	bne.n	2c96 <__libc_init_array+0x2e>
    2c8a:	bd70      	pop	{r4, r5, r6, pc}
    2c8c:	00b3      	lsls	r3, r6, #2
    2c8e:	58eb      	ldr	r3, [r5, r3]
    2c90:	4798      	blx	r3
    2c92:	3601      	adds	r6, #1
    2c94:	e7ee      	b.n	2c74 <__libc_init_array+0xc>
    2c96:	00b3      	lsls	r3, r6, #2
    2c98:	58eb      	ldr	r3, [r5, r3]
    2c9a:	4798      	blx	r3
    2c9c:	3601      	adds	r6, #1
    2c9e:	e7f2      	b.n	2c86 <__libc_init_array+0x1e>
    2ca0:	000040ac 	.word	0x000040ac
    2ca4:	000040ac 	.word	0x000040ac
    2ca8:	000040ac 	.word	0x000040ac
    2cac:	000040b0 	.word	0x000040b0

00002cb0 <memset>:
    2cb0:	0003      	movs	r3, r0
    2cb2:	1882      	adds	r2, r0, r2
    2cb4:	4293      	cmp	r3, r2
    2cb6:	d100      	bne.n	2cba <memset+0xa>
    2cb8:	4770      	bx	lr
    2cba:	7019      	strb	r1, [r3, #0]
    2cbc:	3301      	adds	r3, #1
    2cbe:	e7f9      	b.n	2cb4 <memset+0x4>
    2cc0:	682f2e2e 	.word	0x682f2e2e
    2cc4:	732f6c61 	.word	0x732f6c61
    2cc8:	682f6372 	.word	0x682f6372
    2ccc:	695f6c61 	.word	0x695f6c61
    2cd0:	6d5f6332 	.word	0x6d5f6332
    2cd4:	6e79735f 	.word	0x6e79735f
    2cd8:	00632e63 	.word	0x00632e63
    2cdc:	682f2e2e 	.word	0x682f2e2e
    2ce0:	732f6c61 	.word	0x732f6c61
    2ce4:	682f6372 	.word	0x682f6372
    2ce8:	695f6c61 	.word	0x695f6c61
    2cec:	00632e6f 	.word	0x00632e6f
    2cf0:	682f2e2e 	.word	0x682f2e2e
    2cf4:	732f6c61 	.word	0x732f6c61
    2cf8:	682f6372 	.word	0x682f6372
    2cfc:	735f6c61 	.word	0x735f6c61
    2d00:	6d5f6970 	.word	0x6d5f6970
    2d04:	6e79735f 	.word	0x6e79735f
    2d08:	00632e63 	.word	0x00632e63
    2d0c:	682f2e2e 	.word	0x682f2e2e
    2d10:	652f6c70 	.word	0x652f6c70
    2d14:	682f6369 	.word	0x682f6369
    2d18:	655f6c70 	.word	0x655f6c70
    2d1c:	632e6369 	.word	0x632e6369
    2d20:	00000000 	.word	0x00000000

00002d24 <_map>:
    2d24:	00000007 00000007 0000000d 00000019     ................
    2d34:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    2d44:	65735f6c 6d6f6372 0000632e              l_sercom.c..

00002d50 <_i2cms>:
    2d50:	00000003 00200014 00000100 000000ea     ...... .........
    2d60:	000000d7 02dc6c00                       .....l..

00002d68 <sercomspi_regs>:
    2d68:	0020000c 00020000 00000000 000000fe     .. .............
    2d78:	0000169c 00001672 00001672 00001690     ....r...r.......
    2d88:	000016b4 000016be 00001672 00001672     ........r...r...
    2d98:	00001672 00001672 00001672 00001672     r...r...r...r...
    2da8:	000016a6 00001672 00001672 00001672     ....r...r...r...
    2db8:	00001672 00001672 00001672 00001672     r...r...r...r...
    2dc8:	000016ce 00001686 00001672 00001672     ........r...r...
    2dd8:	00001672 00001672 00001672 00001672     r...r...r...r...
    2de8:	00001672 00001672 00001672 00001672     r...r...r...r...
    2df8:	00001672 00001672 00001672 00001672     r...r...r...r...
    2e08:	00001672 00001672 00001672 00001672     r...r...r...r...
    2e18:	00001672 00001672 00001672 00001672     r...r...r...r...
    2e28:	00001672 00001672 00001672 00001672     r...r...r...r...
    2e38:	00001672 00001672 00001672 00001672     r...r...r...r...
    2e48:	00001672 00001672 00001672 00001676     r...r...r...v...

00002e58 <u8g2_font_5x8_tf>:
    2e58:	020200bf 04030403 00080504 06ff06ff     ................
    2e68:	021a0100 20960631 037e0005 63310721     ....1.. ..~.!.1c
    2e78:	22005233 936e9b07 0d2300ac a657623d     3R."..n...#.=bW.
    2e88:	54355434 24001299 9b623d0a da53bd57     4T5T...$.=b.W.S.
    2e98:	ab082511 67531366 3c0a2600 b3531762     .%..f.Sg.&.<b.S.
    2ea8:	2700a66a 336f1905 62b20728 29019aa7     j..'..o3(..b...)
    2eb8:	1362b208 2a00a553 13622c0a c5491a93     ..b.S..*.,b...I.
    2ec8:	2d0a2b00 1c519b62 2c08a332 a75e9b07     .+.-b.Q.2..,..^.
    2ed8:	062d004a 02336a0c 5e9b072e 2f025697     J.-..j3....^.V./
    2ee8:	5f623408 300033b6 5762b308 31002ab9     .4b_.3.0..bW.*.1
    2ef8:	9762b307 0a326b64 62a76234 008f2a4e     ..b.dk2.4b.bN*..
    2f08:	62340a33 48d46233 0a340526 551b6234     3.4b3b.H&.4.4b.U
    2f18:	004e6235 62340a35 3246f433 0a360029     5bN.5.4b3.F2).6.
    2f28:	f2a76234 0029328a 62340a37 31cc7233     4b...2).7.4b3r.1
    2f38:	0a380047 62a76234 05265152 62340a39     G.8.4b.bRQ&.9.4b
    2f48:	3b4ca2a7 073a0029 e23362aa b3083b08     ..L;).:..b3..;..
    2f58:	5523675e b3073c02 5cca9b62 661c083d     ^g#U.<..b..\=..f
    2f68:	011a3233 62b3083e 0254cb93 62b3093f     32..>..b..T.?..b
    2f78:	26194cd7 450c4000 5ca32b5e 43592549     .L.&.@.E^+.\I%YC
    2f88:	34094105 1ca2a762 0a420653 e2b36234     .A.4b...S.B.4b..
    2f98:	048e5148 62340943 932ea2a7 34094402     HQ..C.4b.....D.4
    2fa8:	73a2b362 09450024 f4336234 460479ca     b..s$.E.4b3..y.F
    2fb8:	33623409 0035caf4 62340a47 334ea2a7     .4b3..5.G.4b..N3
    2fc8:	09480029 e5136234 49006698 b362b307     ).H.4b...f.I..b.
    2fd8:	094a6b62 73376234 4b004655 13623409     bkJ.4b7sUF.K.4b.
    2fe8:	33a99255 6234084c 0047bb93 6234094d     U..3L.4b..G.M.4b
    2ff8:	cd11c713 34094e00 58d71362 094f0067     .....N.4b..Xg.O.
    3008:	a2a76234 50002933 b362340a 67291ca2     4b..3).P.4b...)g
    3018:	3c095100 5ca2a75e 0a52146e a2b36234     .Q.<^..\n.R.4b..
    3028:	00ca291c 62340a53 a8ca62a7 08540a4c     .)..S.4b.b..L.T.
    3038:	62b362b3 08550017 3d136234 09560293     .b.b..U.4b.=..V.
    3048:	9d136234 57002a49 13623409 00c471cd     4b..I*.W.4b..q..
    3058:	62340a58 2a926513 0b5900ca 75936235     X.4b.e.*..Y.5b.u
    3068:	28ca33aa 34095a02 6c723362 075b008f     .3.(.Z.4b3rl..[.
    3078:	623362b3 340a5c73 ca339362 5d1ca328     .b3bs\.4b.3.(..]
    3088:	3362b307 065e239b 00d77293 5e0c065f     ..b3.#^..r.._..^
    3098:	06600233 03137292 62240861 034ca237     3.`..r..a.$b7.L.
    30a8:	62340a62 728af393 07630024 b33762a3     b.4b...r$.c..b7.
    30b8:	34096400 288d5f62 086500d3 d2a76224     .d.4b_.(..e.$b..
    30c8:	09660ac8 955b6234 67004733 a75e2c09     ..f.4b[.3G.g.,^.
    30d8:	0149da62 62340968 668af393 b3086900     b.I.h.4b...f.i..
    30e8:	ac919762 bb096a06 a9619b5e 096b002a     b....j..^.a.*.k.
    30f8:	cb936234 6c0ca291 2362b307 096d06bb     4b.....l..b#..m.
    3108:	5aa36225 6e02a92a b3622407 086f19a2     %b.Z*..n.$b...o.
    3118:	a2a76224 09700a4c e2b35e2c 71033948     $b..L.p.,^..H9.q
    3128:	375e2c08 7205da62 93622408 73019d92     .,^7b..r.$b....s
    3138:	3762a307 0a7402f2 e3976234 002629cc     ..b7..t.4b...)&.
    3148:	62240775 7634cd13 9362a307 09770aac     u.$b..4v..b...w.
    3158:	55936225 78005d52 13622408 79315493     %b.UR].x.$b..T1y
    3168:	135e2c0a 29311a65 24087a00 39623362     .,^.e.1).z.$b3b9
    3178:	3c0b7b02 4a32ab62 048cc51a 6331057c     .{.<b.2J....|.1c
    3188:	3c0c7d73 cc51a362 24946548 14077e00     s}.<b.Q.He.$.~..
    3198:	02549772 7e0005a0 3107a103 00469363     r.T....~...1c.F.
    31a8:	5e3409a2 ce6a471b 340aa304 988d5b62     ..4^.Gj....4b[..
    31b8:	a4004a93 93622d0a e5714cd3 350ba500     .J...-b..Lq....5
    31c8:	35539362 02321c64 633906a6 0aa706b3     b.S5d.2...9c....
    31d8:	f237623c 048f698a 768b06a8 0aa90293     <b7..i.....v....
    31e8:	aab76235 00b55539 6aab07aa ab1e92b7     5b..9U.....j....
    31f8:	97661c08 ac014c54 33629b06 8b05ad0b     ..f.TL....b3....
    3208:	09ae336a a1f76235 af005a96 33768b05     j3..5b...Z....v3
    3218:	6e9b06b0 08b105d7 569762ab 07b20346     ...n.....b.VF...
    3228:	4cd76aab ab07b369 002fa36a 729206b4     .j.Li...j./....r
    3238:	09b500a7 cd135e2c b6003291 3762350c     ....,^...2...5b7
    3248:	a9291a46 b70a6298 136b0905 5e9206b8     F.)..b....k....^
    3258:	07b900a7 64976aab ab07ba35 068dd76a     .....j.d5...j...
    3268:	661c08bb 09526293 623c0abc 8d515b93     ...f.bR...<b.[Q.
    3278:	0abd0098 ab93623c 038c72a4 623c0cbe     ....<b...r....<b
    3288:	48cc5193 00262355 62b309bf a98a6197     .Q.HU#&....b.a..
    3298:	3c0ac002 54519762 c1194c71 5b623c09     ...<b.QTqL...<b[
    32a8:	0ca638ab 623c0ac2 715262a7 0ac3194c     .8....<b.bRqL...
    32b8:	5497623c 194c7154 623c0ac4 71543313     <b.TTqL...<b.3Tq
    32c8:	0ac5194c 62a7623c 194c7152 623409c6     L...<b.bRqL...4b
    32d8:	a86b5237 3c0ac74a 2ea2a75e c8008c93     7Rk.J..<^.......
    32e8:	97623c0a e57a1a51 3c09c911 bd0e5b62     .<b.Q.z....<b[..
    32f8:	0aca08f2 e2a7623c 008f2bd8 623c0acb     ....<b...+....<b
    3308:	7a1a3313 09cc11e5 d39362bb cd00d58a     .3.z.....b......
    3318:	9b62bb09 00d58ad2 62bb09ce ab148d57     ..b........bW...
    3328:	bb09cf01 8af29362 0bd000d5 e3376235     ....b.......5b7.
    3338:	698a6548 3c0ad101 b9549762 d20194d4     He.i...<b.T.....
    3348:	97623c0a 4cd15451 3c09d30a 68ab5b62     .<b.QT.L...<b[.h
    3358:	0ad40526 62a7623c 0a4cd152 623c0ad5     &...<b.bR.L...<b
    3368:	d1545497 0ad60a4c 3313623c 0a4cd154     .TT.L...<b.3T.L.
    3378:	629b06d7 09d83a93 d2376234 d9048e91     ...b.:..4b7.....
    3388:	97623c09 0a4ce951 623c08da 052674db     .<b.Q.L...<b.t&.
    3398:	623c09db 5267a2a7 3c0adc00 8a331362     ..<b..gR...<b.3.
    33a8:	dd00a4ce 5f623d0b 946754e6 0ade0451     .....=b_.Tg.Q...
    33b8:	57936234 00652394 623409df 54eaa2a7     4b.W.#e...4b...T
    33c8:	3c0ae009 c6519762 e134ca23 5b623c09     ...<b.Q.#.4..<b[
    33d8:	34ca2353 623c0ae2 a238655b 0ae3034c     S#.4..<b[e8.L...
    33e8:	5497623c 34ca23c6 623409e4 6511c357     <b.T.#.4..4bW..e
    33f8:	3c0ae51a 9262a762 e634ca23 33622509     ...<b.b.#.4..%b3
    3408:	004732a2 5eab08e7 004ab337 623c0be8     .2G....^7.J...<b
    3418:	2ac65197 e900ac8d 5b623c0a ac8d2a53     .Q.*.....<b[S*..
    3428:	3c0bea00 8662a762 00ac8d2a 62340aeb     ...<b.b.*.....4b
    3438:	46954357 09ec0056 339362bb ed00d592     WC.FV....b.3....
    3448:	9b62bb09 00d59232 62bb08ee 00d596d7     ..b.2......b....
    3458:	62b308ef 06acb293 623c0cf0 51956293     ...b......<b.b.Q
    3468:	0029311a 623c0af1 2b865497 0bf2019a     .1)...<b.T.+....
    3478:	5197623c a4ca2ac6 3c0af300 2a535b62     <b.Q.*.....<b[S*
    3488:	f400a4ca a7623c0b ca2a8662 0bf500a4     .....<b.b.*.....
    3498:	5497623c a4ca2ac6 340af600 54331362     <b.T.*.....4b.3T
    34a8:	f7052651 9762ab08 f80946d1 37622409     Q&....b..F...$b7
    34b8:	012348d2 623c0af9 d1865197 09fa034c     .H#...<b.Q..L...
    34c8:	e35b623c fb01a668 a7623c0a 4cd14662     <b[.h....<b.bF.L
    34d8:	3409fc03 8a331362 0bfd1a66 e35b5e44     ...4b.3.f...D^[.
    34e8:	4988d328 3c0afe01 8af3935e ff0ce523     (..I...<^...#...
    34f8:	135e3c0c 8d328a33 00001498 ff040000     .<^.3.2.........
    3508:	000000ff                                ....

0000350c <u8g2_font_ncenB14_tr>:
    350c:	0303005f 05040505 fd141606 0efc0efc     _...............
    351c:	056d02fe 200b08ba 2c600006 c40f2101     ..m.... ..`,.!..
    352c:	39233425 65222c1c 012221c9 64a50922     %4#9.,"e.!"."..d
    353c:	45e12146 8b1b2300 11296461 d912c44b     F!.E.#..ad).K...
    354c:	49987261 61d912c4 c4499872 0844b112     ar.I...ar.I...D.
    355c:	a6492124 8487195b 2948926b 82550a52     $!I.[...k.H)R.U.
    356c:	10e843b6 a14a4633 9112a84a 2090e395     .C..3FJ.J...... 
    357c:	ee292500 93357be1 5941268a 450b2848     .%)..{5..&AYH(.E
    358c:	28a91165 c687247d 345122c6 648a0b24     e..(}$..."Q4$..d
    359c:	a62c98c1 e34e8c14 24260030 4b8c25d0     ..,...N.0.&$.%.K
    35ac:	20e48a07 93241c99 58722683 d9ab3a1d     ... ..$..&rX.:..
    35bc:	70521384 a7521d56 7421dab4 0727011b     ..RpV.R...!t..'.
    35cc:	712e64a2 05112818 122733a2 9923448d     .d.q.(...3'..D#.
    35dc:	99b266de 10290050 2133a205 3364cd94     .f..P.)...3!..d3
    35ec:	46891a7d 102a006a 3545e0e7 44449a4a     }..Fj.*...E5J.DD
    35fc:	94644923 152b0234 295c214a 7221c887     #Id.4.+.J!\)..!r
    360c:	3070f088 887221ca 2c04221c 2b60e40b     ..p0.!r..".,..`+
    361c:	46443923 072d00d9 f134e065 840a2e10     #9DF..-.e.4.....
    362c:	39232c20 2f002444 3c21c60f 0c5418a9      ,#9D$./..!<..T.
    363c:	8315062a 1330008a 375c25c9 92648c9c     *.....0..%\7..d.
    364c:	c89b7f99 0ce19344 c70b3100 1c275c29     ....D....1..)\'.
    365c:	0e9ff715 25c91532 4d13475c 6c89b666     ....2..%\G.Mf..l
    366c:	a74f1d3c a1c3d562 c9173300 13475c25     <.O.b....3..%\G.
    367c:	89b6664d 839c2c6c db9913e4 012b3444     Mf..l,......D4+.
    368c:	25c91634 4f171f5c d0b32319 4d8a3628     4..%\..O.#..(6.M
    369c:	74839382 18352d3c 735c25c9 90e29c88     ...t<-5..%\s....
    36ac:	b10e2438 89e3e6c5 9a226dcc 16360095     8$.......m"...6.
    36bc:	575c25c9 24d9915a b288c9e3 9b226de6     .%\WZ..$.....m".
    36cc:	0033848c 25c91137 9e50f15c b962e58a     ..3.7..%\.P...b.
    36dc:	11bc7578 c9153800 94375c25 e2d4a449     xu...8..%\7.I...
    36ec:	85346445 4d6a558e 17390346 375c25c9     Ed4..UjMF.9..%\7
    36fc:	92664d14 84c9b799 644f1934 5468c936     .Mf.....4.Od6.hT
    370c:	240d3a03 39233425 4392c444 0f3b0244     .:.$%4#9D..CD.;.
    371c:	23336584 92c44439 0d946443 4a113c00     .e3#9D..Cd...<.J
    372c:	110f5c21 21d33913 421d0874 0b3d0887     !\...9.!t..B..=.
    373c:	f15ca4c9 1c3c4740 4a123e08 87215c21     ..\.@G<..>.J!\!.
    374c:	087421d0 7226421d 3f004396 5421c912     .!t..B&r.C.?..!T
    375c:	6cdd1257 7758d913 2c953124 cf274004     W..l..Xw$1.,.@'.
    376c:	1e7b8421 90a0e4cb 291124ac 92226491     !.{......$.).d".
    377c:	8991444c 89226a24 9a2444d2 d8a0e510     LD..$j"..D$.....
    378c:	02087c58 1dce2041 cb071f74 1d207381     X|..A ..t....s .
    379c:	42839914 1e6c4872 07a7471b 1f187861     ...BrHl..G..ax..
    37ac:	02d427c9 21cc1e42 cd987174 70d1c348     .'..B..!tq..H..p
    37bc:	66cd1c34 74d2e087 274c9d32 7270c9d3     4..f...t2.L'..pr
    37cc:	1d430190 597421cc 258cb10a 0e843ae3     ..C..!tY...%.:..
    37dc:	a0e683a1 890e6839 18e323cc 44035a4d     ....9h...#..MZ.D
    37ec:	8421ce1f 690e9871 3478d1e3 f327cc9f     ..!.q..i..x4..'.
    37fc:	9f327cc9 d1e327cc 1d243478 1f450086     .|2..'..x4$...E.
    380c:	716c21cb 53270ca0 99142cc9 e1232285     .!lq..'S.,..."#.
    381c:	059c2471 38c8a167 0f0c9532 cb1e4607     q$..g..82....F..
    382c:	a0716c21 c953270c 8599142c 71e12322     !lq..'S.,..."#.q
    383c:	67059c24 0e6439c1 47015b99 7c21cd21     $..g.9d..[.G!.!|
    384c:	48918a59 3258d163 90e64487 87361cc8     Y..Hc.X2.D....6.
    385c:	d1e10f4d 919d3474 0008a5a8 21ce1e48     M...t4......H..!
    386c:	8cac5184 78d1e347 478d1e34 3478d287     .Q..G..x4..G..x4
    387c:	e3478d1e 9e3478d1 0a490b14 514c25c5     ..G..x4...I..%LQ
    388c:	297fed19 1dca134a ef9e5b64 9a426c93     ...)J...d[...lB.
    389c:	91c22690 4b044868 8421ce1e 854d2b51     .&..hH.K..!.Q+M.
    38ac:	3c4ce943 10e44f92 213ee43b e233a88f     C.L<.O..;.>!..3.
    38bc:	d4a53690 ca104c0c 9e516421 6991afef     .6...L..!dQ....i
    38cc:	1d992864 d12d4d0c 2e619c21 5a556991     d(...M-.!.a..iUZ
    38dc:	85991864 68599166 46859916 126c59a1     d...f.Yh...F.Yl.
    38ec:	a126c59a 0b368c59 d9c166ce d49c1868     ..&.Y.6..f..h...
    38fc:	214e0562 418421ce d46750ad 4c583520     b.N!.!.A.Pg. 5XL
    390c:	a44305a1 0c128c60 28c4a316 8b1b3c31     ..C.`......(1<..
    391c:	4f0021ca 8421ce1d c6d12669 0e64f1a3     .!.O..!.i&....d.
    392c:	10ec43b1 b10ec43b e3479643 046c8919     .C..;...C.G...l.
    393c:	21cc1e50 ce107174 90ca4348 290ca432     P..!tq..HC..2..)
    394c:	3821d233 7341cd07 87341cd0 285101d4     3.!8..As..4...Q(
    395c:	6983224e a3c6d126 b10e64f1 3b10ec43     N".i&....d..C..;
    396c:	d0b10ec4 6891a326 ca519926 3a1ca876     ....&..h&.Q.v..:
    397c:	b0ea8389 1f520011 718421cd d3490da0     ......R..!.q..I.
    398c:	1d3474d1 e887670d ce1b386c 70d9c368     .t4..g..l8..h..p
    399c:	27189c36 ca165300 09476421 d3250cad     6..'.S..!dG...%.
    39ac:	357ad908 d3d5cb5b 54025424 6c21cb1c     ..z5[...$T.T..!l
    39bc:	cdad3071 2cd93364 21cc8738 321cc873     q0..d3.,8..!s..2
    39cc:	7321cc87 5506bcc8 8421ce1e 478cac51     ..!s...U..!.Q..G
    39dc:	363cd8f3 f363cd8f 8f363cd8 d8f363cd     ..<6..c..<6..c..
    39ec:	1b94383c cf225601 ac61741d 20f36790     <8...V"..ta..g. 
    39fc:	4f0d3c35 6438b3e3 e24d0716 381c49b0     5<.O..8d..M..I.8
    3a0c:	71c1ce87 57001c78 9c1dd430 68553161     ...qx..W0...a1Uh
    3a1c:	1a70d9c4 33c2d1a4 0b46785a 38942253     ..p....3ZxF.S".8
    3a2c:	c49a1264 24d09321 61d1a10e 386c39c3     d...!..$...a.9l8
    3a3c:	d0e38607 58001870 8c21cf1f a711aa63     ....p..X..!.c...
    3a4c:	0e48f934 50e8c3b1 b30eac3a e1644443     4.H....P:...CDd.
    3a5c:	531b4874 1f59068a 617c21cd d36550a3     tH.S..Y..!|a.Pe.
    3a6c:	0b3a4d20 3a90e253 c39b0e68 6c39b0e6      M:.S..:h.....9l
    3a7c:	6e439b0e cc195a00 10f16c21 94c24f2e     ..Cn.Z..!l...O..
    3a8c:	990e9d28 11ace843 3e5c6472 0a5b021c     (...C...rd\>..[.
    3a9c:	6133a604 0113ffd2 21c8125c 8b96214c     ..3a....\..!L!..
    3aac:	58b962e5 e58b962e 0a5d0162 4133a204     .b.X....b.]...3A
    3abc:	0193ffd2 a1080e5e 1296274d 422d2269     ....^...M'..i"-B
    3acc:	075f00a2 f14b6049 85086040 5b213ea4     .._.I`K.@`...>![
    3adc:	2a126114 9a735c21 da63844d 9b326d64     .a.*!\s.M.c.dm2.
    3aec:	6206988c 641dcc1f 41cd0741 341cd073     ...b...dA..As..4
    3afc:	b4884d07 9d3274d1 c9d3274c 491b4274     .M...t2.L'..tB.I
    3b0c:	0f63006a 57542129 5bcb191a 09193323     j.c.)!TW...[#3..
    3b1c:	cc1d6400 074f6c21 d07341cd 8ca4341c     .d..!lO..As..4..
    3b2c:	64e99466 a64e993a 4668e993 126510a4     f..d:.N...hF..e.
    3b3c:	475c212a c6864d1c 8e3e41c3 0025650c     *!\G.M...A>..e%.
    3b4c:	21c80e66 ec93473c f74db43a 1e6706b1     f..!<G..:.M...g.
    3b5c:	0f5b21eb c6464392 13284cd1 a34346ca     .![..CF..L(..FC.
    3b6c:	1e08741c 5889d222 00dd9432 21cc1e68     .t.."..X2...h..!
    3b7c:	cd07416c 1cd07341 6a4d0734 3470d224     lA..As..4.Mj$.p4
    3b8c:	c3470d1c 9c3470d1 0c690a94 333421c5     ..G..p4...i..!43
    3b9c:	f692075a 0f6a014b b9331647 3fb88d1d     Z...K.j.G.3....?
    3bac:	12222c5a cc1d6b00 07416c21 d07341cd     Z,"..k..!lA..As.
    3bbc:	8d07341c 28e1334a 275f113c 466d11c4     .4..J3.(<._'..mF
    3bcc:	0a6c18a9 413421c5 00a5ffda 2133186d     ..l..!4A....m.3!
    3bdc:	d8a941a4 70d22548 5c34b869 970d2e1a     .A..H%.pi.4\....
    3bec:	06a52b86 212c156e 91a9416c 70d1c348     .+..n.,!lA..H..p
    3bfc:	470d1c34 5270d1c3 2b0f6f2a 9c576421     4..G..pR*o.+!dW.
    3c0c:	4ebea64d 001ac366 1dac1c70 d2223163     M..Nf...p...c1".
    3c1c:	74c9d346 274c9d32 346d09d3 7341ce21     F..t2.L'..m4!.As
    3c2c:	07521cd0 21ac1c71 cd124763 74c9d328     ..R.q..!cG..(..t
    3c3c:	274c9d32 488cd1d3 a0e68399 290e6839     2.L'...H....9h.)
    3c4c:	21280f72 5111414c 74c92324 73001ac7     r.(!LA.Q$#.t...s
    3c5c:	54212912 24c90945 6af188c3 25224a2d     .)!TE..$...j-J"%
    3c6c:	a7117400 8e174421 e1a6670a 10a3229e     .t..!D...g..."..
    3c7c:	15750005 516c212c c3470d22 1c3470d1     ..u.,!lQ".G..p4.
    3c8c:	11c3470d 7600855b 4c1d2a14 430c9a51     .G..[..v.*.LQ..C
    3c9c:	3828d8c3 72e9928a 77001088 7c1d301b     ..(8...r...w.0.|
    3cac:	664d2951 186cd0c3 2382911b 26449452     Q)Mf..l....#R.D&
    3cbc:	887285d1 12780850 6164212b a4519361     ..r.P.x.+!daa.Q.
    3ccc:	425579f5 06285193 21ab1b79 4c9b5163     .yUB.Q(.y..!cQ.L
    3cdc:	2cd8d343 c24e8b38 321cf893 d1654507     C..,8.N....2.Ee.
    3cec:	7a0e7c49 5421290e 88d5a071 03c48adc     I|.z.)!Tq.......
    3cfc:	050e7b01 122733a2 1b28a4ed 7c1426ed     .{...3'...(..&.|
    3d0c:	5c31c207 0f7d03f1 2133a205 09b68d94     ..1\..}...3!....
    3d1c:	a93da245 6a0b7e01 72b56524 00468c88     E.=..~.j$e.r..F.
    3d2c:	04000000 0000ffff                       ........

00003d34 <u8g2_font_open_iconic_weather_6x_t>:
    3d34:	06060006 04020606 00303007 30003000     .........00..0.0
    3d44:	003f0000 40360200 c3a9303f 10d9442f     ..?...6@?0../D..
    3d54:	b3651e21 732b9864 c54daa69 e7933a99     !.e.d.+si.M..:..
    3d64:	a5a43109 139298a4 06543a82 2e09688b     .1.......:T..h..
    3d74:	82bc15e1 2403f01f 45a13bc1 81d50ab0     .......$.;.E....
    3d84:	c84d4c4a 5f410000 17c22c30 2110d944     JLM...A_0,..D..!
    3d94:	64b3651e 45c26c18 10e8083c 82c6469b     .e.d.l.E<....F..
    3da4:	e3491688 26902451 c4965081 07105161     ..I.Q$.&.P..aQ..
    3db4:	191c3926 12689085 38a9b281 3cf26753     &9....h....8Sg.<
    3dc4:	94b48621 42725314 60ca8750 25c12d11     !....SrBP..`.-.%
    3dd4:	f05782bc 24807e03 08b42778 503aa156     ..W..~.$x'..V.:P
    3de4:	1909a989 ee514200 c09fc26b 680b483a     .....BQ.k...:H.h
    3df4:	88983ce1 8d2a4132 6c29910b e9ef8e84     .<..2A*...)l....
    3e04:	4e907883 c9b849c2 5a28d936 9760b325     .x.N.I..6.(Z%.`.
    3e14:	2c65630b 3e91c50d 0820c890 a84541ac     .ce,...>.. ..AE.
    3e24:	3a81940a 1169094c 23c7a035 460c2a69     ...:L.i.5..#i*.F
    3e34:	61a41ce9 7e430002 2fc22c30 2108e944     ...a..C~0,./D..!
    3e44:	64b3651e 69732b98 99c50e2a 09e7933a     .e.d.+si*...:...
    3e54:	a4a5a431 82139298 8b06543a e12e0968     1.......:T..h...
    3e64:	8902bc15 4c4a5281 94386825 024d0180     .....RJL%h8...M.
    3e74:	08113406 1059a10d 24e0c701 a073c326     .4....Y....$&.s.
    3e84:	32a1500c f0cb0344 41c30e11 91860c98     .P.2D......A....
    3e94:	248c3064 19246183 60c9230c c3064918     d0.$.a$..#.`.I..
    3ea4:	46183248 9230c192 6491860c 02268c30     H2.F..0....d0.&.
    3eb4:	0000d442 7b6e5944 2b012dc2 a25412b4     B...DYn{.-.+..T.
    3ec4:	9d1a80d4 54a91308 23234a90 41ac0572     .......T.J##r..A
    3ed4:	d210a055 8f406a22 9854d247 365192cb     U..."j@.G.T...Q6
    3ee4:	28d92709 c166551a 4b028214 612b8910     .'.(.Uf....K..+a
    3ef4:	82042c24 a18c0cb0 aa063832 82281500     $,......28....(.
    3f04:	d6069844 02601240 1205a029 306e4500     D...@.`.)....En0
    3f14:	c22dc22c ad8d506a 11a08e84 6066031a     ,.-.jP........f`
    3f24:	3181980c 80c60660 46821a19 63270ce0     ...1`......F..'c
    3f34:	4f908474 8b3651d2 0e10e566 0c0841cc     t..O.Q6.f....A..
    3f44:	1860c606 60618318 3181860c c0e1010c     ..`...a`...1....
    3f54:	a2c7041c 4e946d59 c74241f2 1c0d38c8     ....Ym.N.AB..8..
    3f64:	06342341 3018c0cc 0cc06303 3433018c     A#4....0.c....34
    3f74:	11d08d04 6c6a8356 00005825 ff040000     ....V.jl%X......
    3f84:	000000ff                                ....

00003f88 <u8g2_cb_r0>:
    3f88:	000021c5 00002249 00002275 00002450     .!..I"..u"..P$..
    3f98:	00002426 00002438 0000244a 00002450     &$..8$..J$..P$..
    3fa8:	00002450 0000268e 0000269a 000026d6     P$...&...&...&..
    3fb8:	0000268a 000026d6 0000268a 000026bc     .&...&...&...&..
    3fc8:	000026ca                                .&..

00003fcc <u8x8_d_gdey0154_152x304_init_seq>:
    3fcc:	16061518 16171617 16011517 16001603     ................
    3fdc:	162b162b 153c1509 1514fe04 150f1600     +.+...<.........
    3fec:	153a1630 16981661 15ff1631 15121682     0.:.a...1.......
    3ffc:	19871650 000000ff                       P.......

00004004 <u8x8_d_ssd1607_to_display_seq>:
    4004:	19121518 000000ff                       ........

0000400c <u8x8_ssd1607_200x200_display_info>:
    400c:	3c780100 64326464 003d0900 96280400     ..x<dd2d..=...(.
    401c:	00001326 00980130 c233312b 000043b0     &...0...+13..C..
    402c:	50343337 00000000 c236312b 000043b0     734P....+16..C..
    403c:	50363337 00000000 c234312b 000043b0     736P....+14..C..
    404c:	50373337 00000000 c230312b 000043b0     737P....+10..C..
    405c:	72756854 79616473 2d353220 322d3430     Thursday 25-04-2
    406c:	00343230 20776f4e 362e3331 202c2043     024.Now 13.6C , 
    407c:	6d353337 36202c6d 00002533 4d204449     735mm, 63%..ID M
    408c:	00303334 372d4652 00426439 2e332042     430.RF-79dB.B 3.
    409c:	00563439                                94V.

000040a0 <_init>:
    40a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    40a2:	46c0      	nop			; (mov r8, r8)
    40a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    40a6:	bc08      	pop	{r3}
    40a8:	469e      	mov	lr, r3
    40aa:	4770      	bx	lr

000040ac <__init_array_start>:
    40ac:	000000cd 	.word	0x000000cd

000040b0 <_fini>:
    40b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    40b2:	46c0      	nop			; (mov r8, r8)
    40b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    40b6:	bc08      	pop	{r3}
    40b8:	469e      	mov	lr, r3
    40ba:	4770      	bx	lr

000040bc <__fini_array_start>:
    40bc:	000000a5 	.word	0x000000a5
