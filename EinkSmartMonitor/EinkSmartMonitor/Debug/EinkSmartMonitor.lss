
EinkSmartMonitor.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004060  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000018  20000000  00004060  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000017a8  20000018  00004078  00020018  2**2
                  ALLOC
  3 .stack        00001000  200017c0  00005820  00020018  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020018  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020040  2**0
                  CONTENTS, READONLY
  6 .debug_info   000c2413  00000000  00000000  00020099  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000051a5  00000000  00000000  000e24ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0005134d  00000000  00000000  000e7651  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00003400  00000000  00000000  0013899e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000033a0  00000000  00000000  0013bd9e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00007aeb  00000000  00000000  0013f13e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000186b4  00000000  00000000  00146c29  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0006e0f9  00000000  00000000  0015f2dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000abe0  00000000  00000000  001cd3d8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	c0 27 00 20 09 01 00 00 05 01 00 00 05 01 00 00     .'. ............
	...
      2c:	05 01 00 00 00 00 00 00 00 00 00 00 05 01 00 00     ................
      3c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
      4c:	05 01 00 00 3d 07 00 00 05 01 00 00 05 01 00 00     ....=...........
      5c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
	...
      74:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
      84:	05 01 00 00 05 01 00 00 00 00 00 00 00 00 00 00     ................
      94:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	20000018 	.word	0x20000018
      c4:	00000000 	.word	0x00000000
      c8:	00004060 	.word	0x00004060

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      ce:	b510      	push	{r4, lr}
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	2000001c 	.word	0x2000001c
      f8:	00004060 	.word	0x00004060
      fc:	00004060 	.word	0x00004060
     100:	00000000 	.word	0x00000000

00000104 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     104:	e7fe      	b.n	104 <Dummy_Handler>
	...

00000108 <Reset_Handler>:
{
     108:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     10a:	4a12      	ldr	r2, [pc, #72]	; (154 <Reset_Handler+0x4c>)
     10c:	4b12      	ldr	r3, [pc, #72]	; (158 <Reset_Handler+0x50>)
     10e:	429a      	cmp	r2, r3
     110:	d009      	beq.n	126 <Reset_Handler+0x1e>
     112:	4b11      	ldr	r3, [pc, #68]	; (158 <Reset_Handler+0x50>)
     114:	4a0f      	ldr	r2, [pc, #60]	; (154 <Reset_Handler+0x4c>)
     116:	e003      	b.n	120 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     118:	6811      	ldr	r1, [r2, #0]
     11a:	6019      	str	r1, [r3, #0]
     11c:	3304      	adds	r3, #4
     11e:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     120:	490e      	ldr	r1, [pc, #56]	; (15c <Reset_Handler+0x54>)
     122:	428b      	cmp	r3, r1
     124:	d3f8      	bcc.n	118 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     126:	4b0e      	ldr	r3, [pc, #56]	; (160 <Reset_Handler+0x58>)
     128:	e002      	b.n	130 <Reset_Handler+0x28>
                *pDest++ = 0;
     12a:	2200      	movs	r2, #0
     12c:	601a      	str	r2, [r3, #0]
     12e:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     130:	4a0c      	ldr	r2, [pc, #48]	; (164 <Reset_Handler+0x5c>)
     132:	4293      	cmp	r3, r2
     134:	d3f9      	bcc.n	12a <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     136:	4a0c      	ldr	r2, [pc, #48]	; (168 <Reset_Handler+0x60>)
     138:	21ff      	movs	r1, #255	; 0xff
     13a:	4b0c      	ldr	r3, [pc, #48]	; (16c <Reset_Handler+0x64>)
     13c:	438b      	bics	r3, r1
     13e:	6093      	str	r3, [r2, #8]
        NVMCTRL->CTRLB.bit.MANW = 1;
     140:	4a0b      	ldr	r2, [pc, #44]	; (170 <Reset_Handler+0x68>)
     142:	6851      	ldr	r1, [r2, #4]
     144:	2380      	movs	r3, #128	; 0x80
     146:	430b      	orrs	r3, r1
     148:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     14a:	4b0a      	ldr	r3, [pc, #40]	; (174 <Reset_Handler+0x6c>)
     14c:	4798      	blx	r3
        main();
     14e:	4b0a      	ldr	r3, [pc, #40]	; (178 <Reset_Handler+0x70>)
     150:	4798      	blx	r3
     152:	e7fe      	b.n	152 <Reset_Handler+0x4a>
     154:	00004060 	.word	0x00004060
     158:	20000000 	.word	0x20000000
     15c:	20000018 	.word	0x20000018
     160:	20000018 	.word	0x20000018
     164:	200017c0 	.word	0x200017c0
     168:	e000ed00 	.word	0xe000ed00
     16c:	00000000 	.word	0x00000000
     170:	41004000 	.word	0x41004000
     174:	00002c11 	.word	0x00002c11
     178:	00002879 	.word	0x00002879

0000017c <delay_driver_init>:
	i2c_m_sync_init(&I2C_0, SERCOM3);
	I2C_0_PORT_init();
}

void delay_driver_init(void)
{
     17c:	b510      	push	{r4, lr}
	delay_init(SysTick);
     17e:	4802      	ldr	r0, [pc, #8]	; (188 <delay_driver_init+0xc>)
     180:	4b02      	ldr	r3, [pc, #8]	; (18c <delay_driver_init+0x10>)
     182:	4798      	blx	r3
}
     184:	bd10      	pop	{r4, pc}
     186:	46c0      	nop			; (mov r8, r8)
     188:	e000e010 	.word	0xe000e010
     18c:	000001ad 	.word	0x000001ad

00000190 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     190:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     194:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     196:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     198:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
     19c:	4770      	bx	lr

0000019e <atomic_leave_critical>:
     19e:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     1a2:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     1a4:	f383 8810 	msr	PRIMASK, r3
}
     1a8:	4770      	bx	lr
	...

000001ac <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
     1ac:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
     1ae:	4b02      	ldr	r3, [pc, #8]	; (1b8 <delay_init+0xc>)
     1b0:	6018      	str	r0, [r3, #0]
     1b2:	4b02      	ldr	r3, [pc, #8]	; (1bc <delay_init+0x10>)
     1b4:	4798      	blx	r3
}
     1b6:	bd10      	pop	{r4, pc}
     1b8:	20000034 	.word	0x20000034
     1bc:	0000113d 	.word	0x0000113d

000001c0 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     1c0:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     1c2:	4b04      	ldr	r3, [pc, #16]	; (1d4 <delay_ms+0x14>)
     1c4:	681c      	ldr	r4, [r3, #0]
     1c6:	4b04      	ldr	r3, [pc, #16]	; (1d8 <delay_ms+0x18>)
     1c8:	4798      	blx	r3
     1ca:	0001      	movs	r1, r0
     1cc:	0020      	movs	r0, r4
     1ce:	4b03      	ldr	r3, [pc, #12]	; (1dc <delay_ms+0x1c>)
     1d0:	4798      	blx	r3
}
     1d2:	bd10      	pop	{r4, pc}
     1d4:	20000034 	.word	0x20000034
     1d8:	00000609 	.word	0x00000609
     1dc:	00001149 	.word	0x00001149

000001e0 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
     1e0:	b570      	push	{r4, r5, r6, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
     1e2:	2502      	movs	r5, #2
     1e4:	2400      	movs	r4, #0

	while (upper >= lower) {
     1e6:	e007      	b.n	1f8 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
     1e8:	4a0d      	ldr	r2, [pc, #52]	; (220 <process_ext_irq+0x40>)
     1ea:	58b3      	ldr	r3, [r6, r2]
     1ec:	2b00      	cmp	r3, #0
     1ee:	d000      	beq.n	1f2 <process_ext_irq+0x12>
				ext_irqs[middle].cb();
     1f0:	4798      	blx	r3
			lower = middle + 1;
		} else {
			upper = middle - 1;
		}
	}
}
     1f2:	bd70      	pop	{r4, r5, r6, pc}
			upper = middle - 1;
     1f4:	3a01      	subs	r2, #1
     1f6:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
     1f8:	42ac      	cmp	r4, r5
     1fa:	d8fa      	bhi.n	1f2 <process_ext_irq+0x12>
		middle = (upper + lower) >> 1;
     1fc:	192b      	adds	r3, r5, r4
     1fe:	105b      	asrs	r3, r3, #1
     200:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
     202:	2a01      	cmp	r2, #1
     204:	d8f5      	bhi.n	1f2 <process_ext_irq+0x12>
     206:	21ff      	movs	r1, #255	; 0xff
     208:	400b      	ands	r3, r1
		if (ext_irqs[middle].pin == pin) {
     20a:	00de      	lsls	r6, r3, #3
     20c:	4904      	ldr	r1, [pc, #16]	; (220 <process_ext_irq+0x40>)
     20e:	1989      	adds	r1, r1, r6
     210:	6849      	ldr	r1, [r1, #4]
     212:	4281      	cmp	r1, r0
     214:	d0e8      	beq.n	1e8 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
     216:	d2ed      	bcs.n	1f4 <process_ext_irq+0x14>
			lower = middle + 1;
     218:	3201      	adds	r2, #1
     21a:	b2d4      	uxtb	r4, r2
     21c:	e7ec      	b.n	1f8 <process_ext_irq+0x18>
     21e:	46c0      	nop			; (mov r8, r8)
     220:	20000038 	.word	0x20000038

00000224 <ext_irq_init>:
{
     224:	b510      	push	{r4, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     226:	2300      	movs	r3, #0
     228:	e009      	b.n	23e <ext_irq_init+0x1a>
		ext_irqs[i].pin = 0xFFFFFFFF;
     22a:	4a08      	ldr	r2, [pc, #32]	; (24c <ext_irq_init+0x28>)
     22c:	00d9      	lsls	r1, r3, #3
     22e:	1850      	adds	r0, r2, r1
     230:	2401      	movs	r4, #1
     232:	4264      	negs	r4, r4
     234:	6044      	str	r4, [r0, #4]
		ext_irqs[i].cb  = NULL;
     236:	2000      	movs	r0, #0
     238:	5088      	str	r0, [r1, r2]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     23a:	3301      	adds	r3, #1
     23c:	b29b      	uxth	r3, r3
     23e:	2b01      	cmp	r3, #1
     240:	d9f3      	bls.n	22a <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
     242:	4803      	ldr	r0, [pc, #12]	; (250 <ext_irq_init+0x2c>)
     244:	4b03      	ldr	r3, [pc, #12]	; (254 <ext_irq_init+0x30>)
     246:	4798      	blx	r3
}
     248:	bd10      	pop	{r4, pc}
     24a:	46c0      	nop			; (mov r8, r8)
     24c:	20000038 	.word	0x20000038
     250:	000001e1 	.word	0x000001e1
     254:	0000064d 	.word	0x0000064d

00000258 <ext_irq_register>:
{
     258:	b5f0      	push	{r4, r5, r6, r7, lr}
     25a:	46d6      	mov	lr, sl
     25c:	464f      	mov	r7, r9
     25e:	4646      	mov	r6, r8
     260:	b5c0      	push	{r6, r7, lr}
     262:	b084      	sub	sp, #16
	uint8_t i = 0, j = 0;
     264:	2300      	movs	r3, #0
	for (; i < EXT_IRQ_AMOUNT; i++) {
     266:	2b01      	cmp	r3, #1
     268:	d80c      	bhi.n	284 <ext_irq_register+0x2c>
		if (ext_irqs[i].pin == pin) {
     26a:	00dc      	lsls	r4, r3, #3
     26c:	4a32      	ldr	r2, [pc, #200]	; (338 <ext_irq_register+0xe0>)
     26e:	1912      	adds	r2, r2, r4
     270:	6852      	ldr	r2, [r2, #4]
     272:	4282      	cmp	r2, r0
     274:	d002      	beq.n	27c <ext_irq_register+0x24>
	for (; i < EXT_IRQ_AMOUNT; i++) {
     276:	3301      	adds	r3, #1
     278:	b2db      	uxtb	r3, r3
     27a:	e7f4      	b.n	266 <ext_irq_register+0xe>
			ext_irqs[i].cb = cb;
     27c:	4b2e      	ldr	r3, [pc, #184]	; (338 <ext_irq_register+0xe0>)
     27e:	50e1      	str	r1, [r4, r3]
			found          = true;
     280:	2601      	movs	r6, #1
			break;
     282:	e000      	b.n	286 <ext_irq_register+0x2e>
	bool    found = false;
     284:	2600      	movs	r6, #0
	if (NULL == cb) {
     286:	2900      	cmp	r1, #0
     288:	d00c      	beq.n	2a4 <ext_irq_register+0x4c>
	if (!found) {
     28a:	2e00      	cmp	r6, #0
     28c:	d142      	bne.n	314 <ext_irq_register+0xbc>
     28e:	2300      	movs	r3, #0
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     290:	2b01      	cmp	r3, #1
     292:	d811      	bhi.n	2b8 <ext_irq_register+0x60>
			if (NULL == ext_irqs[i].cb) {
     294:	00da      	lsls	r2, r3, #3
     296:	4d28      	ldr	r5, [pc, #160]	; (338 <ext_irq_register+0xe0>)
     298:	5952      	ldr	r2, [r2, r5]
     29a:	2a00      	cmp	r2, #0
     29c:	d007      	beq.n	2ae <ext_irq_register+0x56>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     29e:	3301      	adds	r3, #1
     2a0:	b2db      	uxtb	r3, r3
     2a2:	e7f5      	b.n	290 <ext_irq_register+0x38>
		if (!found) {
     2a4:	2e00      	cmp	r6, #0
     2a6:	d040      	beq.n	32a <ext_irq_register+0xd2>
		return _ext_irq_enable(pin, false);
     2a8:	4b24      	ldr	r3, [pc, #144]	; (33c <ext_irq_register+0xe4>)
     2aa:	4798      	blx	r3
     2ac:	e037      	b.n	31e <ext_irq_register+0xc6>
				ext_irqs[i].cb  = cb;
     2ae:	00dc      	lsls	r4, r3, #3
     2b0:	5161      	str	r1, [r4, r5]
				ext_irqs[i].pin = pin;
     2b2:	192c      	adds	r4, r5, r4
     2b4:	6060      	str	r0, [r4, #4]
				found           = true;
     2b6:	2601      	movs	r6, #1
     2b8:	2200      	movs	r2, #0
     2ba:	e001      	b.n	2c0 <ext_irq_register+0x68>
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
     2bc:	3201      	adds	r2, #1
     2be:	b2d2      	uxtb	r2, r2
     2c0:	2a01      	cmp	r2, #1
     2c2:	d827      	bhi.n	314 <ext_irq_register+0xbc>
     2c4:	2b01      	cmp	r3, #1
     2c6:	d825      	bhi.n	314 <ext_irq_register+0xbc>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
     2c8:	9301      	str	r3, [sp, #4]
     2ca:	491b      	ldr	r1, [pc, #108]	; (338 <ext_irq_register+0xe0>)
     2cc:	00dc      	lsls	r4, r3, #3
     2ce:	190c      	adds	r4, r1, r4
     2d0:	6867      	ldr	r7, [r4, #4]
     2d2:	00d4      	lsls	r4, r2, #3
     2d4:	1909      	adds	r1, r1, r4
     2d6:	6849      	ldr	r1, [r1, #4]
     2d8:	428f      	cmp	r7, r1
     2da:	d2ef      	bcs.n	2bc <ext_irq_register+0x64>
     2dc:	1c4c      	adds	r4, r1, #1
     2de:	d0ed      	beq.n	2bc <ext_irq_register+0x64>
				struct ext_irq tmp = ext_irqs[j];
     2e0:	a902      	add	r1, sp, #8
     2e2:	468c      	mov	ip, r1
     2e4:	4c14      	ldr	r4, [pc, #80]	; (338 <ext_irq_register+0xe0>)
     2e6:	46a0      	mov	r8, r4
     2e8:	00d4      	lsls	r4, r2, #3
     2ea:	46a1      	mov	r9, r4
     2ec:	4644      	mov	r4, r8
     2ee:	444c      	add	r4, r9
     2f0:	4665      	mov	r5, ip
     2f2:	cc82      	ldmia	r4!, {r1, r7}
     2f4:	c582      	stmia	r5!, {r1, r7}
				ext_irqs[j] = ext_irqs[i];
     2f6:	9901      	ldr	r1, [sp, #4]
     2f8:	00c9      	lsls	r1, r1, #3
     2fa:	468a      	mov	sl, r1
     2fc:	4649      	mov	r1, r9
     2fe:	4441      	add	r1, r8
     300:	4644      	mov	r4, r8
     302:	4454      	add	r4, sl
     304:	cca0      	ldmia	r4!, {r5, r7}
     306:	c1a0      	stmia	r1!, {r5, r7}
				ext_irqs[i] = tmp;
     308:	4645      	mov	r5, r8
     30a:	4455      	add	r5, sl
     30c:	4661      	mov	r1, ip
     30e:	c990      	ldmia	r1!, {r4, r7}
     310:	c590      	stmia	r5!, {r4, r7}
     312:	e7d3      	b.n	2bc <ext_irq_register+0x64>
	if (!found) {
     314:	2e00      	cmp	r6, #0
     316:	d00b      	beq.n	330 <ext_irq_register+0xd8>
	return _ext_irq_enable(pin, true);
     318:	2101      	movs	r1, #1
     31a:	4b08      	ldr	r3, [pc, #32]	; (33c <ext_irq_register+0xe4>)
     31c:	4798      	blx	r3
}
     31e:	b004      	add	sp, #16
     320:	bc1c      	pop	{r2, r3, r4}
     322:	4690      	mov	r8, r2
     324:	4699      	mov	r9, r3
     326:	46a2      	mov	sl, r4
     328:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
     32a:	200d      	movs	r0, #13
     32c:	4240      	negs	r0, r0
     32e:	e7f6      	b.n	31e <ext_irq_register+0xc6>
		return ERR_INVALID_ARG;
     330:	200d      	movs	r0, #13
     332:	4240      	negs	r0, r0
     334:	e7f3      	b.n	31e <ext_irq_register+0xc6>
     336:	46c0      	nop			; (mov r8, r8)
     338:	20000038 	.word	0x20000038
     33c:	000006e9 	.word	0x000006e9

00000340 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
     340:	b510      	push	{r4, lr}
     342:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
     344:	3814      	subs	r0, #20
     346:	8b84      	ldrh	r4, [r0, #28]
     348:	ab01      	add	r3, sp, #4
     34a:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     34c:	0014      	movs	r4, r2
     34e:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
     350:	4a06      	ldr	r2, [pc, #24]	; (36c <i2c_m_sync_write+0x2c>)
     352:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
     354:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     356:	0019      	movs	r1, r3
     358:	4b05      	ldr	r3, [pc, #20]	; (370 <i2c_m_sync_write+0x30>)
     35a:	4798      	blx	r3

	if (ret) {
     35c:	2800      	cmp	r0, #0
     35e:	d102      	bne.n	366 <i2c_m_sync_write+0x26>
		return ret;
	}

	return n;
}
     360:	0020      	movs	r0, r4
     362:	b004      	add	sp, #16
     364:	bd10      	pop	{r4, pc}
		return ret;
     366:	0004      	movs	r4, r0
     368:	e7fa      	b.n	360 <i2c_m_sync_write+0x20>
     36a:	46c0      	nop			; (mov r8, r8)
     36c:	ffff8000 	.word	0xffff8000
     370:	00000b89 	.word	0x00000b89

00000374 <i2c_m_sync_read>:
{
     374:	b510      	push	{r4, lr}
     376:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
     378:	3814      	subs	r0, #20
     37a:	8b84      	ldrh	r4, [r0, #28]
     37c:	ab01      	add	r3, sp, #4
     37e:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     380:	0014      	movs	r4, r2
     382:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     384:	4a06      	ldr	r2, [pc, #24]	; (3a0 <i2c_m_sync_read+0x2c>)
     386:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
     388:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     38a:	0019      	movs	r1, r3
     38c:	4b05      	ldr	r3, [pc, #20]	; (3a4 <i2c_m_sync_read+0x30>)
     38e:	4798      	blx	r3
	if (ret) {
     390:	2800      	cmp	r0, #0
     392:	d102      	bne.n	39a <i2c_m_sync_read+0x26>
}
     394:	0020      	movs	r0, r4
     396:	b004      	add	sp, #16
     398:	bd10      	pop	{r4, pc}
		return ret;
     39a:	0004      	movs	r4, r0
     39c:	e7fa      	b.n	394 <i2c_m_sync_read+0x20>
     39e:	46c0      	nop			; (mov r8, r8)
     3a0:	ffff8001 	.word	0xffff8001
     3a4:	00000b89 	.word	0x00000b89

000003a8 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
     3a8:	b570      	push	{r4, r5, r6, lr}
     3aa:	0004      	movs	r4, r0
     3ac:	000d      	movs	r5, r1
	int32_t init_status;
	ASSERT(i2c);
     3ae:	1e43      	subs	r3, r0, #1
     3b0:	4198      	sbcs	r0, r3
     3b2:	b2c0      	uxtb	r0, r0
     3b4:	225e      	movs	r2, #94	; 0x5e
     3b6:	4907      	ldr	r1, [pc, #28]	; (3d4 <i2c_m_sync_init+0x2c>)
     3b8:	4b07      	ldr	r3, [pc, #28]	; (3d8 <i2c_m_sync_init+0x30>)
     3ba:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
     3bc:	0029      	movs	r1, r5
     3be:	0020      	movs	r0, r4
     3c0:	4b06      	ldr	r3, [pc, #24]	; (3dc <i2c_m_sync_init+0x34>)
     3c2:	4798      	blx	r3
	if (init_status) {
     3c4:	2800      	cmp	r0, #0
     3c6:	d103      	bne.n	3d0 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
     3c8:	4b05      	ldr	r3, [pc, #20]	; (3e0 <i2c_m_sync_init+0x38>)
     3ca:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
     3cc:	4b05      	ldr	r3, [pc, #20]	; (3e4 <i2c_m_sync_init+0x3c>)
     3ce:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
     3d0:	bd70      	pop	{r4, r5, r6, pc}
     3d2:	46c0      	nop			; (mov r8, r8)
     3d4:	00002c68 	.word	0x00002c68
     3d8:	00000601 	.word	0x00000601
     3dc:	00000a65 	.word	0x00000a65
     3e0:	00000375 	.word	0x00000375
     3e4:	00000341 	.word	0x00000341

000003e8 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
     3e8:	b510      	push	{r4, lr}
	return _i2c_m_sync_enable(&i2c->device);
     3ea:	4b01      	ldr	r3, [pc, #4]	; (3f0 <i2c_m_sync_enable+0x8>)
     3ec:	4798      	blx	r3
}
     3ee:	bd10      	pop	{r4, pc}
     3f0:	00000b11 	.word	0x00000b11

000003f4 <i2c_m_sync_set_slaveaddr>:
/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
     3f4:	0589      	lsls	r1, r1, #22
     3f6:	0d89      	lsrs	r1, r1, #22
     3f8:	2380      	movs	r3, #128	; 0x80
     3fa:	00db      	lsls	r3, r3, #3
     3fc:	401a      	ands	r2, r3
     3fe:	430a      	orrs	r2, r1
     400:	8382      	strh	r2, [r0, #28]
}
     402:	0010      	movs	r0, r2
     404:	4770      	bx	lr
	...

00000408 <i2c_m_sync_cmd_read>:

/**
 * \brief Sync version of i2c read command
 */
int32_t i2c_m_sync_cmd_read(struct i2c_m_sync_desc *i2c, uint8_t reg, uint8_t *buffer, uint8_t length)
{
     408:	b570      	push	{r4, r5, r6, lr}
     40a:	b086      	sub	sp, #24
     40c:	0004      	movs	r4, r0
     40e:	0016      	movs	r6, r2
     410:	001d      	movs	r5, r3
     412:	466b      	mov	r3, sp
     414:	71d9      	strb	r1, [r3, #7]
     416:	3307      	adds	r3, #7
	struct _i2c_m_msg msg;
	int32_t           ret;

	msg.addr   = i2c->slave_addr;
     418:	8b82      	ldrh	r2, [r0, #28]
     41a:	a903      	add	r1, sp, #12
     41c:	800a      	strh	r2, [r1, #0]
	msg.len    = 1;
     41e:	2201      	movs	r2, #1
     420:	604a      	str	r2, [r1, #4]
	msg.flags  = 0;
     422:	2200      	movs	r2, #0
     424:	804a      	strh	r2, [r1, #2]
	msg.buffer = &reg;
     426:	608b      	str	r3, [r1, #8]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     428:	4b07      	ldr	r3, [pc, #28]	; (448 <i2c_m_sync_cmd_read+0x40>)
     42a:	4798      	blx	r3

	if (ret != 0) {
     42c:	2800      	cmp	r0, #0
     42e:	d001      	beq.n	434 <i2c_m_sync_cmd_read+0x2c>
		/* error occurred */
		return ret;
	}

	return ERR_NONE;
}
     430:	b006      	add	sp, #24
     432:	bd70      	pop	{r4, r5, r6, pc}
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     434:	a903      	add	r1, sp, #12
     436:	4b05      	ldr	r3, [pc, #20]	; (44c <i2c_m_sync_cmd_read+0x44>)
     438:	804b      	strh	r3, [r1, #2]
	msg.buffer = buffer;
     43a:	608e      	str	r6, [r1, #8]
	msg.len    = length;
     43c:	604d      	str	r5, [r1, #4]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     43e:	0020      	movs	r0, r4
     440:	4b01      	ldr	r3, [pc, #4]	; (448 <i2c_m_sync_cmd_read+0x40>)
     442:	4798      	blx	r3
     444:	e7f4      	b.n	430 <i2c_m_sync_cmd_read+0x28>
     446:	46c0      	nop			; (mov r8, r8)
     448:	00000b89 	.word	0x00000b89
     44c:	ffff8001 	.word	0xffff8001

00000450 <i2c_m_sync_get_io_descriptor>:
/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
	*io = &i2c->io;
     450:	3014      	adds	r0, #20
     452:	6008      	str	r0, [r1, #0]
	return ERR_NONE;
}
     454:	2000      	movs	r0, #0
     456:	4770      	bx	lr

00000458 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     458:	b570      	push	{r4, r5, r6, lr}
     45a:	0004      	movs	r4, r0
     45c:	000d      	movs	r5, r1
     45e:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
     460:	2800      	cmp	r0, #0
     462:	d00e      	beq.n	482 <io_write+0x2a>
     464:	2900      	cmp	r1, #0
     466:	d00a      	beq.n	47e <io_write+0x26>
     468:	2001      	movs	r0, #1
     46a:	2234      	movs	r2, #52	; 0x34
     46c:	4906      	ldr	r1, [pc, #24]	; (488 <io_write+0x30>)
     46e:	4b07      	ldr	r3, [pc, #28]	; (48c <io_write+0x34>)
     470:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     472:	6823      	ldr	r3, [r4, #0]
     474:	0032      	movs	r2, r6
     476:	0029      	movs	r1, r5
     478:	0020      	movs	r0, r4
     47a:	4798      	blx	r3
}
     47c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
     47e:	2000      	movs	r0, #0
     480:	e7f3      	b.n	46a <io_write+0x12>
     482:	2000      	movs	r0, #0
     484:	e7f1      	b.n	46a <io_write+0x12>
     486:	46c0      	nop			; (mov r8, r8)
     488:	00002c84 	.word	0x00002c84
     48c:	00000601 	.word	0x00000601

00000490 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
     490:	b570      	push	{r4, r5, r6, lr}
     492:	0004      	movs	r4, r0
     494:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
     496:	2800      	cmp	r0, #0
     498:	d017      	beq.n	4ca <spi_m_sync_init+0x3a>
     49a:	2900      	cmp	r1, #0
     49c:	d013      	beq.n	4c6 <spi_m_sync_init+0x36>
     49e:	2001      	movs	r0, #1
     4a0:	2240      	movs	r2, #64	; 0x40
     4a2:	490b      	ldr	r1, [pc, #44]	; (4d0 <spi_m_sync_init+0x40>)
     4a4:	4b0b      	ldr	r3, [pc, #44]	; (4d4 <spi_m_sync_init+0x44>)
     4a6:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
     4a8:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
     4aa:	1d20      	adds	r0, r4, #4
     4ac:	0029      	movs	r1, r5
     4ae:	4b0a      	ldr	r3, [pc, #40]	; (4d8 <spi_m_sync_init+0x48>)
     4b0:	4798      	blx	r3

	if (rc < 0) {
     4b2:	2800      	cmp	r0, #0
     4b4:	db06      	blt.n	4c4 <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
     4b6:	4b09      	ldr	r3, [pc, #36]	; (4dc <spi_m_sync_init+0x4c>)
     4b8:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
     4ba:	4b09      	ldr	r3, [pc, #36]	; (4e0 <spi_m_sync_init+0x50>)
     4bc:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
     4be:	4b09      	ldr	r3, [pc, #36]	; (4e4 <spi_m_sync_init+0x54>)
     4c0:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
     4c2:	2000      	movs	r0, #0
}
     4c4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
     4c6:	2000      	movs	r0, #0
     4c8:	e7ea      	b.n	4a0 <spi_m_sync_init+0x10>
     4ca:	2000      	movs	r0, #0
     4cc:	e7e8      	b.n	4a0 <spi_m_sync_init+0x10>
     4ce:	46c0      	nop			; (mov r8, r8)
     4d0:	00002c98 	.word	0x00002c98
     4d4:	00000601 	.word	0x00000601
     4d8:	00000da5 	.word	0x00000da5
     4dc:	ffff8000 	.word	0xffff8000
     4e0:	00000595 	.word	0x00000595
     4e4:	00000559 	.word	0x00000559

000004e8 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
     4e8:	b510      	push	{r4, lr}
     4ea:	0004      	movs	r4, r0
	ASSERT(spi);
     4ec:	1e43      	subs	r3, r0, #1
     4ee:	4198      	sbcs	r0, r3
     4f0:	b2c0      	uxtb	r0, r0
     4f2:	2257      	movs	r2, #87	; 0x57
     4f4:	4903      	ldr	r1, [pc, #12]	; (504 <spi_m_sync_enable+0x1c>)
     4f6:	4b04      	ldr	r3, [pc, #16]	; (508 <spi_m_sync_enable+0x20>)
     4f8:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
     4fa:	1d20      	adds	r0, r4, #4
     4fc:	4b03      	ldr	r3, [pc, #12]	; (50c <spi_m_sync_enable+0x24>)
     4fe:	4798      	blx	r3
}
     500:	bd10      	pop	{r4, pc}
     502:	46c0      	nop			; (mov r8, r8)
     504:	00002c98 	.word	0x00002c98
     508:	00000601 	.word	0x00000601
     50c:	00000f5d 	.word	0x00000f5d

00000510 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
     510:	b530      	push	{r4, r5, lr}
     512:	b087      	sub	sp, #28
     514:	0004      	movs	r4, r0
     516:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
     518:	2800      	cmp	r0, #0
     51a:	d015      	beq.n	548 <spi_m_sync_transfer+0x38>
     51c:	2900      	cmp	r1, #0
     51e:	d011      	beq.n	544 <spi_m_sync_transfer+0x34>
     520:	2001      	movs	r0, #1
     522:	22b3      	movs	r2, #179	; 0xb3
     524:	4909      	ldr	r1, [pc, #36]	; (54c <spi_m_sync_transfer+0x3c>)
     526:	4b0a      	ldr	r3, [pc, #40]	; (550 <spi_m_sync_transfer+0x40>)
     528:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
     52a:	682b      	ldr	r3, [r5, #0]
     52c:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
     52e:	686b      	ldr	r3, [r5, #4]
     530:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
     532:	68ab      	ldr	r3, [r5, #8]
     534:	9301      	str	r3, [sp, #4]
     536:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
     538:	1d20      	adds	r0, r4, #4
     53a:	a903      	add	r1, sp, #12
     53c:	4b05      	ldr	r3, [pc, #20]	; (554 <spi_m_sync_transfer+0x44>)
     53e:	4798      	blx	r3
}
     540:	b007      	add	sp, #28
     542:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
     544:	2000      	movs	r0, #0
     546:	e7ec      	b.n	522 <spi_m_sync_transfer+0x12>
     548:	2000      	movs	r0, #0
     54a:	e7ea      	b.n	522 <spi_m_sync_transfer+0x12>
     54c:	00002c98 	.word	0x00002c98
     550:	00000601 	.word	0x00000601
     554:	00000f95 	.word	0x00000f95

00000558 <_spi_m_sync_io_write>:
{
     558:	b570      	push	{r4, r5, r6, lr}
     55a:	b084      	sub	sp, #16
     55c:	0004      	movs	r4, r0
     55e:	000e      	movs	r6, r1
     560:	0015      	movs	r5, r2
	ASSERT(io);
     562:	1e43      	subs	r3, r0, #1
     564:	4198      	sbcs	r0, r3
     566:	b2c0      	uxtb	r0, r0
     568:	22a3      	movs	r2, #163	; 0xa3
     56a:	4907      	ldr	r1, [pc, #28]	; (588 <_spi_m_sync_io_write+0x30>)
     56c:	4b07      	ldr	r3, [pc, #28]	; (58c <_spi_m_sync_io_write+0x34>)
     56e:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     570:	0020      	movs	r0, r4
     572:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
     574:	2300      	movs	r3, #0
     576:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
     578:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
     57a:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     57c:	a901      	add	r1, sp, #4
     57e:	4b04      	ldr	r3, [pc, #16]	; (590 <_spi_m_sync_io_write+0x38>)
     580:	4798      	blx	r3
}
     582:	b004      	add	sp, #16
     584:	bd70      	pop	{r4, r5, r6, pc}
     586:	46c0      	nop			; (mov r8, r8)
     588:	00002c98 	.word	0x00002c98
     58c:	00000601 	.word	0x00000601
     590:	00000511 	.word	0x00000511

00000594 <_spi_m_sync_io_read>:
{
     594:	b570      	push	{r4, r5, r6, lr}
     596:	b084      	sub	sp, #16
     598:	0004      	movs	r4, r0
     59a:	000e      	movs	r6, r1
     59c:	0015      	movs	r5, r2
	ASSERT(io);
     59e:	1e43      	subs	r3, r0, #1
     5a0:	4198      	sbcs	r0, r3
     5a2:	b2c0      	uxtb	r0, r0
     5a4:	2287      	movs	r2, #135	; 0x87
     5a6:	4907      	ldr	r1, [pc, #28]	; (5c4 <_spi_m_sync_io_read+0x30>)
     5a8:	4b07      	ldr	r3, [pc, #28]	; (5c8 <_spi_m_sync_io_read+0x34>)
     5aa:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     5ac:	0020      	movs	r0, r4
     5ae:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
     5b0:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
     5b2:	2300      	movs	r3, #0
     5b4:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
     5b6:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     5b8:	a901      	add	r1, sp, #4
     5ba:	4b04      	ldr	r3, [pc, #16]	; (5cc <_spi_m_sync_io_read+0x38>)
     5bc:	4798      	blx	r3
}
     5be:	b004      	add	sp, #16
     5c0:	bd70      	pop	{r4, r5, r6, pc}
     5c2:	46c0      	nop			; (mov r8, r8)
     5c4:	00002c98 	.word	0x00002c98
     5c8:	00000601 	.word	0x00000601
     5cc:	00000511 	.word	0x00000511

000005d0 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
     5d0:	b570      	push	{r4, r5, r6, lr}
     5d2:	0004      	movs	r4, r0
     5d4:	000d      	movs	r5, r1
	ASSERT(spi && io);
     5d6:	2800      	cmp	r0, #0
     5d8:	d00c      	beq.n	5f4 <spi_m_sync_get_io_descriptor+0x24>
     5da:	2900      	cmp	r1, #0
     5dc:	d008      	beq.n	5f0 <spi_m_sync_get_io_descriptor+0x20>
     5de:	2001      	movs	r0, #1
     5e0:	22bd      	movs	r2, #189	; 0xbd
     5e2:	4905      	ldr	r1, [pc, #20]	; (5f8 <spi_m_sync_get_io_descriptor+0x28>)
     5e4:	4b05      	ldr	r3, [pc, #20]	; (5fc <spi_m_sync_get_io_descriptor+0x2c>)
     5e6:	4798      	blx	r3
	*io = &spi->io;
     5e8:	340c      	adds	r4, #12
     5ea:	602c      	str	r4, [r5, #0]
	return 0;
}
     5ec:	2000      	movs	r0, #0
     5ee:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && io);
     5f0:	2000      	movs	r0, #0
     5f2:	e7f5      	b.n	5e0 <spi_m_sync_get_io_descriptor+0x10>
     5f4:	2000      	movs	r0, #0
     5f6:	e7f3      	b.n	5e0 <spi_m_sync_get_io_descriptor+0x10>
     5f8:	00002c98 	.word	0x00002c98
     5fc:	00000601 	.word	0x00000601

00000600 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     600:	2800      	cmp	r0, #0
     602:	d100      	bne.n	606 <assert+0x6>
		__asm("BKPT #0");
     604:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     606:	4770      	bx	lr

00000608 <_get_cycles_for_ms>:
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
	switch (power) {
	case 8:
		return (ms * (freq / 100000)) * 100;
     608:	0103      	lsls	r3, r0, #4
     60a:	1a1b      	subs	r3, r3, r0
     60c:	015a      	lsls	r2, r3, #5
     60e:	2064      	movs	r0, #100	; 0x64
     610:	4350      	muls	r0, r2
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
     612:	4770      	bx	lr

00000614 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     614:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
     616:	4a08      	ldr	r2, [pc, #32]	; (638 <_init_chip+0x24>)
     618:	6853      	ldr	r3, [r2, #4]
     61a:	2106      	movs	r1, #6
     61c:	430b      	orrs	r3, r1
     61e:	6053      	str	r3, [r2, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
     620:	4b06      	ldr	r3, [pc, #24]	; (63c <_init_chip+0x28>)
     622:	4798      	blx	r3
	_sysctrl_init_sources();
     624:	4b06      	ldr	r3, [pc, #24]	; (640 <_init_chip+0x2c>)
     626:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
     628:	2008      	movs	r0, #8
     62a:	4c06      	ldr	r4, [pc, #24]	; (644 <_init_chip+0x30>)
     62c:	47a0      	blx	r4
#endif
	_sysctrl_init_referenced_generators();
     62e:	4b06      	ldr	r3, [pc, #24]	; (648 <_init_chip+0x34>)
     630:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     632:	20f7      	movs	r0, #247	; 0xf7
     634:	47a0      	blx	r4
}
     636:	bd10      	pop	{r4, pc}
     638:	41004000 	.word	0x41004000
     63c:	00000839 	.word	0x00000839
     640:	0000107d 	.word	0x0000107d
     644:	000007f9 	.word	0x000007f9
     648:	000010b1 	.word	0x000010b1

0000064c <_ext_irq_init>:
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     64c:	4b23      	ldr	r3, [pc, #140]	; (6dc <_ext_irq_init+0x90>)
     64e:	785b      	ldrb	r3, [r3, #1]
     650:	09db      	lsrs	r3, r3, #7
     652:	d1fb      	bne.n	64c <_ext_irq_init>
     654:	4b21      	ldr	r3, [pc, #132]	; (6dc <_ext_irq_init+0x90>)
     656:	785b      	ldrb	r3, [r3, #1]
     658:	09db      	lsrs	r3, r3, #7
     65a:	d1fb      	bne.n	654 <_ext_irq_init+0x8>

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
	tmp = ((Eic *)hw)->CTRL.reg;
     65c:	4b1f      	ldr	r3, [pc, #124]	; (6dc <_ext_irq_init+0x90>)
     65e:	781b      	ldrb	r3, [r3, #0]
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
	hri_eic_wait_for_sync(EIC);
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
     660:	079b      	lsls	r3, r3, #30
     662:	d50a      	bpl.n	67a <_ext_irq_init+0x2e>
}

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
     664:	2200      	movs	r2, #0
     666:	4b1d      	ldr	r3, [pc, #116]	; (6dc <_ext_irq_init+0x90>)
     668:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     66a:	4b1c      	ldr	r3, [pc, #112]	; (6dc <_ext_irq_init+0x90>)
     66c:	785b      	ldrb	r3, [r3, #1]
     66e:	09db      	lsrs	r3, r3, #7
     670:	d1fb      	bne.n	66a <_ext_irq_init+0x1e>
     672:	4b1a      	ldr	r3, [pc, #104]	; (6dc <_ext_irq_init+0x90>)
     674:	785b      	ldrb	r3, [r3, #1]
     676:	09db      	lsrs	r3, r3, #7
     678:	d1fb      	bne.n	672 <_ext_irq_init+0x26>
	((Eic *)hw)->CTRL.reg = data;
     67a:	2201      	movs	r2, #1
     67c:	4b17      	ldr	r3, [pc, #92]	; (6dc <_ext_irq_init+0x90>)
     67e:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     680:	4b16      	ldr	r3, [pc, #88]	; (6dc <_ext_irq_init+0x90>)
     682:	785b      	ldrb	r3, [r3, #1]
     684:	09db      	lsrs	r3, r3, #7
     686:	d1fb      	bne.n	680 <_ext_irq_init+0x34>
     688:	4b14      	ldr	r3, [pc, #80]	; (6dc <_ext_irq_init+0x90>)
     68a:	785b      	ldrb	r3, [r3, #1]
     68c:	09db      	lsrs	r3, r3, #7
     68e:	d1fb      	bne.n	688 <_ext_irq_init+0x3c>
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
     690:	4b12      	ldr	r3, [pc, #72]	; (6dc <_ext_irq_init+0x90>)
     692:	2200      	movs	r2, #0
     694:	709a      	strb	r2, [r3, #2]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
     696:	605a      	str	r2, [r3, #4]
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
     698:	2282      	movs	r2, #130	; 0x82
     69a:	0192      	lsls	r2, r2, #6
     69c:	615a      	str	r2, [r3, #20]
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
     69e:	2280      	movs	r2, #128	; 0x80
     6a0:	0552      	lsls	r2, r2, #21
     6a2:	619a      	str	r2, [r3, #24]
     6a4:	2280      	movs	r2, #128	; 0x80
     6a6:	0392      	lsls	r2, r2, #14
     6a8:	61da      	str	r2, [r3, #28]
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
     6aa:	781a      	ldrb	r2, [r3, #0]
     6ac:	2102      	movs	r1, #2
     6ae:	430a      	orrs	r2, r1
     6b0:	b2d2      	uxtb	r2, r2
     6b2:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     6b4:	4b09      	ldr	r3, [pc, #36]	; (6dc <_ext_irq_init+0x90>)
     6b6:	785b      	ldrb	r3, [r3, #1]
     6b8:	09db      	lsrs	r3, r3, #7
     6ba:	d1fb      	bne.n	6b4 <_ext_irq_init+0x68>
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     6bc:	4b08      	ldr	r3, [pc, #32]	; (6e0 <_ext_irq_init+0x94>)
     6be:	2210      	movs	r2, #16
     6c0:	2180      	movs	r1, #128	; 0x80
     6c2:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
     6c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     6c8:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     6cc:	3101      	adds	r1, #1
     6ce:	31ff      	adds	r1, #255	; 0xff
     6d0:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     6d2:	601a      	str	r2, [r3, #0]

	NVIC_DisableIRQ(EIC_IRQn);
	NVIC_ClearPendingIRQ(EIC_IRQn);
	NVIC_EnableIRQ(EIC_IRQn);

	callback = cb;
     6d4:	4b03      	ldr	r3, [pc, #12]	; (6e4 <_ext_irq_init+0x98>)
     6d6:	6018      	str	r0, [r3, #0]

	return ERR_NONE;
}
     6d8:	2000      	movs	r0, #0
     6da:	4770      	bx	lr
     6dc:	40001800 	.word	0x40001800
     6e0:	e000e100 	.word	0xe000e100
     6e4:	20000048 	.word	0x20000048

000006e8 <_ext_irq_enable>:

/**
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
     6e8:	b530      	push	{r4, r5, lr}
	uint8_t extint = INVALID_EXTINT_NUMBER;
	uint8_t i      = 0;
     6ea:	2300      	movs	r3, #0

	for (; i < ARRAY_SIZE(_map); i++) {
     6ec:	2b01      	cmp	r3, #1
     6ee:	d80b      	bhi.n	708 <_ext_irq_enable+0x20>
		if (_map[i].pin == pin) {
     6f0:	00dc      	lsls	r4, r3, #3
     6f2:	4a10      	ldr	r2, [pc, #64]	; (734 <_ext_irq_enable+0x4c>)
     6f4:	1912      	adds	r2, r2, r4
     6f6:	6852      	ldr	r2, [r2, #4]
     6f8:	4282      	cmp	r2, r0
     6fa:	d002      	beq.n	702 <_ext_irq_enable+0x1a>
	for (; i < ARRAY_SIZE(_map); i++) {
     6fc:	3301      	adds	r3, #1
     6fe:	b2db      	uxtb	r3, r3
     700:	e7f4      	b.n	6ec <_ext_irq_enable+0x4>
			extint = _map[i].extint;
     702:	4b0c      	ldr	r3, [pc, #48]	; (734 <_ext_irq_enable+0x4c>)
     704:	5ce2      	ldrb	r2, [r4, r3]
			break;
     706:	e000      	b.n	70a <_ext_irq_enable+0x22>
	uint8_t extint = INVALID_EXTINT_NUMBER;
     708:	22ff      	movs	r2, #255	; 0xff
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
     70a:	2aff      	cmp	r2, #255	; 0xff
     70c:	d00e      	beq.n	72c <_ext_irq_enable+0x44>
		return ERR_INVALID_ARG;
	}

	if (enable) {
     70e:	2900      	cmp	r1, #0
     710:	d106      	bne.n	720 <_ext_irq_enable+0x38>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
     712:	2301      	movs	r3, #1
     714:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENCLR.reg = mask;
     716:	4a08      	ldr	r2, [pc, #32]	; (738 <_ext_irq_enable+0x50>)
     718:	6093      	str	r3, [r2, #8]
	((Eic *)hw)->INTFLAG.reg = mask;
     71a:	6113      	str	r3, [r2, #16]
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
	}

	return ERR_NONE;
     71c:	2000      	movs	r0, #0
}
     71e:	bd30      	pop	{r4, r5, pc}
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
     720:	2301      	movs	r3, #1
     722:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENSET.reg = mask;
     724:	4a04      	ldr	r2, [pc, #16]	; (738 <_ext_irq_enable+0x50>)
     726:	60d3      	str	r3, [r2, #12]
	return ERR_NONE;
     728:	2000      	movs	r0, #0
     72a:	e7f8      	b.n	71e <_ext_irq_enable+0x36>
		return ERR_INVALID_ARG;
     72c:	200d      	movs	r0, #13
     72e:	4240      	negs	r0, r0
     730:	e7f5      	b.n	71e <_ext_irq_enable+0x36>
     732:	46c0      	nop			; (mov r8, r8)
     734:	00002ccc 	.word	0x00002ccc
     738:	40001800 	.word	0x40001800

0000073c <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
     73c:	b5f0      	push	{r4, r5, r6, r7, lr}
     73e:	b083      	sub	sp, #12
	return ((Eic *)hw)->INTFLAG.reg;
     740:	4b27      	ldr	r3, [pc, #156]	; (7e0 <EIC_Handler+0xa4>)
     742:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     744:	68d9      	ldr	r1, [r3, #12]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     746:	400a      	ands	r2, r1
     748:	9201      	str	r2, [sp, #4]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;

	hri_eic_clear_INTFLAG_reg(EIC, flags);
     74a:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     74c:	611a      	str	r2, [r3, #16]

	ASSERT(callback);
     74e:	4b25      	ldr	r3, [pc, #148]	; (7e4 <EIC_Handler+0xa8>)
     750:	6818      	ldr	r0, [r3, #0]
     752:	1e43      	subs	r3, r0, #1
     754:	4198      	sbcs	r0, r3
     756:	b2c0      	uxtb	r0, r0
     758:	22d2      	movs	r2, #210	; 0xd2
     75a:	4923      	ldr	r1, [pc, #140]	; (7e8 <EIC_Handler+0xac>)
     75c:	4b23      	ldr	r3, [pc, #140]	; (7ec <EIC_Handler+0xb0>)
     75e:	4798      	blx	r3
	uint32_t          pin = INVALID_PIN_NUMBER;
     760:	2501      	movs	r5, #1
     762:	426d      	negs	r5, r5

	while (flags) {
     764:	e031      	b.n	7ca <EIC_Handler+0x8e>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;

			while (upper >= lower) {
				middle = (upper + lower) >> 1;
				if (_map[middle].extint == pos) {
					pin = _map[middle].pin;
     766:	00db      	lsls	r3, r3, #3
     768:	4a21      	ldr	r2, [pc, #132]	; (7f0 <EIC_Handler+0xb4>)
     76a:	18d3      	adds	r3, r2, r3
     76c:	685d      	ldr	r5, [r3, #4]
				} else {
					upper = middle - 1;
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
     76e:	1c6b      	adds	r3, r5, #1
     770:	d003      	beq.n	77a <EIC_Handler+0x3e>
				callback(pin);
     772:	4b1c      	ldr	r3, [pc, #112]	; (7e4 <EIC_Handler+0xa8>)
     774:	681b      	ldr	r3, [r3, #0]
     776:	0028      	movs	r0, r5
     778:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
     77a:	2201      	movs	r2, #1
     77c:	40a2      	lsls	r2, r4
     77e:	9b01      	ldr	r3, [sp, #4]
     780:	4393      	bics	r3, r2
     782:	9301      	str	r3, [sp, #4]
			pos = ffs(flags) - 1;
     784:	9801      	ldr	r0, [sp, #4]
     786:	4b1b      	ldr	r3, [pc, #108]	; (7f4 <EIC_Handler+0xb8>)
     788:	4798      	blx	r3
     78a:	3801      	subs	r0, #1
     78c:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     78e:	1c63      	adds	r3, r4, #1
     790:	d014      	beq.n	7bc <EIC_Handler+0x80>
     792:	2602      	movs	r6, #2
     794:	2000      	movs	r0, #0
     796:	e001      	b.n	79c <EIC_Handler+0x60>
					upper = middle - 1;
     798:	3901      	subs	r1, #1
     79a:	b2ce      	uxtb	r6, r1
			while (upper >= lower) {
     79c:	42b0      	cmp	r0, r6
     79e:	d8e6      	bhi.n	76e <EIC_Handler+0x32>
				middle = (upper + lower) >> 1;
     7a0:	1833      	adds	r3, r6, r0
     7a2:	105b      	asrs	r3, r3, #1
     7a4:	b2d9      	uxtb	r1, r3
     7a6:	22ff      	movs	r2, #255	; 0xff
     7a8:	4013      	ands	r3, r2
				if (_map[middle].extint == pos) {
     7aa:	00df      	lsls	r7, r3, #3
     7ac:	4a10      	ldr	r2, [pc, #64]	; (7f0 <EIC_Handler+0xb4>)
     7ae:	5cba      	ldrb	r2, [r7, r2]
     7b0:	42a2      	cmp	r2, r4
     7b2:	d0d8      	beq.n	766 <EIC_Handler+0x2a>
				if (_map[middle].extint < pos) {
     7b4:	daf0      	bge.n	798 <EIC_Handler+0x5c>
					lower = middle + 1;
     7b6:	3101      	adds	r1, #1
     7b8:	b2c8      	uxtb	r0, r1
     7ba:	e7ef      	b.n	79c <EIC_Handler+0x60>
	return ((Eic *)hw)->INTFLAG.reg;
     7bc:	4b08      	ldr	r3, [pc, #32]	; (7e0 <EIC_Handler+0xa4>)
     7be:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     7c0:	68d9      	ldr	r1, [r3, #12]
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     7c2:	400a      	ands	r2, r1
     7c4:	9201      	str	r2, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
     7c6:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     7c8:	611a      	str	r2, [r3, #16]
	while (flags) {
     7ca:	9b01      	ldr	r3, [sp, #4]
     7cc:	2b00      	cmp	r3, #0
     7ce:	d005      	beq.n	7dc <EIC_Handler+0xa0>
		pos = ffs(flags) - 1;
     7d0:	9801      	ldr	r0, [sp, #4]
     7d2:	4b08      	ldr	r3, [pc, #32]	; (7f4 <EIC_Handler+0xb8>)
     7d4:	4798      	blx	r3
     7d6:	3801      	subs	r0, #1
     7d8:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     7da:	e7d8      	b.n	78e <EIC_Handler+0x52>
	}
}
     7dc:	b003      	add	sp, #12
     7de:	bdf0      	pop	{r4, r5, r6, r7, pc}
     7e0:	40001800 	.word	0x40001800
     7e4:	20000048 	.word	0x20000048
     7e8:	00002cb4 	.word	0x00002cb4
     7ec:	00000601 	.word	0x00000601
     7f0:	00002ccc 	.word	0x00002ccc
     7f4:	00002bbd 	.word	0x00002bbd

000007f8 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     7f8:	07c3      	lsls	r3, r0, #31
     7fa:	d509      	bpl.n	810 <_gclk_init_generators_by_fref+0x18>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
     7fc:	4b0b      	ldr	r3, [pc, #44]	; (82c <_gclk_init_generators_by_fref+0x34>)
     7fe:	2280      	movs	r2, #128	; 0x80
     800:	0052      	lsls	r2, r2, #1
     802:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     804:	4a0a      	ldr	r2, [pc, #40]	; (830 <_gclk_init_generators_by_fref+0x38>)
     806:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     808:	4b08      	ldr	r3, [pc, #32]	; (82c <_gclk_init_generators_by_fref+0x34>)
     80a:	785b      	ldrb	r3, [r3, #1]
     80c:	09db      	lsrs	r3, r3, #7
     80e:	d1fb      	bne.n	808 <_gclk_init_generators_by_fref+0x10>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
     810:	0703      	lsls	r3, r0, #28
     812:	d509      	bpl.n	828 <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENDIV.reg = data;
     814:	4b05      	ldr	r3, [pc, #20]	; (82c <_gclk_init_generators_by_fref+0x34>)
     816:	2204      	movs	r2, #4
     818:	32ff      	adds	r2, #255	; 0xff
     81a:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     81c:	4a05      	ldr	r2, [pc, #20]	; (834 <_gclk_init_generators_by_fref+0x3c>)
     81e:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     820:	4b02      	ldr	r3, [pc, #8]	; (82c <_gclk_init_generators_by_fref+0x34>)
     822:	785b      	ldrb	r3, [r3, #1]
     824:	09db      	lsrs	r3, r3, #7
     826:	d1fb      	bne.n	820 <_gclk_init_generators_by_fref+0x28>
		        | (CONF_GCLK_GEN_7_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_7_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_7_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_7_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_7_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
	}
#endif
}
     828:	4770      	bx	lr
     82a:	46c0      	nop			; (mov r8, r8)
     82c:	40000c00 	.word	0x40000c00
     830:	00090700 	.word	0x00090700
     834:	00090303 	.word	0x00090303

00000838 <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
     838:	4b06      	ldr	r3, [pc, #24]	; (854 <_pm_init+0x1c>)
     83a:	7a1a      	ldrb	r2, [r3, #8]
     83c:	b2d2      	uxtb	r2, r2
     83e:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
     840:	7a5a      	ldrb	r2, [r3, #9]
     842:	b2d2      	uxtb	r2, r2
     844:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
     846:	7a9a      	ldrb	r2, [r3, #10]
     848:	b2d2      	uxtb	r2, r2
     84a:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
     84c:	7ada      	ldrb	r2, [r3, #11]
     84e:	b2d2      	uxtb	r2, r2
     850:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
     852:	4770      	bx	lr
     854:	40000400 	.word	0x40000400

00000858 <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
     858:	4b02      	ldr	r3, [pc, #8]	; (864 <_sercom_get_hardware_index+0xc>)
     85a:	469c      	mov	ip, r3
     85c:	4460      	add	r0, ip
     85e:	0a80      	lsrs	r0, r0, #10
     860:	b2c0      	uxtb	r0, r0
}
     862:	4770      	bx	lr
     864:	bdfff800 	.word	0xbdfff800

00000868 <_spi_sync_enable>:
		;
}

static inline bool hri_sercomspi_is_syncing(const void *const hw)
{
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
     868:	8a03      	ldrh	r3, [r0, #16]
     86a:	0bdb      	lsrs	r3, r3, #15
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw)) {
     86c:	d108      	bne.n	880 <_spi_sync_enable+0x18>
}

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
     86e:	6803      	ldr	r3, [r0, #0]
     870:	2202      	movs	r2, #2
     872:	4313      	orrs	r3, r2
     874:	6003      	str	r3, [r0, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     876:	8a03      	ldrh	r3, [r0, #16]
     878:	0bdb      	lsrs	r3, r3, #15
     87a:	d1fc      	bne.n	876 <_spi_sync_enable+0xe>
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
     87c:	2000      	movs	r0, #0
}
     87e:	4770      	bx	lr
		return ERR_BUSY;
     880:	2004      	movs	r0, #4
     882:	4240      	negs	r0, r0
     884:	e7fb      	b.n	87e <_spi_sync_enable+0x16>
	...

00000888 <_get_i2cm_index>:
{
     888:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     88a:	4b0b      	ldr	r3, [pc, #44]	; (8b8 <_get_i2cm_index+0x30>)
     88c:	4798      	blx	r3
     88e:	0002      	movs	r2, r0
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     890:	2000      	movs	r0, #0
     892:	2800      	cmp	r0, #0
     894:	d006      	beq.n	8a4 <_get_i2cm_index+0x1c>
	ASSERT(false);
     896:	4a09      	ldr	r2, [pc, #36]	; (8bc <_get_i2cm_index+0x34>)
     898:	4909      	ldr	r1, [pc, #36]	; (8c0 <_get_i2cm_index+0x38>)
     89a:	2000      	movs	r0, #0
     89c:	4b09      	ldr	r3, [pc, #36]	; (8c4 <_get_i2cm_index+0x3c>)
     89e:	4798      	blx	r3
	return 0;
     8a0:	2000      	movs	r0, #0
}
     8a2:	bd10      	pop	{r4, pc}
		if (_i2cms[i].number == sercom_offset) {
     8a4:	0043      	lsls	r3, r0, #1
     8a6:	181b      	adds	r3, r3, r0
     8a8:	00d9      	lsls	r1, r3, #3
     8aa:	4b07      	ldr	r3, [pc, #28]	; (8c8 <_get_i2cm_index+0x40>)
     8ac:	5ccb      	ldrb	r3, [r1, r3]
     8ae:	429a      	cmp	r2, r3
     8b0:	d0f7      	beq.n	8a2 <_get_i2cm_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     8b2:	3001      	adds	r0, #1
     8b4:	b2c0      	uxtb	r0, r0
     8b6:	e7ec      	b.n	892 <_get_i2cm_index+0xa>
     8b8:	00000859 	.word	0x00000859
     8bc:	00000366 	.word	0x00000366
     8c0:	00002cdc 	.word	0x00002cdc
     8c4:	00000601 	.word	0x00000601
     8c8:	00002cf8 	.word	0x00002cf8

000008cc <_sercom_i2c_sync_send_address>:
{
     8cc:	b570      	push	{r4, r5, r6, lr}
     8ce:	0005      	movs	r5, r0
	void *             hw  = i2c_dev->hw;
     8d0:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
     8d2:	1e43      	subs	r3, r0, #1
     8d4:	4198      	sbcs	r0, r3
     8d6:	b2c0      	uxtb	r0, r0
     8d8:	4a5c      	ldr	r2, [pc, #368]	; (a4c <_sercom_i2c_sync_send_address+0x180>)
     8da:	495d      	ldr	r1, [pc, #372]	; (a50 <_sercom_i2c_sync_send_address+0x184>)
     8dc:	4b5d      	ldr	r3, [pc, #372]	; (a54 <_sercom_i2c_sync_send_address+0x188>)
     8de:	4798      	blx	r3
}

static inline void hri_sercomi2cm_clear_CTRLB_ACKACT_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     8e0:	6863      	ldr	r3, [r4, #4]
     8e2:	4a5d      	ldr	r2, [pc, #372]	; (a58 <_sercom_i2c_sync_send_address+0x18c>)
     8e4:	4013      	ands	r3, r2
     8e6:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     8e8:	8a23      	ldrh	r3, [r4, #16]
     8ea:	0bdb      	lsrs	r3, r3, #15
     8ec:	d1fc      	bne.n	8e8 <_sercom_i2c_sync_send_address+0x1c>
	hri_sercomi2cm_write_ADDR_reg(hw, ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0));
     8ee:	882a      	ldrh	r2, [r5, #0]
     8f0:	0052      	lsls	r2, r2, #1
     8f2:	886b      	ldrh	r3, [r5, #2]
     8f4:	2101      	movs	r1, #1
     8f6:	400b      	ands	r3, r1
     8f8:	4313      	orrs	r3, r2
     8fa:	b2db      	uxtb	r3, r3
}

static inline void hri_sercomi2cm_write_ADDR_reg(const void *const hw, hri_sercomi2cm_addr_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.ADDR.reg = data;
     8fc:	7523      	strb	r3, [r4, #20]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     8fe:	8a23      	ldrh	r3, [r4, #16]
     900:	0bdb      	lsrs	r3, r3, #15
     902:	d1fc      	bne.n	8fe <_sercom_i2c_sync_send_address+0x32>
	void *   hw      = i2c_dev->hw;
     904:	692e      	ldr	r6, [r5, #16]
	uint32_t timeout = 65535;
     906:	4a55      	ldr	r2, [pc, #340]	; (a5c <_sercom_i2c_sync_send_address+0x190>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
     908:	7bb3      	ldrb	r3, [r6, #14]
     90a:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
     90c:	0018      	movs	r0, r3
		if (timeout-- == 0) {
     90e:	1e51      	subs	r1, r2, #1
     910:	2a00      	cmp	r2, #0
     912:	d002      	beq.n	91a <_sercom_i2c_sync_send_address+0x4e>
     914:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
     916:	079b      	lsls	r3, r3, #30
     918:	d0f6      	beq.n	908 <_sercom_i2c_sync_send_address+0x3c>
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     91a:	8a23      	ldrh	r3, [r4, #16]
     91c:	0bdb      	lsrs	r3, r3, #15
     91e:	d1fc      	bne.n	91a <_sercom_i2c_sync_send_address+0x4e>
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw);
	return ((Sercom *)hw)->I2CM.STATUS.reg;
     920:	8a23      	ldrh	r3, [r4, #16]
     922:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
     924:	07c2      	lsls	r2, r0, #31
     926:	d550      	bpl.n	9ca <_sercom_i2c_sync_send_address+0xfe>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
     928:	079a      	lsls	r2, r3, #30
     92a:	d510      	bpl.n	94e <_sercom_i2c_sync_send_address+0x82>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
     92c:	2201      	movs	r2, #1
     92e:	73a2      	strb	r2, [r4, #14]
			msg->flags |= I2C_M_FAIL;
     930:	886a      	ldrh	r2, [r5, #2]
     932:	2180      	movs	r1, #128	; 0x80
     934:	0149      	lsls	r1, r1, #5
     936:	430a      	orrs	r2, r1
     938:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
     93a:	886a      	ldrh	r2, [r5, #2]
     93c:	4948      	ldr	r1, [pc, #288]	; (a60 <_sercom_i2c_sync_send_address+0x194>)
     93e:	400a      	ands	r2, r1
     940:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
     942:	07db      	lsls	r3, r3, #31
     944:	d400      	bmi.n	948 <_sercom_i2c_sync_send_address+0x7c>
     946:	e07c      	b.n	a42 <_sercom_i2c_sync_send_address+0x176>
				return I2C_ERR_BUS;
     948:	2005      	movs	r0, #5
     94a:	4240      	negs	r0, r0
     94c:	e063      	b.n	a16 <_sercom_i2c_sync_send_address+0x14a>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
     94e:	075b      	lsls	r3, r3, #29
     950:	d40b      	bmi.n	96a <_sercom_i2c_sync_send_address+0x9e>
			if (msg->len == 0) {
     952:	6868      	ldr	r0, [r5, #4]
     954:	2800      	cmp	r0, #0
     956:	d12d      	bne.n	9b4 <_sercom_i2c_sync_send_address+0xe8>
				if (msg->flags & I2C_M_STOP) {
     958:	886b      	ldrh	r3, [r5, #2]
     95a:	b21b      	sxth	r3, r3
     95c:	2b00      	cmp	r3, #0
     95e:	db20      	blt.n	9a2 <_sercom_i2c_sync_send_address+0xd6>
				msg->flags &= ~I2C_M_BUSY;
     960:	886b      	ldrh	r3, [r5, #2]
     962:	4a3f      	ldr	r2, [pc, #252]	; (a60 <_sercom_i2c_sync_send_address+0x194>)
     964:	4013      	ands	r3, r2
     966:	806b      	strh	r3, [r5, #2]
     968:	e055      	b.n	a16 <_sercom_i2c_sync_send_address+0x14a>
				if (msg->len > 0) {
     96a:	686b      	ldr	r3, [r5, #4]
     96c:	2b00      	cmp	r3, #0
     96e:	dd04      	ble.n	97a <_sercom_i2c_sync_send_address+0xae>
					msg->flags |= I2C_M_FAIL;
     970:	886b      	ldrh	r3, [r5, #2]
     972:	2280      	movs	r2, #128	; 0x80
     974:	0152      	lsls	r2, r2, #5
     976:	4313      	orrs	r3, r2
     978:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
     97a:	886b      	ldrh	r3, [r5, #2]
     97c:	b21b      	sxth	r3, r3
     97e:	2b00      	cmp	r3, #0
     980:	db06      	blt.n	990 <_sercom_i2c_sync_send_address+0xc4>
				msg->flags &= ~I2C_M_BUSY;
     982:	886b      	ldrh	r3, [r5, #2]
     984:	4a36      	ldr	r2, [pc, #216]	; (a60 <_sercom_i2c_sync_send_address+0x194>)
     986:	4013      	ands	r3, r2
     988:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
     98a:	2002      	movs	r0, #2
     98c:	4240      	negs	r0, r0
     98e:	e042      	b.n	a16 <_sercom_i2c_sync_send_address+0x14a>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     990:	6862      	ldr	r2, [r4, #4]
     992:	23c0      	movs	r3, #192	; 0xc0
     994:	029b      	lsls	r3, r3, #10
     996:	4313      	orrs	r3, r2
     998:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     99a:	8a23      	ldrh	r3, [r4, #16]
     99c:	0bdb      	lsrs	r3, r3, #15
     99e:	d1fc      	bne.n	99a <_sercom_i2c_sync_send_address+0xce>
     9a0:	e7ef      	b.n	982 <_sercom_i2c_sync_send_address+0xb6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     9a2:	6862      	ldr	r2, [r4, #4]
     9a4:	23c0      	movs	r3, #192	; 0xc0
     9a6:	029b      	lsls	r3, r3, #10
     9a8:	4313      	orrs	r3, r2
     9aa:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     9ac:	8a23      	ldrh	r3, [r4, #16]
     9ae:	0bdb      	lsrs	r3, r3, #15
     9b0:	d1fc      	bne.n	9ac <_sercom_i2c_sync_send_address+0xe0>
     9b2:	e7d5      	b.n	960 <_sercom_i2c_sync_send_address+0x94>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
     9b4:	68ab      	ldr	r3, [r5, #8]
     9b6:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
     9b8:	7623      	strb	r3, [r4, #24]
				msg->buffer++;
     9ba:	68ab      	ldr	r3, [r5, #8]
     9bc:	3301      	adds	r3, #1
     9be:	60ab      	str	r3, [r5, #8]
				msg->len--;
     9c0:	686b      	ldr	r3, [r5, #4]
     9c2:	3b01      	subs	r3, #1
     9c4:	606b      	str	r3, [r5, #4]
			return I2C_OK;
     9c6:	2000      	movs	r0, #0
     9c8:	e025      	b.n	a16 <_sercom_i2c_sync_send_address+0x14a>
	} else if (flags & SB_FLAG) {
     9ca:	0782      	lsls	r2, r0, #30
     9cc:	d53c      	bpl.n	a48 <_sercom_i2c_sync_send_address+0x17c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
     9ce:	686a      	ldr	r2, [r5, #4]
     9d0:	2a00      	cmp	r2, #0
     9d2:	d031      	beq.n	a38 <_sercom_i2c_sync_send_address+0x16c>
     9d4:	075b      	lsls	r3, r3, #29
     9d6:	d42f      	bmi.n	a38 <_sercom_i2c_sync_send_address+0x16c>
			msg->len--;
     9d8:	3a01      	subs	r2, #1
     9da:	606a      	str	r2, [r5, #4]
			if (msg->len == 0) {
     9dc:	2a00      	cmp	r2, #0
     9de:	d107      	bne.n	9f0 <_sercom_i2c_sync_send_address+0x124>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     9e0:	6862      	ldr	r2, [r4, #4]
     9e2:	2380      	movs	r3, #128	; 0x80
     9e4:	02db      	lsls	r3, r3, #11
     9e6:	4313      	orrs	r3, r2
     9e8:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     9ea:	8a23      	ldrh	r3, [r4, #16]
     9ec:	0bdb      	lsrs	r3, r3, #15
     9ee:	d1fc      	bne.n	9ea <_sercom_i2c_sync_send_address+0x11e>
			if (msg->len == 0) {
     9f0:	686b      	ldr	r3, [r5, #4]
     9f2:	2b00      	cmp	r3, #0
     9f4:	d107      	bne.n	a06 <_sercom_i2c_sync_send_address+0x13a>
				if (msg->flags & I2C_M_STOP) {
     9f6:	886b      	ldrh	r3, [r5, #2]
     9f8:	b21b      	sxth	r3, r3
     9fa:	2b00      	cmp	r3, #0
     9fc:	db0c      	blt.n	a18 <_sercom_i2c_sync_send_address+0x14c>
				msg->flags &= ~I2C_M_BUSY;
     9fe:	886b      	ldrh	r3, [r5, #2]
     a00:	4a17      	ldr	r2, [pc, #92]	; (a60 <_sercom_i2c_sync_send_address+0x194>)
     a02:	4013      	ands	r3, r2
     a04:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
     a06:	68ab      	ldr	r3, [r5, #8]
     a08:	1c5a      	adds	r2, r3, #1
     a0a:	60aa      	str	r2, [r5, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
     a0c:	7e22      	ldrb	r2, [r4, #24]
     a0e:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     a10:	2302      	movs	r3, #2
     a12:	73a3      	strb	r3, [r4, #14]
	return I2C_OK;
     a14:	2000      	movs	r0, #0
}
     a16:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
     a18:	6863      	ldr	r3, [r4, #4]
     a1a:	4a11      	ldr	r2, [pc, #68]	; (a60 <_sercom_i2c_sync_send_address+0x194>)
     a1c:	4013      	ands	r3, r2
     a1e:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     a20:	8a23      	ldrh	r3, [r4, #16]
     a22:	0bdb      	lsrs	r3, r3, #15
     a24:	d1fc      	bne.n	a20 <_sercom_i2c_sync_send_address+0x154>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     a26:	6862      	ldr	r2, [r4, #4]
     a28:	23c0      	movs	r3, #192	; 0xc0
     a2a:	029b      	lsls	r3, r3, #10
     a2c:	4313      	orrs	r3, r2
     a2e:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     a30:	8a23      	ldrh	r3, [r4, #16]
     a32:	0bdb      	lsrs	r3, r3, #15
     a34:	d1fc      	bne.n	a30 <_sercom_i2c_sync_send_address+0x164>
     a36:	e7e2      	b.n	9fe <_sercom_i2c_sync_send_address+0x132>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     a38:	2302      	movs	r3, #2
     a3a:	73a3      	strb	r3, [r4, #14]
			return I2C_NACK;
     a3c:	2002      	movs	r0, #2
     a3e:	4240      	negs	r0, r0
     a40:	e7e9      	b.n	a16 <_sercom_i2c_sync_send_address+0x14a>
			return I2C_ERR_BAD_ADDRESS;
     a42:	2004      	movs	r0, #4
     a44:	4240      	negs	r0, r0
     a46:	e7e6      	b.n	a16 <_sercom_i2c_sync_send_address+0x14a>
	return I2C_OK;
     a48:	2000      	movs	r0, #0
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
     a4a:	e7e4      	b.n	a16 <_sercom_i2c_sync_send_address+0x14a>
     a4c:	00000581 	.word	0x00000581
     a50:	00002cdc 	.word	0x00002cdc
     a54:	00000601 	.word	0x00000601
     a58:	fffbffff 	.word	0xfffbffff
     a5c:	0000ffff 	.word	0x0000ffff
     a60:	fffffeff 	.word	0xfffffeff

00000a64 <_i2c_m_sync_init>:
{
     a64:	b570      	push	{r4, r5, r6, lr}
     a66:	0006      	movs	r6, r0
     a68:	000c      	movs	r4, r1
	uint8_t i = _get_i2cm_index(hw);
     a6a:	0008      	movs	r0, r1
     a6c:	4b23      	ldr	r3, [pc, #140]	; (afc <_i2c_m_sync_init+0x98>)
     a6e:	4798      	blx	r3
     a70:	0005      	movs	r5, r0
	ASSERT(i2c_dev);
     a72:	0030      	movs	r0, r6
     a74:	1e43      	subs	r3, r0, #1
     a76:	4198      	sbcs	r0, r3
     a78:	b2c0      	uxtb	r0, r0
     a7a:	4a21      	ldr	r2, [pc, #132]	; (b00 <_i2c_m_sync_init+0x9c>)
     a7c:	4921      	ldr	r1, [pc, #132]	; (b04 <_i2c_m_sync_init+0xa0>)
     a7e:	4b22      	ldr	r3, [pc, #136]	; (b08 <_i2c_m_sync_init+0xa4>)
     a80:	4798      	blx	r3
	i2c_dev->hw = hw;
     a82:	6134      	str	r4, [r6, #16]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     a84:	8a23      	ldrh	r3, [r4, #16]
     a86:	0bdb      	lsrs	r3, r3, #15
     a88:	d1fc      	bne.n	a84 <_i2c_m_sync_init+0x20>
     a8a:	8a23      	ldrh	r3, [r4, #16]
     a8c:	0bdb      	lsrs	r3, r3, #15
     a8e:	d1fc      	bne.n	a8a <_i2c_m_sync_init+0x26>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
     a90:	6823      	ldr	r3, [r4, #0]
	if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
     a92:	079b      	lsls	r3, r3, #30
     a94:	d507      	bpl.n	aa6 <_i2c_m_sync_init+0x42>
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     a96:	2300      	movs	r3, #0
     a98:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     a9a:	8a23      	ldrh	r3, [r4, #16]
     a9c:	0bdb      	lsrs	r3, r3, #15
     a9e:	d1fc      	bne.n	a9a <_i2c_m_sync_init+0x36>
     aa0:	8a23      	ldrh	r3, [r4, #16]
     aa2:	0bdb      	lsrs	r3, r3, #15
     aa4:	d1fc      	bne.n	aa0 <_i2c_m_sync_init+0x3c>
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     aa6:	2301      	movs	r3, #1
     aa8:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     aaa:	8a23      	ldrh	r3, [r4, #16]
     aac:	0bdb      	lsrs	r3, r3, #15
     aae:	d1fc      	bne.n	aaa <_i2c_m_sync_init+0x46>
     ab0:	8a23      	ldrh	r3, [r4, #16]
     ab2:	0bdb      	lsrs	r3, r3, #15
     ab4:	d1fc      	bne.n	ab0 <_i2c_m_sync_init+0x4c>
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a & ~SERCOM_I2CM_CTRLA_ENABLE);
     ab6:	006b      	lsls	r3, r5, #1
     ab8:	195b      	adds	r3, r3, r5
     aba:	00da      	lsls	r2, r3, #3
     abc:	4b13      	ldr	r3, [pc, #76]	; (b0c <_i2c_m_sync_init+0xa8>)
     abe:	189b      	adds	r3, r3, r2
     ac0:	685b      	ldr	r3, [r3, #4]
     ac2:	2202      	movs	r2, #2
     ac4:	4393      	bics	r3, r2
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     ac6:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     ac8:	8a23      	ldrh	r3, [r4, #16]
     aca:	0bdb      	lsrs	r3, r3, #15
     acc:	d1fc      	bne.n	ac8 <_i2c_m_sync_init+0x64>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
     ace:	006b      	lsls	r3, r5, #1
     ad0:	195b      	adds	r3, r3, r5
     ad2:	00da      	lsls	r2, r3, #3
     ad4:	4b0d      	ldr	r3, [pc, #52]	; (b0c <_i2c_m_sync_init+0xa8>)
     ad6:	189b      	adds	r3, r3, r2
     ad8:	689b      	ldr	r3, [r3, #8]
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
     ada:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     adc:	8a23      	ldrh	r3, [r4, #16]
     ade:	0bdb      	lsrs	r3, r3, #15
     ae0:	d1fc      	bne.n	adc <_i2c_m_sync_init+0x78>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
     ae2:	4a0a      	ldr	r2, [pc, #40]	; (b0c <_i2c_m_sync_init+0xa8>)
     ae4:	006b      	lsls	r3, r5, #1
     ae6:	1958      	adds	r0, r3, r5
     ae8:	00c1      	lsls	r1, r0, #3
     aea:	0008      	movs	r0, r1
     aec:	1851      	adds	r1, r2, r1
     aee:	8989      	ldrh	r1, [r1, #12]
	((Sercom *)hw)->I2CM.BAUD.reg = data;
     af0:	8161      	strh	r1, [r4, #10]
	i2c_dev->service.trise = _i2cms[i].trise;
     af2:	1812      	adds	r2, r2, r0
     af4:	8a13      	ldrh	r3, [r2, #16]
     af6:	81f3      	strh	r3, [r6, #14]
}
     af8:	2000      	movs	r0, #0
     afa:	bd70      	pop	{r4, r5, r6, pc}
     afc:	00000889 	.word	0x00000889
     b00:	000004d7 	.word	0x000004d7
     b04:	00002cdc 	.word	0x00002cdc
     b08:	00000601 	.word	0x00000601
     b0c:	00002cf8 	.word	0x00002cf8

00000b10 <_i2c_m_sync_enable>:
{
     b10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     b12:	0006      	movs	r6, r0
	void *hw              = i2c_dev->hw;
     b14:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
     b16:	4d18      	ldr	r5, [pc, #96]	; (b78 <_i2c_m_sync_enable+0x68>)
     b18:	1e43      	subs	r3, r0, #1
     b1a:	4198      	sbcs	r0, r3
     b1c:	b2c0      	uxtb	r0, r0
     b1e:	22a1      	movs	r2, #161	; 0xa1
     b20:	00d2      	lsls	r2, r2, #3
     b22:	0029      	movs	r1, r5
     b24:	4f15      	ldr	r7, [pc, #84]	; (b7c <_i2c_m_sync_enable+0x6c>)
     b26:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
     b28:	6930      	ldr	r0, [r6, #16]
     b2a:	1e43      	subs	r3, r0, #1
     b2c:	4198      	sbcs	r0, r3
     b2e:	b2c0      	uxtb	r0, r0
     b30:	4a13      	ldr	r2, [pc, #76]	; (b80 <_i2c_m_sync_enable+0x70>)
     b32:	0029      	movs	r1, r5
     b34:	47b8      	blx	r7
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
     b36:	6823      	ldr	r3, [r4, #0]
     b38:	2202      	movs	r2, #2
     b3a:	4313      	orrs	r3, r2
     b3c:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     b3e:	8a23      	ldrh	r3, [r4, #16]
     b40:	0bdb      	lsrs	r3, r3, #15
     b42:	d1fc      	bne.n	b3e <_i2c_m_sync_enable+0x2e>
     b44:	2004      	movs	r0, #4
     b46:	490f      	ldr	r1, [pc, #60]	; (b84 <_i2c_m_sync_enable+0x74>)
     b48:	8a23      	ldrh	r3, [r4, #16]
     b4a:	0bdb      	lsrs	r3, r3, #15
     b4c:	d1fc      	bne.n	b48 <_i2c_m_sync_enable+0x38>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
     b4e:	8a22      	ldrh	r2, [r4, #16]
     b50:	0912      	lsrs	r2, r2, #4
     b52:	3303      	adds	r3, #3
     b54:	4013      	ands	r3, r2
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
     b56:	2b01      	cmp	r3, #1
     b58:	d008      	beq.n	b6c <_i2c_m_sync_enable+0x5c>
		timeout--;
     b5a:	3901      	subs	r1, #1
		if (timeout <= 0) {
     b5c:	2900      	cmp	r1, #0
     b5e:	dcf3      	bgt.n	b48 <_i2c_m_sync_enable+0x38>
			if (--timeout_attempt)
     b60:	3801      	subs	r0, #1
     b62:	2800      	cmp	r0, #0
     b64:	d004      	beq.n	b70 <_i2c_m_sync_enable+0x60>
			((Sercom *)hw)->I2CM.STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(I2C_IDLE);
     b66:	2310      	movs	r3, #16
     b68:	8223      	strh	r3, [r4, #16]
     b6a:	e7ec      	b.n	b46 <_i2c_m_sync_enable+0x36>
	return ERR_NONE;
     b6c:	2000      	movs	r0, #0
}
     b6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return I2C_ERR_BUSY;
     b70:	2006      	movs	r0, #6
     b72:	4240      	negs	r0, r0
     b74:	e7fb      	b.n	b6e <_i2c_m_sync_enable+0x5e>
     b76:	46c0      	nop			; (mov r8, r8)
     b78:	00002cdc 	.word	0x00002cdc
     b7c:	00000601 	.word	0x00000601
     b80:	00000509 	.word	0x00000509
     b84:	0000ffff 	.word	0x0000ffff

00000b88 <_i2c_m_sync_transfer>:
{
     b88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     b8a:	0005      	movs	r5, r0
     b8c:	000e      	movs	r6, r1
	void *   hw = i2c_dev->hw;
     b8e:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
     b90:	1e43      	subs	r3, r0, #1
     b92:	4198      	sbcs	r0, r3
     b94:	b2c0      	uxtb	r0, r0
     b96:	4a7b      	ldr	r2, [pc, #492]	; (d84 <_i2c_m_sync_transfer+0x1fc>)
     b98:	497b      	ldr	r1, [pc, #492]	; (d88 <_i2c_m_sync_transfer+0x200>)
     b9a:	4f7c      	ldr	r7, [pc, #496]	; (d8c <_i2c_m_sync_transfer+0x204>)
     b9c:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
     b9e:	6928      	ldr	r0, [r5, #16]
     ba0:	1e43      	subs	r3, r0, #1
     ba2:	4198      	sbcs	r0, r3
     ba4:	b2c0      	uxtb	r0, r0
     ba6:	4a7a      	ldr	r2, [pc, #488]	; (d90 <_i2c_m_sync_transfer+0x208>)
     ba8:	4977      	ldr	r1, [pc, #476]	; (d88 <_i2c_m_sync_transfer+0x200>)
     baa:	47b8      	blx	r7
	ASSERT(msg);
     bac:	0030      	movs	r0, r6
     bae:	1e43      	subs	r3, r0, #1
     bb0:	4198      	sbcs	r0, r3
     bb2:	b2c0      	uxtb	r0, r0
     bb4:	4a77      	ldr	r2, [pc, #476]	; (d94 <_i2c_m_sync_transfer+0x20c>)
     bb6:	4974      	ldr	r1, [pc, #464]	; (d88 <_i2c_m_sync_transfer+0x200>)
     bb8:	47b8      	blx	r7
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
     bba:	886b      	ldrh	r3, [r5, #2]
     bbc:	05db      	lsls	r3, r3, #23
     bbe:	d500      	bpl.n	bc2 <_i2c_m_sync_transfer+0x3a>
     bc0:	e0dc      	b.n	d7c <_i2c_m_sync_transfer+0x1f4>
	msg->flags |= I2C_M_BUSY;
     bc2:	8872      	ldrh	r2, [r6, #2]
     bc4:	2380      	movs	r3, #128	; 0x80
     bc6:	005b      	lsls	r3, r3, #1
     bc8:	469c      	mov	ip, r3
     bca:	431a      	orrs	r2, r3
     bcc:	8072      	strh	r2, [r6, #2]
	i2c_dev->service.msg = *msg;
     bce:	002a      	movs	r2, r5
     bd0:	0031      	movs	r1, r6
     bd2:	c989      	ldmia	r1!, {r0, r3, r7}
     bd4:	c289      	stmia	r2!, {r0, r3, r7}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
     bd6:	6862      	ldr	r2, [r4, #4]
     bd8:	4663      	mov	r3, ip
     bda:	4313      	orrs	r3, r2
     bdc:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     bde:	8a23      	ldrh	r3, [r4, #16]
     be0:	0bdb      	lsrs	r3, r3, #15
     be2:	d1fc      	bne.n	bde <_i2c_m_sync_transfer+0x56>
	ret = _sercom_i2c_sync_send_address(i2c_dev);
     be4:	0028      	movs	r0, r5
     be6:	4b6c      	ldr	r3, [pc, #432]	; (d98 <_i2c_m_sync_transfer+0x210>)
     be8:	4798      	blx	r3
	if (ret) {
     bea:	2800      	cmp	r0, #0
     bec:	d100      	bne.n	bf0 <_i2c_m_sync_transfer+0x68>
     bee:	e07d      	b.n	cec <_i2c_m_sync_transfer+0x164>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
     bf0:	886b      	ldrh	r3, [r5, #2]
     bf2:	4a6a      	ldr	r2, [pc, #424]	; (d9c <_i2c_m_sync_transfer+0x214>)
     bf4:	4013      	ands	r3, r2
     bf6:	806b      	strh	r3, [r5, #2]
}
     bf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return I2C_ERR_BUS;
     bfa:	2005      	movs	r0, #5
     bfc:	4240      	negs	r0, r0
     bfe:	e086      	b.n	d0e <_i2c_m_sync_transfer+0x186>
			if (msg->flags & I2C_M_STOP) {
     c00:	8873      	ldrh	r3, [r6, #2]
     c02:	b21b      	sxth	r3, r3
     c04:	2b00      	cmp	r3, #0
     c06:	db04      	blt.n	c12 <_i2c_m_sync_transfer+0x8a>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
     c08:	886b      	ldrh	r3, [r5, #2]
     c0a:	4a64      	ldr	r2, [pc, #400]	; (d9c <_i2c_m_sync_transfer+0x214>)
     c0c:	4013      	ands	r3, r2
     c0e:	806b      	strh	r3, [r5, #2]
			return ret;
     c10:	e7f2      	b.n	bf8 <_i2c_m_sync_transfer+0x70>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     c12:	6862      	ldr	r2, [r4, #4]
     c14:	23c0      	movs	r3, #192	; 0xc0
     c16:	029b      	lsls	r3, r3, #10
     c18:	4313      	orrs	r3, r2
     c1a:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     c1c:	8a23      	ldrh	r3, [r4, #16]
     c1e:	0bdb      	lsrs	r3, r3, #15
     c20:	d1fc      	bne.n	c1c <_i2c_m_sync_transfer+0x94>
     c22:	e7f1      	b.n	c08 <_i2c_m_sync_transfer+0x80>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
     c24:	075b      	lsls	r3, r3, #29
     c26:	d40b      	bmi.n	c40 <_i2c_m_sync_transfer+0xb8>
			if (msg->len == 0) {
     c28:	6868      	ldr	r0, [r5, #4]
     c2a:	2800      	cmp	r0, #0
     c2c:	d12d      	bne.n	c8a <_i2c_m_sync_transfer+0x102>
				if (msg->flags & I2C_M_STOP) {
     c2e:	886b      	ldrh	r3, [r5, #2]
     c30:	b21b      	sxth	r3, r3
     c32:	2b00      	cmp	r3, #0
     c34:	db20      	blt.n	c78 <_i2c_m_sync_transfer+0xf0>
				msg->flags &= ~I2C_M_BUSY;
     c36:	886b      	ldrh	r3, [r5, #2]
     c38:	4a58      	ldr	r2, [pc, #352]	; (d9c <_i2c_m_sync_transfer+0x214>)
     c3a:	4013      	ands	r3, r2
     c3c:	806b      	strh	r3, [r5, #2]
     c3e:	e055      	b.n	cec <_i2c_m_sync_transfer+0x164>
				if (msg->len > 0) {
     c40:	686b      	ldr	r3, [r5, #4]
     c42:	2b00      	cmp	r3, #0
     c44:	dd04      	ble.n	c50 <_i2c_m_sync_transfer+0xc8>
					msg->flags |= I2C_M_FAIL;
     c46:	886b      	ldrh	r3, [r5, #2]
     c48:	2280      	movs	r2, #128	; 0x80
     c4a:	0152      	lsls	r2, r2, #5
     c4c:	4313      	orrs	r3, r2
     c4e:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
     c50:	886b      	ldrh	r3, [r5, #2]
     c52:	b21b      	sxth	r3, r3
     c54:	2b00      	cmp	r3, #0
     c56:	db06      	blt.n	c66 <_i2c_m_sync_transfer+0xde>
				msg->flags &= ~I2C_M_BUSY;
     c58:	886b      	ldrh	r3, [r5, #2]
     c5a:	4a50      	ldr	r2, [pc, #320]	; (d9c <_i2c_m_sync_transfer+0x214>)
     c5c:	4013      	ands	r3, r2
     c5e:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
     c60:	2002      	movs	r0, #2
     c62:	4240      	negs	r0, r0
     c64:	e042      	b.n	cec <_i2c_m_sync_transfer+0x164>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     c66:	6862      	ldr	r2, [r4, #4]
     c68:	23c0      	movs	r3, #192	; 0xc0
     c6a:	029b      	lsls	r3, r3, #10
     c6c:	4313      	orrs	r3, r2
     c6e:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     c70:	8a23      	ldrh	r3, [r4, #16]
     c72:	0bdb      	lsrs	r3, r3, #15
     c74:	d1fc      	bne.n	c70 <_i2c_m_sync_transfer+0xe8>
     c76:	e7ef      	b.n	c58 <_i2c_m_sync_transfer+0xd0>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     c78:	6862      	ldr	r2, [r4, #4]
     c7a:	23c0      	movs	r3, #192	; 0xc0
     c7c:	029b      	lsls	r3, r3, #10
     c7e:	4313      	orrs	r3, r2
     c80:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     c82:	8a23      	ldrh	r3, [r4, #16]
     c84:	0bdb      	lsrs	r3, r3, #15
     c86:	d1fc      	bne.n	c82 <_i2c_m_sync_transfer+0xfa>
     c88:	e7d5      	b.n	c36 <_i2c_m_sync_transfer+0xae>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
     c8a:	68ab      	ldr	r3, [r5, #8]
     c8c:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
     c8e:	7623      	strb	r3, [r4, #24]
				msg->buffer++;
     c90:	68ab      	ldr	r3, [r5, #8]
     c92:	3301      	adds	r3, #1
     c94:	60ab      	str	r3, [r5, #8]
				msg->len--;
     c96:	686b      	ldr	r3, [r5, #4]
     c98:	3b01      	subs	r3, #1
     c9a:	606b      	str	r3, [r5, #4]
			return I2C_OK;
     c9c:	2000      	movs	r0, #0
     c9e:	e025      	b.n	cec <_i2c_m_sync_transfer+0x164>
	} else if (flags & SB_FLAG) {
     ca0:	078a      	lsls	r2, r1, #30
     ca2:	d569      	bpl.n	d78 <_i2c_m_sync_transfer+0x1f0>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
     ca4:	686a      	ldr	r2, [r5, #4]
     ca6:	2a00      	cmp	r2, #0
     ca8:	d05e      	beq.n	d68 <_i2c_m_sync_transfer+0x1e0>
     caa:	075b      	lsls	r3, r3, #29
     cac:	d45c      	bmi.n	d68 <_i2c_m_sync_transfer+0x1e0>
			msg->len--;
     cae:	3a01      	subs	r2, #1
     cb0:	606a      	str	r2, [r5, #4]
			if (msg->len == 0) {
     cb2:	2a00      	cmp	r2, #0
     cb4:	d107      	bne.n	cc6 <_i2c_m_sync_transfer+0x13e>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     cb6:	6862      	ldr	r2, [r4, #4]
     cb8:	2380      	movs	r3, #128	; 0x80
     cba:	02db      	lsls	r3, r3, #11
     cbc:	4313      	orrs	r3, r2
     cbe:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     cc0:	8a23      	ldrh	r3, [r4, #16]
     cc2:	0bdb      	lsrs	r3, r3, #15
     cc4:	d1fc      	bne.n	cc0 <_i2c_m_sync_transfer+0x138>
			if (msg->len == 0) {
     cc6:	686b      	ldr	r3, [r5, #4]
     cc8:	2b00      	cmp	r3, #0
     cca:	d107      	bne.n	cdc <_i2c_m_sync_transfer+0x154>
				if (msg->flags & I2C_M_STOP) {
     ccc:	886b      	ldrh	r3, [r5, #2]
     cce:	b21b      	sxth	r3, r3
     cd0:	2b00      	cmp	r3, #0
     cd2:	db39      	blt.n	d48 <_i2c_m_sync_transfer+0x1c0>
				msg->flags &= ~I2C_M_BUSY;
     cd4:	886b      	ldrh	r3, [r5, #2]
     cd6:	4a31      	ldr	r2, [pc, #196]	; (d9c <_i2c_m_sync_transfer+0x214>)
     cd8:	4013      	ands	r3, r2
     cda:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
     cdc:	68ab      	ldr	r3, [r5, #8]
     cde:	1c5a      	adds	r2, r3, #1
     ce0:	60aa      	str	r2, [r5, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
     ce2:	7e22      	ldrb	r2, [r4, #24]
     ce4:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     ce6:	2302      	movs	r3, #2
     ce8:	73a3      	strb	r3, [r4, #14]
	return I2C_OK;
     cea:	2000      	movs	r0, #0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
     cec:	886b      	ldrh	r3, [r5, #2]
     cee:	05db      	lsls	r3, r3, #23
     cf0:	d400      	bmi.n	cf4 <_i2c_m_sync_transfer+0x16c>
     cf2:	e781      	b.n	bf8 <_i2c_m_sync_transfer+0x70>
	void *   hw      = i2c_dev->hw;
     cf4:	692f      	ldr	r7, [r5, #16]
	uint32_t timeout = 65535;
     cf6:	4a2a      	ldr	r2, [pc, #168]	; (da0 <_i2c_m_sync_transfer+0x218>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
     cf8:	7bbb      	ldrb	r3, [r7, #14]
     cfa:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
     cfc:	0019      	movs	r1, r3
		if (timeout-- == 0) {
     cfe:	1e50      	subs	r0, r2, #1
     d00:	2a00      	cmp	r2, #0
     d02:	d100      	bne.n	d06 <_i2c_m_sync_transfer+0x17e>
     d04:	e779      	b.n	bfa <_i2c_m_sync_transfer+0x72>
     d06:	0002      	movs	r2, r0
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
     d08:	079b      	lsls	r3, r3, #30
     d0a:	d0f5      	beq.n	cf8 <_i2c_m_sync_transfer+0x170>
	return I2C_OK;
     d0c:	2000      	movs	r0, #0
		if (ret) {
     d0e:	2800      	cmp	r0, #0
     d10:	d000      	beq.n	d14 <_i2c_m_sync_transfer+0x18c>
     d12:	e775      	b.n	c00 <_i2c_m_sync_transfer+0x78>
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     d14:	8a23      	ldrh	r3, [r4, #16]
     d16:	0bdb      	lsrs	r3, r3, #15
     d18:	d1fc      	bne.n	d14 <_i2c_m_sync_transfer+0x18c>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
     d1a:	8a23      	ldrh	r3, [r4, #16]
     d1c:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
     d1e:	07ca      	lsls	r2, r1, #31
     d20:	d5be      	bpl.n	ca0 <_i2c_m_sync_transfer+0x118>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
     d22:	079a      	lsls	r2, r3, #30
     d24:	d400      	bmi.n	d28 <_i2c_m_sync_transfer+0x1a0>
     d26:	e77d      	b.n	c24 <_i2c_m_sync_transfer+0x9c>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
     d28:	2201      	movs	r2, #1
     d2a:	73a2      	strb	r2, [r4, #14]
			msg->flags |= I2C_M_FAIL;
     d2c:	886a      	ldrh	r2, [r5, #2]
     d2e:	2180      	movs	r1, #128	; 0x80
     d30:	0149      	lsls	r1, r1, #5
     d32:	430a      	orrs	r2, r1
     d34:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
     d36:	886a      	ldrh	r2, [r5, #2]
     d38:	4918      	ldr	r1, [pc, #96]	; (d9c <_i2c_m_sync_transfer+0x214>)
     d3a:	400a      	ands	r2, r1
     d3c:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
     d3e:	07db      	lsls	r3, r3, #31
     d40:	d517      	bpl.n	d72 <_i2c_m_sync_transfer+0x1ea>
				return I2C_ERR_BUS;
     d42:	2005      	movs	r0, #5
     d44:	4240      	negs	r0, r0
     d46:	e7d1      	b.n	cec <_i2c_m_sync_transfer+0x164>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
     d48:	6863      	ldr	r3, [r4, #4]
     d4a:	4a14      	ldr	r2, [pc, #80]	; (d9c <_i2c_m_sync_transfer+0x214>)
     d4c:	4013      	ands	r3, r2
     d4e:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     d50:	8a23      	ldrh	r3, [r4, #16]
     d52:	0bdb      	lsrs	r3, r3, #15
     d54:	d1fc      	bne.n	d50 <_i2c_m_sync_transfer+0x1c8>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     d56:	6862      	ldr	r2, [r4, #4]
     d58:	23c0      	movs	r3, #192	; 0xc0
     d5a:	029b      	lsls	r3, r3, #10
     d5c:	4313      	orrs	r3, r2
     d5e:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     d60:	8a23      	ldrh	r3, [r4, #16]
     d62:	0bdb      	lsrs	r3, r3, #15
     d64:	d1fc      	bne.n	d60 <_i2c_m_sync_transfer+0x1d8>
     d66:	e7b5      	b.n	cd4 <_i2c_m_sync_transfer+0x14c>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     d68:	2302      	movs	r3, #2
     d6a:	73a3      	strb	r3, [r4, #14]
			return I2C_NACK;
     d6c:	2002      	movs	r0, #2
     d6e:	4240      	negs	r0, r0
     d70:	e7bc      	b.n	cec <_i2c_m_sync_transfer+0x164>
			return I2C_ERR_BAD_ADDRESS;
     d72:	2004      	movs	r0, #4
     d74:	4240      	negs	r0, r0
     d76:	e7b9      	b.n	cec <_i2c_m_sync_transfer+0x164>
	return I2C_OK;
     d78:	2000      	movs	r0, #0
     d7a:	e7b7      	b.n	cec <_i2c_m_sync_transfer+0x164>
		return I2C_ERR_BUSY;
     d7c:	2006      	movs	r0, #6
     d7e:	4240      	negs	r0, r0
     d80:	e73a      	b.n	bf8 <_i2c_m_sync_transfer+0x70>
     d82:	46c0      	nop			; (mov r8, r8)
     d84:	0000059b 	.word	0x0000059b
     d88:	00002cdc 	.word	0x00002cdc
     d8c:	00000601 	.word	0x00000601
     d90:	0000059c 	.word	0x0000059c
     d94:	0000059d 	.word	0x0000059d
     d98:	000008cd 	.word	0x000008cd
     d9c:	fffffeff 	.word	0xfffffeff
     da0:	0000ffff 	.word	0x0000ffff

00000da4 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
     da4:	b570      	push	{r4, r5, r6, lr}
     da6:	0006      	movs	r6, r0
     da8:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
     daa:	0008      	movs	r0, r1
     dac:	4b61      	ldr	r3, [pc, #388]	; (f34 <_spi_m_sync_init+0x190>)
     dae:	4798      	blx	r3
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
     db0:	2300      	movs	r3, #0
     db2:	2b00      	cmp	r3, #0
     db4:	d100      	bne.n	db8 <_spi_m_sync_init+0x14>
     db6:	e06c      	b.n	e92 <_spi_m_sync_init+0xee>
	return NULL;
     db8:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
     dba:	2e00      	cmp	r6, #0
     dbc:	d100      	bne.n	dc0 <_spi_m_sync_init+0x1c>
     dbe:	e073      	b.n	ea8 <_spi_m_sync_init+0x104>
     dc0:	2c00      	cmp	r4, #0
     dc2:	d100      	bne.n	dc6 <_spi_m_sync_init+0x22>
     dc4:	e06e      	b.n	ea4 <_spi_m_sync_init+0x100>
     dc6:	2001      	movs	r0, #1
     dc8:	4a5b      	ldr	r2, [pc, #364]	; (f38 <_spi_m_sync_init+0x194>)
     dca:	495c      	ldr	r1, [pc, #368]	; (f3c <_spi_m_sync_init+0x198>)
     dcc:	4b5c      	ldr	r3, [pc, #368]	; (f40 <_spi_m_sync_init+0x19c>)
     dce:	4798      	blx	r3

	if (regs == NULL) {
     dd0:	2d00      	cmp	r5, #0
     dd2:	d100      	bne.n	dd6 <_spi_m_sync_init+0x32>
     dd4:	e0ab      	b.n	f2e <_spi_m_sync_init+0x18a>
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     dd6:	8a23      	ldrh	r3, [r4, #16]
     dd8:	0bdb      	lsrs	r3, r3, #15
     dda:	d1fc      	bne.n	dd6 <_spi_m_sync_init+0x32>
     ddc:	8a23      	ldrh	r3, [r4, #16]
     dde:	0bdb      	lsrs	r3, r3, #15
     de0:	d1fc      	bne.n	ddc <_spi_m_sync_init+0x38>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
     de2:	6823      	ldr	r3, [r4, #0]
		return ERR_INVALID_ARG;
	}

	hri_sercomspi_wait_for_sync(hw);
	if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
     de4:	079b      	lsls	r3, r3, #30
     de6:	d507      	bpl.n	df8 <_spi_m_sync_init+0x54>
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     de8:	2300      	movs	r3, #0
     dea:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     dec:	8a23      	ldrh	r3, [r4, #16]
     dee:	0bdb      	lsrs	r3, r3, #15
     df0:	d1fc      	bne.n	dec <_spi_m_sync_init+0x48>
     df2:	8a23      	ldrh	r3, [r4, #16]
     df4:	0bdb      	lsrs	r3, r3, #15
     df6:	d1fc      	bne.n	df2 <_spi_m_sync_init+0x4e>
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     df8:	2301      	movs	r3, #1
     dfa:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     dfc:	8a23      	ldrh	r3, [r4, #16]
     dfe:	0bdb      	lsrs	r3, r3, #15
     e00:	d1fc      	bne.n	dfc <_spi_m_sync_init+0x58>
     e02:	8a23      	ldrh	r3, [r4, #16]
     e04:	0bdb      	lsrs	r3, r3, #15
     e06:	d1fc      	bne.n	e02 <_spi_m_sync_init+0x5e>
		hri_sercomspi_wait_for_sync(hw);
	}
	hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST);
	hri_sercomspi_wait_for_sync(hw);

	dev->prvt = hw;
     e08:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
     e0a:	782b      	ldrb	r3, [r5, #0]
     e0c:	786a      	ldrb	r2, [r5, #1]
     e0e:	0212      	lsls	r2, r2, #8
     e10:	431a      	orrs	r2, r3
     e12:	78ab      	ldrb	r3, [r5, #2]
     e14:	041b      	lsls	r3, r3, #16
     e16:	431a      	orrs	r2, r3
     e18:	78eb      	ldrb	r3, [r5, #3]
     e1a:	061b      	lsls	r3, r3, #24
     e1c:	4313      	orrs	r3, r2
     e1e:	221c      	movs	r2, #28
     e20:	4013      	ands	r3, r2
     e22:	2b08      	cmp	r3, #8
     e24:	d042      	beq.n	eac <_spi_m_sync_init+0x108>
	ASSERT(hw && regs);
     e26:	2c00      	cmp	r4, #0
     e28:	d100      	bne.n	e2c <_spi_m_sync_init+0x88>
     e2a:	e07c      	b.n	f26 <_spi_m_sync_init+0x182>
     e2c:	2d00      	cmp	r5, #0
     e2e:	d100      	bne.n	e32 <_spi_m_sync_init+0x8e>
     e30:	e077      	b.n	f22 <_spi_m_sync_init+0x17e>
     e32:	2001      	movs	r0, #1
     e34:	4a43      	ldr	r2, [pc, #268]	; (f44 <_spi_m_sync_init+0x1a0>)
     e36:	4941      	ldr	r1, [pc, #260]	; (f3c <_spi_m_sync_init+0x198>)
     e38:	4b41      	ldr	r3, [pc, #260]	; (f40 <_spi_m_sync_init+0x19c>)
     e3a:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
     e3c:	782b      	ldrb	r3, [r5, #0]
     e3e:	786a      	ldrb	r2, [r5, #1]
     e40:	0212      	lsls	r2, r2, #8
     e42:	431a      	orrs	r2, r3
     e44:	78ab      	ldrb	r3, [r5, #2]
     e46:	041b      	lsls	r3, r3, #16
     e48:	431a      	orrs	r2, r3
     e4a:	78eb      	ldrb	r3, [r5, #3]
     e4c:	061b      	lsls	r3, r3, #24
     e4e:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
     e50:	4a3d      	ldr	r2, [pc, #244]	; (f48 <_spi_m_sync_init+0x1a4>)
     e52:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     e54:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     e56:	8a23      	ldrh	r3, [r4, #16]
     e58:	0bdb      	lsrs	r3, r3, #15
     e5a:	d1fc      	bne.n	e56 <_spi_m_sync_init+0xb2>
	    hw, (regs->ctrlb & ~(SERCOM_SPI_CTRLB_AMODE_Msk | SERCOM_SPI_CTRLB_PLOADEN)) | (SERCOM_SPI_CTRLB_RXEN));
     e5c:	792b      	ldrb	r3, [r5, #4]
     e5e:	796a      	ldrb	r2, [r5, #5]
     e60:	0212      	lsls	r2, r2, #8
     e62:	431a      	orrs	r2, r3
     e64:	79ab      	ldrb	r3, [r5, #6]
     e66:	041b      	lsls	r3, r3, #16
     e68:	431a      	orrs	r2, r3
     e6a:	79eb      	ldrb	r3, [r5, #7]
     e6c:	061b      	lsls	r3, r3, #24
     e6e:	4313      	orrs	r3, r2
     e70:	4a36      	ldr	r2, [pc, #216]	; (f4c <_spi_m_sync_init+0x1a8>)
     e72:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
     e74:	2280      	movs	r2, #128	; 0x80
     e76:	0292      	lsls	r2, r2, #10
     e78:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
     e7a:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
     e7c:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
     e7e:	72a3      	strb	r3, [r4, #10]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
     e80:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
     e82:	7223      	strb	r3, [r4, #8]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
     e84:	792b      	ldrb	r3, [r5, #4]
     e86:	075b      	lsls	r3, r3, #29
     e88:	d14f      	bne.n	f2a <_spi_m_sync_init+0x186>
     e8a:	2301      	movs	r3, #1
     e8c:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
     e8e:	2000      	movs	r0, #0
}
     e90:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
     e92:	2800      	cmp	r0, #0
     e94:	d002      	beq.n	e9c <_spi_m_sync_init+0xf8>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
     e96:	3301      	adds	r3, #1
     e98:	b2db      	uxtb	r3, r3
     e9a:	e78a      	b.n	db2 <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
     e9c:	011d      	lsls	r5, r3, #4
     e9e:	4b2c      	ldr	r3, [pc, #176]	; (f50 <_spi_m_sync_init+0x1ac>)
     ea0:	195d      	adds	r5, r3, r5
     ea2:	e78a      	b.n	dba <_spi_m_sync_init+0x16>
	ASSERT(dev && hw);
     ea4:	2000      	movs	r0, #0
     ea6:	e78f      	b.n	dc8 <_spi_m_sync_init+0x24>
     ea8:	2000      	movs	r0, #0
     eaa:	e78d      	b.n	dc8 <_spi_m_sync_init+0x24>
	ASSERT(hw && regs);
     eac:	2c00      	cmp	r4, #0
     eae:	d036      	beq.n	f1e <_spi_m_sync_init+0x17a>
     eb0:	2d00      	cmp	r5, #0
     eb2:	d032      	beq.n	f1a <_spi_m_sync_init+0x176>
     eb4:	2001      	movs	r0, #1
     eb6:	4a27      	ldr	r2, [pc, #156]	; (f54 <_spi_m_sync_init+0x1b0>)
     eb8:	4920      	ldr	r1, [pc, #128]	; (f3c <_spi_m_sync_init+0x198>)
     eba:	4b21      	ldr	r3, [pc, #132]	; (f40 <_spi_m_sync_init+0x19c>)
     ebc:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
     ebe:	782b      	ldrb	r3, [r5, #0]
     ec0:	786a      	ldrb	r2, [r5, #1]
     ec2:	0212      	lsls	r2, r2, #8
     ec4:	431a      	orrs	r2, r3
     ec6:	78ab      	ldrb	r3, [r5, #2]
     ec8:	041b      	lsls	r3, r3, #16
     eca:	431a      	orrs	r2, r3
     ecc:	78eb      	ldrb	r3, [r5, #3]
     ece:	061b      	lsls	r3, r3, #24
     ed0:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
     ed2:	4a1d      	ldr	r2, [pc, #116]	; (f48 <_spi_m_sync_init+0x1a4>)
     ed4:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
     ed6:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     ed8:	8a23      	ldrh	r3, [r4, #16]
     eda:	0bdb      	lsrs	r3, r3, #15
     edc:	d1fc      	bne.n	ed8 <_spi_m_sync_init+0x134>
	hri_sercomspi_write_CTRLB_reg(hw, regs->ctrlb | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_PLOADEN));
     ede:	792b      	ldrb	r3, [r5, #4]
     ee0:	796a      	ldrb	r2, [r5, #5]
     ee2:	0212      	lsls	r2, r2, #8
     ee4:	431a      	orrs	r2, r3
     ee6:	79ab      	ldrb	r3, [r5, #6]
     ee8:	041b      	lsls	r3, r3, #16
     eea:	431a      	orrs	r2, r3
     eec:	79eb      	ldrb	r3, [r5, #7]
     eee:	061b      	lsls	r3, r3, #24
     ef0:	4313      	orrs	r3, r2
     ef2:	4a19      	ldr	r2, [pc, #100]	; (f58 <_spi_m_sync_init+0x1b4>)
     ef4:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
     ef6:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
     ef8:	7a2b      	ldrb	r3, [r5, #8]
     efa:	7a6a      	ldrb	r2, [r5, #9]
     efc:	0212      	lsls	r2, r2, #8
     efe:	431a      	orrs	r2, r3
     f00:	7aab      	ldrb	r3, [r5, #10]
     f02:	041b      	lsls	r3, r3, #16
     f04:	431a      	orrs	r2, r3
     f06:	7aeb      	ldrb	r3, [r5, #11]
     f08:	061b      	lsls	r3, r3, #24
     f0a:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
     f0c:	6163      	str	r3, [r4, #20]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
     f0e:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
     f10:	7223      	strb	r3, [r4, #8]
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
     f12:	8a23      	ldrh	r3, [r4, #16]
     f14:	0bdb      	lsrs	r3, r3, #15
	while (hri_sercomspi_is_syncing(hw))
     f16:	d1fc      	bne.n	f12 <_spi_m_sync_init+0x16e>
     f18:	e7b4      	b.n	e84 <_spi_m_sync_init+0xe0>
	ASSERT(hw && regs);
     f1a:	2000      	movs	r0, #0
     f1c:	e7cb      	b.n	eb6 <_spi_m_sync_init+0x112>
     f1e:	2000      	movs	r0, #0
     f20:	e7c9      	b.n	eb6 <_spi_m_sync_init+0x112>
	ASSERT(hw && regs);
     f22:	2000      	movs	r0, #0
     f24:	e786      	b.n	e34 <_spi_m_sync_init+0x90>
     f26:	2000      	movs	r0, #0
     f28:	e784      	b.n	e34 <_spi_m_sync_init+0x90>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
     f2a:	2302      	movs	r3, #2
     f2c:	e7ae      	b.n	e8c <_spi_m_sync_init+0xe8>
		return ERR_INVALID_ARG;
     f2e:	200d      	movs	r0, #13
     f30:	4240      	negs	r0, r0
     f32:	e7ad      	b.n	e90 <_spi_m_sync_init+0xec>
     f34:	00000859 	.word	0x00000859
     f38:	000008a3 	.word	0x000008a3
     f3c:	00002cdc 	.word	0x00002cdc
     f40:	00000601 	.word	0x00000601
     f44:	00000872 	.word	0x00000872
     f48:	fffffefc 	.word	0xfffffefc
     f4c:	fffd3fbf 	.word	0xfffd3fbf
     f50:	00002d10 	.word	0x00002d10
     f54:	00000883 	.word	0x00000883
     f58:	00020040 	.word	0x00020040

00000f5c <_spi_m_sync_enable>:

	return _spi_deinit(hw);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
     f5c:	b510      	push	{r4, lr}
     f5e:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->prvt);
     f60:	d00d      	beq.n	f7e <_spi_m_sync_enable+0x22>
     f62:	6803      	ldr	r3, [r0, #0]
     f64:	2b00      	cmp	r3, #0
     f66:	d008      	beq.n	f7a <_spi_m_sync_enable+0x1e>
     f68:	2001      	movs	r0, #1
     f6a:	4a06      	ldr	r2, [pc, #24]	; (f84 <_spi_m_sync_enable+0x28>)
     f6c:	4906      	ldr	r1, [pc, #24]	; (f88 <_spi_m_sync_enable+0x2c>)
     f6e:	4b07      	ldr	r3, [pc, #28]	; (f8c <_spi_m_sync_enable+0x30>)
     f70:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
     f72:	6820      	ldr	r0, [r4, #0]
     f74:	4b06      	ldr	r3, [pc, #24]	; (f90 <_spi_m_sync_enable+0x34>)
     f76:	4798      	blx	r3
}
     f78:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
     f7a:	2000      	movs	r0, #0
     f7c:	e7f5      	b.n	f6a <_spi_m_sync_enable+0xe>
     f7e:	2000      	movs	r0, #0
     f80:	e7f3      	b.n	f6a <_spi_m_sync_enable+0xe>
     f82:	46c0      	nop			; (mov r8, r8)
     f84:	0000090a 	.word	0x0000090a
     f88:	00002cdc 	.word	0x00002cdc
     f8c:	00000601 	.word	0x00000601
     f90:	00000869 	.word	0x00000869

00000f94 <_spi_m_sync_trans>:
	ctrl->txcnt++;
	hri_sercomspi_write_DATA_reg(hw, data);
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
     f94:	b570      	push	{r4, r5, r6, lr}
     f96:	b088      	sub	sp, #32
     f98:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
     f9a:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
     f9c:	680b      	ldr	r3, [r1, #0]
     f9e:	9303      	str	r3, [sp, #12]
     fa0:	684b      	ldr	r3, [r1, #4]
     fa2:	9304      	str	r3, [sp, #16]
     fa4:	2300      	movs	r3, #0
     fa6:	9305      	str	r3, [sp, #20]
     fa8:	9306      	str	r3, [sp, #24]
     faa:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
     fac:	2800      	cmp	r0, #0
     fae:	d014      	beq.n	fda <_spi_m_sync_trans+0x46>
     fb0:	2c00      	cmp	r4, #0
     fb2:	d010      	beq.n	fd6 <_spi_m_sync_trans+0x42>
     fb4:	2001      	movs	r0, #1
     fb6:	4a2d      	ldr	r2, [pc, #180]	; (106c <STACK_SIZE+0x6c>)
     fb8:	492d      	ldr	r1, [pc, #180]	; (1070 <STACK_SIZE+0x70>)
     fba:	4b2e      	ldr	r3, [pc, #184]	; (1074 <STACK_SIZE+0x74>)
     fbc:	4798      	blx	r3
     fbe:	8a23      	ldrh	r3, [r4, #16]
     fc0:	0bdb      	lsrs	r3, r3, #15

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(hw)) {
     fc2:	d14f      	bne.n	1064 <STACK_SIZE+0x64>
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     fc4:	8a23      	ldrh	r3, [r4, #16]
     fc6:	0bdb      	lsrs	r3, r3, #15
     fc8:	d1fc      	bne.n	fc4 <_spi_m_sync_trans+0x30>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
     fca:	6823      	ldr	r3, [r4, #0]
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
     fcc:	079b      	lsls	r3, r3, #30
     fce:	d418      	bmi.n	1002 <STACK_SIZE+0x2>
		return ERR_NOT_INITIALIZED;
     fd0:	2014      	movs	r0, #20
     fd2:	4240      	negs	r0, r0
     fd4:	e044      	b.n	1060 <STACK_SIZE+0x60>
	ASSERT(dev && hw);
     fd6:	2000      	movs	r0, #0
     fd8:	e7ed      	b.n	fb6 <_spi_m_sync_trans+0x22>
     fda:	2000      	movs	r0, #0
     fdc:	e7eb      	b.n	fb6 <_spi_m_sync_trans+0x22>
		return false;
     fde:	2200      	movs	r2, #0
     fe0:	e026      	b.n	1030 <STACK_SIZE+0x30>
			data |= (*ctrl->txbuf) << 8;
     fe2:	7858      	ldrb	r0, [r3, #1]
     fe4:	0200      	lsls	r0, r0, #8
     fe6:	4301      	orrs	r1, r0
			ctrl->txbuf++;
     fe8:	3302      	adds	r3, #2
     fea:	9303      	str	r3, [sp, #12]
	ctrl->txcnt++;
     fec:	3201      	adds	r2, #1
     fee:	9205      	str	r2, [sp, #20]
	hri_sercomspi_write_DATA_reg(hw, data);
     ff0:	b289      	uxth	r1, r1
	((Sercom *)hw)->SPI.DATA.reg = data;
     ff2:	8321      	strh	r1, [r4, #24]
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check(hw, iflag, &ctrl);
			}
		}

		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
     ff4:	9805      	ldr	r0, [sp, #20]
     ff6:	68ab      	ldr	r3, [r5, #8]
     ff8:	4298      	cmp	r0, r3
     ffa:	d302      	bcc.n	1002 <STACK_SIZE+0x2>
     ffc:	9a06      	ldr	r2, [sp, #24]
     ffe:	4293      	cmp	r3, r2
    1000:	d929      	bls.n	1056 <STACK_SIZE+0x56>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    1002:	7ba3      	ldrb	r3, [r4, #14]
    1004:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    1006:	075a      	lsls	r2, r3, #29
    1008:	d5e9      	bpl.n	fde <_spi_m_sync_trans+0x4a>
	return ((Sercom *)hw)->SPI.DATA.reg;
    100a:	8b22      	ldrh	r2, [r4, #24]
    100c:	b292      	uxth	r2, r2
	if (ctrl->rxbuf) {
    100e:	9904      	ldr	r1, [sp, #16]
    1010:	2900      	cmp	r1, #0
    1012:	d008      	beq.n	1026 <STACK_SIZE+0x26>
		*ctrl->rxbuf++ = (uint8_t)data;
    1014:	1c48      	adds	r0, r1, #1
    1016:	9004      	str	r0, [sp, #16]
    1018:	700a      	strb	r2, [r1, #0]
		if (ctrl->char_size > 1) {
    101a:	2e01      	cmp	r6, #1
    101c:	d903      	bls.n	1026 <STACK_SIZE+0x26>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    101e:	1c88      	adds	r0, r1, #2
    1020:	9004      	str	r0, [sp, #16]
    1022:	0a12      	lsrs	r2, r2, #8
    1024:	704a      	strb	r2, [r1, #1]
	ctrl->rxcnt++;
    1026:	9a06      	ldr	r2, [sp, #24]
    1028:	9201      	str	r2, [sp, #4]
    102a:	3201      	adds	r2, #1
    102c:	9206      	str	r2, [sp, #24]
	return true;
    102e:	2201      	movs	r2, #1
		if (!_spi_rx_check(hw, iflag, &ctrl)) {
    1030:	2a00      	cmp	r2, #0
    1032:	d1df      	bne.n	ff4 <_spi_m_sync_trans+0x60>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    1034:	9906      	ldr	r1, [sp, #24]
    1036:	9a05      	ldr	r2, [sp, #20]
    1038:	4291      	cmp	r1, r2
    103a:	d3db      	bcc.n	ff4 <_spi_m_sync_trans+0x60>
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    103c:	07db      	lsls	r3, r3, #31
    103e:	d5d9      	bpl.n	ff4 <_spi_m_sync_trans+0x60>
	if (ctrl->txbuf) {
    1040:	9b03      	ldr	r3, [sp, #12]
    1042:	2b00      	cmp	r3, #0
    1044:	d005      	beq.n	1052 <STACK_SIZE+0x52>
		data = *ctrl->txbuf++;
    1046:	1c59      	adds	r1, r3, #1
    1048:	9103      	str	r1, [sp, #12]
    104a:	7819      	ldrb	r1, [r3, #0]
		if (ctrl->char_size > 1) {
    104c:	2e01      	cmp	r6, #1
    104e:	d8c8      	bhi.n	fe2 <_spi_m_sync_trans+0x4e>
    1050:	e7cc      	b.n	fec <_spi_m_sync_trans+0x58>
		data = SPI_DUMMY_CHAR;
    1052:	4909      	ldr	r1, [pc, #36]	; (1078 <STACK_SIZE+0x78>)
    1054:	e7ca      	b.n	fec <_spi_m_sync_trans+0x58>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    1056:	7ba3      	ldrb	r3, [r4, #14]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    1058:	079b      	lsls	r3, r3, #30
    105a:	d0fc      	beq.n	1056 <STACK_SIZE+0x56>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    105c:	2303      	movs	r3, #3
    105e:	73a3      	strb	r3, [r4, #14]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    1060:	b008      	add	sp, #32
    1062:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
    1064:	2004      	movs	r0, #4
    1066:	4240      	negs	r0, r0
    1068:	e7fa      	b.n	1060 <STACK_SIZE+0x60>
    106a:	46c0      	nop			; (mov r8, r8)
    106c:	00000a01 	.word	0x00000a01
    1070:	00002cdc 	.word	0x00002cdc
    1074:	00000601 	.word	0x00000601
    1078:	000001ff 	.word	0x000001ff

0000107c <_sysctrl_init_sources>:
}

static inline hri_sysctrl_osc32k_reg_t hri_sysctrl_read_OSC32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC32K.reg;
    107c:	4a0b      	ldr	r2, [pc, #44]	; (10ac <_sysctrl_init_sources+0x30>)
    107e:	6993      	ldr	r3, [r2, #24]
	tmp = (tmp & SYSCTRL_OSC32K_CALIB_Msk) >> SYSCTRL_OSC32K_CALIB_Pos;
    1080:	0c1b      	lsrs	r3, r3, #16
	hri_sysctrl_write_OSC32K_reg(
	    hw,
#if CONF_OSC32K_OVERWRITE_CALIBRATION == 1
	    SYSCTRL_OSC32K_CALIB(CONF_OSC32K_CALIB) |
#else
	    SYSCTRL_OSC32K_CALIB(calib) |
    1082:	041b      	lsls	r3, r3, #16
    1084:	21fe      	movs	r1, #254	; 0xfe
    1086:	03c9      	lsls	r1, r1, #15
    1088:	400b      	ands	r3, r1
#endif
	        (CONF_OSC32K_WRTLOCK << SYSCTRL_OSC32K_WRTLOCK_Pos) | SYSCTRL_OSC32K_STARTUP(CONF_OSC32K_STARTUP)
	        | (CONF_OSC32K_RUNSTDBY << SYSCTRL_OSC32K_RUNSTDBY_Pos) | (CONF_OSC32K_EN1K << SYSCTRL_OSC32K_EN1K_Pos)
	        | (CONF_OSC32K_EN32K << SYSCTRL_OSC32K_EN32K_Pos) | (1 << SYSCTRL_OSC32K_ENABLE_Pos));
    108a:	210e      	movs	r1, #14
    108c:	430b      	orrs	r3, r1
}

static inline void hri_sysctrl_write_OSC32K_reg(const void *const hw, hri_sysctrl_osc32k_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg = data;
    108e:	6193      	str	r3, [r2, #24]
}

static inline hri_sysctrl_osculp32k_reg_t hri_sysctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    1090:	7f13      	ldrb	r3, [r2, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    1092:	3111      	adds	r1, #17
    1094:	400b      	ands	r3, r1
}

static inline void hri_sysctrl_write_OSCULP32K_reg(const void *const hw, hri_sysctrl_osculp32k_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    1096:	7713      	strb	r3, [r2, #28]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) >> SYSCTRL_PCLKSR_OSC32KRDY_Pos;
    1098:	4b04      	ldr	r3, [pc, #16]	; (10ac <_sysctrl_init_sources+0x30>)
    109a:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC32K_CONFIG == 1
#if CONF_OSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(hw))
    109c:	075b      	lsls	r3, r3, #29
    109e:	d5fb      	bpl.n	1098 <_sysctrl_init_sources+0x1c>
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ONDEMAND;
    10a0:	4a02      	ldr	r2, [pc, #8]	; (10ac <_sysctrl_init_sources+0x30>)
    10a2:	6993      	ldr	r3, [r2, #24]
    10a4:	2180      	movs	r1, #128	; 0x80
    10a6:	430b      	orrs	r3, r1
    10a8:	6193      	str	r3, [r2, #24]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
    10aa:	4770      	bx	lr
    10ac:	40000800 	.word	0x40000800

000010b0 <_sysctrl_init_referenced_generators>:
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    10b0:	2202      	movs	r2, #2
    10b2:	4b19      	ldr	r3, [pc, #100]	; (1118 <_sysctrl_init_referenced_generators+0x68>)
    10b4:	849a      	strh	r2, [r3, #36]	; 0x24
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    10b6:	4b18      	ldr	r3, [pc, #96]	; (1118 <_sysctrl_init_referenced_generators+0x68>)
    10b8:	68db      	ldr	r3, [r3, #12]
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    10ba:	06db      	lsls	r3, r3, #27
    10bc:	d5fb      	bpl.n	10b6 <_sysctrl_init_referenced_generators+0x6>
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    10be:	4a17      	ldr	r2, [pc, #92]	; (111c <_sysctrl_init_referenced_generators+0x6c>)
    10c0:	4b15      	ldr	r3, [pc, #84]	; (1118 <_sysctrl_init_referenced_generators+0x68>)
    10c2:	62da      	str	r2, [r3, #44]	; 0x2c
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    10c4:	4b16      	ldr	r3, [pc, #88]	; (1120 <_sysctrl_init_referenced_generators+0x70>)
    10c6:	681b      	ldr	r3, [r3, #0]
    10c8:	0e9b      	lsrs	r3, r3, #26
    10ca:	2b3f      	cmp	r3, #63	; 0x3f
    10cc:	d01b      	beq.n	1106 <_sysctrl_init_referenced_generators+0x56>
    10ce:	029b      	lsls	r3, r3, #10
    10d0:	2280      	movs	r2, #128	; 0x80
    10d2:	0092      	lsls	r2, r2, #2
    10d4:	4313      	orrs	r3, r2
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    10d6:	4a10      	ldr	r2, [pc, #64]	; (1118 <_sysctrl_init_referenced_generators+0x68>)
    10d8:	6293      	str	r3, [r2, #40]	; 0x28
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    10da:	2302      	movs	r3, #2
    10dc:	8493      	strh	r3, [r2, #36]	; 0x24
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    10de:	8c93      	ldrh	r3, [r2, #36]	; 0x24
	hri_sysctrl_write_DFLLCTRL_reg(hw, tmp);
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    10e0:	075b      	lsls	r3, r3, #29
    10e2:	d513      	bpl.n	110c <_sysctrl_init_referenced_generators+0x5c>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    10e4:	4b0c      	ldr	r3, [pc, #48]	; (1118 <_sysctrl_init_referenced_generators+0x68>)
    10e6:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
    10e8:	23d0      	movs	r3, #208	; 0xd0
    10ea:	4013      	ands	r3, r2
		hri_sysctrl_pclksr_reg_t status_mask
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    10ec:	2bd0      	cmp	r3, #208	; 0xd0
    10ee:	d1f9      	bne.n	10e4 <_sysctrl_init_referenced_generators+0x34>
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
    10f0:	4a09      	ldr	r2, [pc, #36]	; (1118 <_sysctrl_init_referenced_generators+0x68>)
    10f2:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    10f4:	2180      	movs	r1, #128	; 0x80
    10f6:	430b      	orrs	r3, r1
    10f8:	b29b      	uxth	r3, r3
    10fa:	8493      	strh	r3, [r2, #36]	; 0x24
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    10fc:	4b09      	ldr	r3, [pc, #36]	; (1124 <_sysctrl_init_referenced_generators+0x74>)
    10fe:	785b      	ldrb	r3, [r3, #1]
	hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    1100:	09db      	lsrs	r3, r3, #7
    1102:	d1fb      	bne.n	10fc <_sysctrl_init_referenced_generators+0x4c>
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    1104:	4770      	bx	lr
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    1106:	23fc      	movs	r3, #252	; 0xfc
    1108:	01db      	lsls	r3, r3, #7
    110a:	e7e4      	b.n	10d6 <_sysctrl_init_referenced_generators+0x26>
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    110c:	4b02      	ldr	r3, [pc, #8]	; (1118 <_sysctrl_init_referenced_generators+0x68>)
    110e:	68db      	ldr	r3, [r3, #12]
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    1110:	06db      	lsls	r3, r3, #27
    1112:	d5fb      	bpl.n	110c <_sysctrl_init_referenced_generators+0x5c>
    1114:	e7ec      	b.n	10f0 <_sysctrl_init_referenced_generators+0x40>
    1116:	46c0      	nop			; (mov r8, r8)
    1118:	40000800 	.word	0x40000800
    111c:	04010000 	.word	0x04010000
    1120:	00806024 	.word	0x00806024
    1124:	40000c00 	.word	0x40000c00

00001128 <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    1128:	4b02      	ldr	r3, [pc, #8]	; (1134 <_system_time_init+0xc>)
    112a:	4a03      	ldr	r2, [pc, #12]	; (1138 <_system_time_init+0x10>)
    112c:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    112e:	2205      	movs	r2, #5
    1130:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    1132:	4770      	bx	lr
    1134:	e000e010 	.word	0xe000e010
    1138:	00ffffff 	.word	0x00ffffff

0000113c <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    113c:	b510      	push	{r4, lr}
	_system_time_init(hw);
    113e:	4b01      	ldr	r3, [pc, #4]	; (1144 <_delay_init+0x8>)
    1140:	4798      	blx	r3
}
    1142:	bd10      	pop	{r4, pc}
    1144:	00001129 	.word	0x00001129

00001148 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
    1148:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
    114a:	e00b      	b.n	1164 <_delay_cycles+0x1c>
		SysTick->LOAD = 0xFFFFFF;
    114c:	4b0b      	ldr	r3, [pc, #44]	; (117c <_delay_cycles+0x34>)
    114e:	480c      	ldr	r0, [pc, #48]	; (1180 <_delay_cycles+0x38>)
    1150:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    1152:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    1154:	4b09      	ldr	r3, [pc, #36]	; (117c <_delay_cycles+0x34>)
    1156:	681b      	ldr	r3, [r3, #0]
    1158:	03db      	lsls	r3, r3, #15
    115a:	d5fb      	bpl.n	1154 <_delay_cycles+0xc>
			;
		buf -= 0xFFFFFF;
    115c:	4b09      	ldr	r3, [pc, #36]	; (1184 <_delay_cycles+0x3c>)
    115e:	469c      	mov	ip, r3
    1160:	4461      	add	r1, ip
	while (n--) {
    1162:	0010      	movs	r0, r2
    1164:	1e42      	subs	r2, r0, #1
    1166:	b2d2      	uxtb	r2, r2
    1168:	2800      	cmp	r0, #0
    116a:	d1ef      	bne.n	114c <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
    116c:	4b03      	ldr	r3, [pc, #12]	; (117c <_delay_cycles+0x34>)
    116e:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
    1170:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    1172:	4b02      	ldr	r3, [pc, #8]	; (117c <_delay_cycles+0x34>)
    1174:	681b      	ldr	r3, [r3, #0]
    1176:	03db      	lsls	r3, r3, #15
    1178:	d5fb      	bpl.n	1172 <_delay_cycles+0x2a>
		;
}
    117a:	4770      	bx	lr
    117c:	e000e010 	.word	0xe000e010
    1180:	00ffffff 	.word	0x00ffffff
    1184:	ff000001 	.word	0xff000001

00001188 <I2C_RTC_Handler>:

uint8_t rtcIntCount = 0;
uint8_t rfIntCount = 0;

static void I2C_RTC_Handler(void){
	if (rtcIntCount < 255) {
    1188:	4b03      	ldr	r3, [pc, #12]	; (1198 <I2C_RTC_Handler+0x10>)
    118a:	781b      	ldrb	r3, [r3, #0]
    118c:	2bff      	cmp	r3, #255	; 0xff
    118e:	d002      	beq.n	1196 <I2C_RTC_Handler+0xe>
		rtcIntCount++;
    1190:	3301      	adds	r3, #1
    1192:	4a01      	ldr	r2, [pc, #4]	; (1198 <I2C_RTC_Handler+0x10>)
    1194:	7013      	strb	r3, [r2, #0]
	}
}
    1196:	4770      	bx	lr
    1198:	2000004d 	.word	0x2000004d

0000119c <RF_int_Handler>:
	return res;
}


static void RF_int_Handler(void){
	if(rfIntCount < 255){
    119c:	4b03      	ldr	r3, [pc, #12]	; (11ac <RF_int_Handler+0x10>)
    119e:	781b      	ldrb	r3, [r3, #0]
    11a0:	2bff      	cmp	r3, #255	; 0xff
    11a2:	d002      	beq.n	11aa <RF_int_Handler+0xe>
		rfIntCount++;
    11a4:	3301      	adds	r3, #1
    11a6:	4a01      	ldr	r2, [pc, #4]	; (11ac <RF_int_Handler+0x10>)
    11a8:	7013      	strb	r3, [r2, #0]
	}	
}
    11aa:	4770      	bx	lr
    11ac:	2000004c 	.word	0x2000004c

000011b0 <RTC_IRQ_Ready>:
	uint8_t res = rtcIntCount;
    11b0:	4b02      	ldr	r3, [pc, #8]	; (11bc <RTC_IRQ_Ready+0xc>)
    11b2:	7818      	ldrb	r0, [r3, #0]
	rtcIntCount = 0;
    11b4:	2200      	movs	r2, #0
    11b6:	701a      	strb	r2, [r3, #0]
}
    11b8:	4770      	bx	lr
    11ba:	46c0      	nop			; (mov r8, r8)
    11bc:	2000004d 	.word	0x2000004d

000011c0 <SPI0_WriteBuff>:
}

void SPI0_ReadBuff(uint8_t* buff, uint16_t len){
	io_read(spi0,buff,len);
}
void SPI0_WriteBuff(uint8_t* buff, uint16_t len){
    11c0:	b510      	push	{r4, lr}
    11c2:	0003      	movs	r3, r0
    11c4:	000a      	movs	r2, r1
	io_write(spi0,buff,len);
    11c6:	4903      	ldr	r1, [pc, #12]	; (11d4 <SPI0_WriteBuff+0x14>)
    11c8:	6808      	ldr	r0, [r1, #0]
    11ca:	0019      	movs	r1, r3
    11cc:	4b02      	ldr	r3, [pc, #8]	; (11d8 <SPI0_WriteBuff+0x18>)
    11ce:	4798      	blx	r3
}
    11d0:	bd10      	pop	{r4, pc}
    11d2:	46c0      	nop			; (mov r8, r8)
    11d4:	20001728 	.word	0x20001728
    11d8:	00000459 	.word	0x00000459

000011dc <RTC_write_batch>:
void SPI0_Write_byte(uint8_t byte){
	io_write(spi0, &byte, 1);
}


bool RTC_write_batch(uint8_t addres, uint8_t *data, uint8_t data_len){
    11dc:	b570      	push	{r4, r5, r6, lr}
    11de:	000d      	movs	r5, r1
    11e0:	0014      	movs	r4, r2
	i2c_m_sync_set_slaveaddr(&I2C_0, addres, I2C_M_SEVEN);
    11e2:	b201      	sxth	r1, r0
    11e4:	2280      	movs	r2, #128	; 0x80
    11e6:	0112      	lsls	r2, r2, #4
    11e8:	4805      	ldr	r0, [pc, #20]	; (1200 <RTC_write_batch+0x24>)
    11ea:	4b06      	ldr	r3, [pc, #24]	; (1204 <RTC_write_batch+0x28>)
    11ec:	4798      	blx	r3
	//i2c_m_sync_cmd_write(&EXT_I2C, 0x00, data, data_len);	
	return (io_write(i2c0, (uint8_t *)data, data_len) >= 0) ? true : false;
    11ee:	b2a2      	uxth	r2, r4
    11f0:	4b05      	ldr	r3, [pc, #20]	; (1208 <RTC_write_batch+0x2c>)
    11f2:	6818      	ldr	r0, [r3, #0]
    11f4:	0029      	movs	r1, r5
    11f6:	4b05      	ldr	r3, [pc, #20]	; (120c <RTC_write_batch+0x30>)
    11f8:	4798      	blx	r3
    11fa:	43c0      	mvns	r0, r0
    11fc:	0fc0      	lsrs	r0, r0, #31
}
    11fe:	bd70      	pop	{r4, r5, r6, pc}
    1200:	200016e8 	.word	0x200016e8
    1204:	000003f5 	.word	0x000003f5
    1208:	20001724 	.word	0x20001724
    120c:	00000459 	.word	0x00000459

00001210 <RTC_read_batch>:

bool RTC_read_batch(uint8_t addres ,uint8_t *data, uint8_t data_len){
    1210:	b570      	push	{r4, r5, r6, lr}
    1212:	000c      	movs	r4, r1
    1214:	0015      	movs	r5, r2
	i2c_m_sync_set_slaveaddr(&I2C_0, addres, I2C_M_SEVEN);
    1216:	b201      	sxth	r1, r0
    1218:	4e06      	ldr	r6, [pc, #24]	; (1234 <RTC_read_batch+0x24>)
    121a:	2280      	movs	r2, #128	; 0x80
    121c:	0112      	lsls	r2, r2, #4
    121e:	0030      	movs	r0, r6
    1220:	4b05      	ldr	r3, [pc, #20]	; (1238 <RTC_read_batch+0x28>)
    1222:	4798      	blx	r3
	i2c_m_sync_cmd_read(&I2C_0, 0x00, data, data_len);
    1224:	002b      	movs	r3, r5
    1226:	0022      	movs	r2, r4
    1228:	2100      	movs	r1, #0
    122a:	0030      	movs	r0, r6
    122c:	4c03      	ldr	r4, [pc, #12]	; (123c <RTC_read_batch+0x2c>)
    122e:	47a0      	blx	r4
	//return (io_read(I2C_io, (uint8_t *)data, data_len) >= 0) ? true : false;
}
    1230:	bd70      	pop	{r4, r5, r6, pc}
    1232:	46c0      	nop			; (mov r8, r8)
    1234:	200016e8 	.word	0x200016e8
    1238:	000003f5 	.word	0x000003f5
    123c:	00000409 	.word	0x00000409

00001240 <GPIO_init>:
	i2c_m_sync_set_slaveaddr(&I2C_0, addres, I2C_M_SEVEN);
	i2c_m_sync_cmd_read(&I2C_0, reg, data, data_len);
}


void GPIO_init(void){
    1240:	b5f0      	push	{r4, r5, r6, r7, lr}
    1242:	46ce      	mov	lr, r9
    1244:	4647      	mov	r7, r8
    1246:	b580      	push	{r7, lr}
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1248:	22c0      	movs	r2, #192	; 0xc0
    124a:	05d2      	lsls	r2, r2, #23
    124c:	2380      	movs	r3, #128	; 0x80
    124e:	031b      	lsls	r3, r3, #12
    1250:	6193      	str	r3, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1252:	6093      	str	r3, [r2, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1254:	4b35      	ldr	r3, [pc, #212]	; (132c <GPIO_init+0xec>)
    1256:	2480      	movs	r4, #128	; 0x80
    1258:	05e4      	lsls	r4, r4, #23
    125a:	629c      	str	r4, [r3, #40]	; 0x28
    125c:	4934      	ldr	r1, [pc, #208]	; (1330 <GPIO_init+0xf0>)
    125e:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1260:	2553      	movs	r5, #83	; 0x53
    1262:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1264:	2101      	movs	r1, #1
    1266:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1268:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    126a:	2080      	movs	r0, #128	; 0x80
    126c:	01c0      	lsls	r0, r0, #7
    126e:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1270:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1272:	4830      	ldr	r0, [pc, #192]	; (1334 <GPIO_init+0xf4>)
    1274:	6298      	str	r0, [r3, #40]	; 0x28
    1276:	20c0      	movs	r0, #192	; 0xc0
    1278:	0600      	lsls	r0, r0, #24
    127a:	4681      	mov	r9, r0
    127c:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    127e:	3d05      	subs	r5, #5
    1280:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1282:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1284:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1286:	2080      	movs	r0, #128	; 0x80
    1288:	0200      	lsls	r0, r0, #8
    128a:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    128c:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    128e:	482a      	ldr	r0, [pc, #168]	; (1338 <GPIO_init+0xf8>)
    1290:	6298      	str	r0, [r3, #40]	; 0x28
    1292:	4648      	mov	r0, r9
    1294:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1296:	3501      	adds	r5, #1
    1298:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    129a:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    129c:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    129e:	2080      	movs	r0, #128	; 0x80
    12a0:	0240      	lsls	r0, r0, #9
    12a2:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    12a4:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    12a6:	629c      	str	r4, [r3, #40]	; 0x28
    12a8:	4824      	ldr	r0, [pc, #144]	; (133c <GPIO_init+0xfc>)
    12aa:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    12ac:	3501      	adds	r5, #1
    12ae:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    12b0:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    12b2:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    12b4:	2780      	movs	r7, #128	; 0x80
    12b6:	02bf      	lsls	r7, r7, #10
    12b8:	6057      	str	r7, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    12ba:	4821      	ldr	r0, [pc, #132]	; (1340 <GPIO_init+0x100>)
    12bc:	6298      	str	r0, [r3, #40]	; 0x28
    12be:	4821      	ldr	r0, [pc, #132]	; (1344 <GPIO_init+0x104>)
    12c0:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    12c2:	6057      	str	r7, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    12c4:	3501      	adds	r5, #1
    12c6:	5d58      	ldrb	r0, [r3, r5]
    12c8:	4680      	mov	r8, r0
    12ca:	2004      	movs	r0, #4
    12cc:	4684      	mov	ip, r0
    12ce:	4660      	mov	r0, ip
    12d0:	4646      	mov	r6, r8
    12d2:	4306      	orrs	r6, r0
    12d4:	b2f0      	uxtb	r0, r6
    12d6:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    12d8:	6197      	str	r7, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    12da:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    12dc:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    12de:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    12e0:	2080      	movs	r0, #128	; 0x80
    12e2:	02c0      	lsls	r0, r0, #11
    12e4:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    12e6:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    12e8:	629c      	str	r4, [r3, #40]	; 0x28
    12ea:	4817      	ldr	r0, [pc, #92]	; (1348 <GPIO_init+0x108>)
    12ec:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    12ee:	3501      	adds	r5, #1
    12f0:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
    12f2:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    12f4:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    12f6:	2080      	movs	r0, #128	; 0x80
    12f8:	0500      	lsls	r0, r0, #20
    12fa:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    12fc:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    12fe:	629c      	str	r4, [r3, #40]	; 0x28
    1300:	4812      	ldr	r0, [pc, #72]	; (134c <GPIO_init+0x10c>)
    1302:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1304:	245b      	movs	r4, #91	; 0x5b
    1306:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1308:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    130a:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    130c:	2080      	movs	r0, #128	; 0x80
    130e:	0100      	lsls	r0, r0, #4
    1310:	6190      	str	r0, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1312:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1314:	4a0e      	ldr	r2, [pc, #56]	; (1350 <GPIO_init+0x110>)
    1316:	629a      	str	r2, [r3, #40]	; 0x28
    1318:	464a      	mov	r2, r9
    131a:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    131c:	204b      	movs	r0, #75	; 0x4b
    131e:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1320:	438a      	bics	r2, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1322:	541a      	strb	r2, [r3, r0]
	gpio_set_pin_function(EP_EN, GPIO_PIN_FUNCTION_OFF);
	
	gpio_set_pin_level(EP_RST, true);
	gpio_set_pin_direction(EP_RST, GPIO_DIRECTION_OUT);
	gpio_set_pin_function(EP_RST, GPIO_PIN_FUNCTION_OFF);	
}
    1324:	bc0c      	pop	{r2, r3}
    1326:	4690      	mov	r8, r2
    1328:	4699      	mov	r9, r3
    132a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    132c:	41004400 	.word	0x41004400
    1330:	c0000008 	.word	0xc0000008
    1334:	40004000 	.word	0x40004000
    1338:	40008000 	.word	0x40008000
    133c:	c0000001 	.word	0xc0000001
    1340:	40020000 	.word	0x40020000
    1344:	c0020002 	.word	0xc0020002
    1348:	c0000004 	.word	0xc0000004
    134c:	c0000800 	.word	0xc0000800
    1350:	40000800 	.word	0x40000800

00001354 <SPI_init>:


void SPI_init(void){
    1354:	b5f0      	push	{r4, r5, r6, r7, lr}
    1356:	46c6      	mov	lr, r8
    1358:	b500      	push	{lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    135a:	21c0      	movs	r1, #192	; 0xc0
    135c:	05c9      	lsls	r1, r1, #23
    135e:	2380      	movs	r3, #128	; 0x80
    1360:	005b      	lsls	r3, r3, #1
    1362:	614b      	str	r3, [r1, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1364:	608b      	str	r3, [r1, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1366:	4b30      	ldr	r3, [pc, #192]	; (1428 <SPI_init+0xd4>)
    1368:	4a30      	ldr	r2, [pc, #192]	; (142c <SPI_init+0xd8>)
    136a:	629a      	str	r2, [r3, #40]	; 0x28
    136c:	22c0      	movs	r2, #192	; 0xc0
    136e:	0612      	lsls	r2, r2, #24
    1370:	4694      	mov	ip, r2
    1372:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1374:	2448      	movs	r4, #72	; 0x48
    1376:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1378:	2601      	movs	r6, #1
    137a:	43b0      	bics	r0, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    137c:	2201      	movs	r2, #1
    137e:	4310      	orrs	r0, r2
    1380:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1382:	5518      	strb	r0, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1384:	2734      	movs	r7, #52	; 0x34
    1386:	5dd8      	ldrb	r0, [r3, r7]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1388:	250f      	movs	r5, #15
    138a:	43a8      	bics	r0, r5
	tmp |= PORT_PMUX_PMUXE(data);
    138c:	2402      	movs	r4, #2
    138e:	46a0      	mov	r8, r4
    1390:	4644      	mov	r4, r8
    1392:	4320      	orrs	r0, r4
    1394:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1396:	55d8      	strb	r0, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1398:	2080      	movs	r0, #128	; 0x80
    139a:	0080      	lsls	r0, r0, #2
    139c:	6148      	str	r0, [r1, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    139e:	6088      	str	r0, [r1, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    13a0:	4823      	ldr	r0, [pc, #140]	; (1430 <SPI_init+0xdc>)
    13a2:	6298      	str	r0, [r3, #40]	; 0x28
    13a4:	4660      	mov	r0, ip
    13a6:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    13a8:	2049      	movs	r0, #73	; 0x49
    13aa:	4684      	mov	ip, r0
    13ac:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    13ae:	43b0      	bics	r0, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    13b0:	4310      	orrs	r0, r2
    13b2:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    13b4:	4664      	mov	r4, ip
    13b6:	5518      	strb	r0, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    13b8:	5dd8      	ldrb	r0, [r3, r7]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    13ba:	3c3a      	subs	r4, #58	; 0x3a
    13bc:	4020      	ands	r0, r4
	tmp |= PORT_PMUX_PMUXO(data);
    13be:	2420      	movs	r4, #32
    13c0:	46a4      	mov	ip, r4
    13c2:	4664      	mov	r4, ip
    13c4:	4320      	orrs	r0, r4
    13c6:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    13c8:	55d8      	strb	r0, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    13ca:	2080      	movs	r0, #128	; 0x80
    13cc:	00c0      	lsls	r0, r0, #3
    13ce:	6048      	str	r0, [r1, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    13d0:	4918      	ldr	r1, [pc, #96]	; (1434 <SPI_init+0xe0>)
    13d2:	6299      	str	r1, [r3, #40]	; 0x28
    13d4:	4918      	ldr	r1, [pc, #96]	; (1438 <SPI_init+0xe4>)
    13d6:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    13d8:	3716      	adds	r7, #22
    13da:	5dd9      	ldrb	r1, [r3, r7]
    13dc:	2004      	movs	r0, #4
    13de:	4381      	bics	r1, r0
    13e0:	55d9      	strb	r1, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    13e2:	5dd9      	ldrb	r1, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
    13e4:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    13e6:	4311      	orrs	r1, r2
    13e8:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    13ea:	55d9      	strb	r1, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    13ec:	2135      	movs	r1, #53	; 0x35
    13ee:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    13f0:	43aa      	bics	r2, r5
	tmp |= PORT_PMUX_PMUXE(data);
    13f2:	4644      	mov	r4, r8
    13f4:	4322      	orrs	r2, r4
    13f6:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    13f8:	545a      	strb	r2, [r3, r1]
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
    13fa:	4a10      	ldr	r2, [pc, #64]	; (143c <SPI_init+0xe8>)
    13fc:	6a13      	ldr	r3, [r2, #32]
    13fe:	4318      	orrs	r0, r3
    1400:	6210      	str	r0, [r2, #32]
	((Gclk *)hw)->CLKCTRL.reg = data;
    1402:	4a0f      	ldr	r2, [pc, #60]	; (1440 <SPI_init+0xec>)
    1404:	4b0f      	ldr	r3, [pc, #60]	; (1444 <SPI_init+0xf0>)
    1406:	805a      	strh	r2, [r3, #2]
	gpio_set_pin_function(PA10, PINMUX_PA10C_SERCOM0_PAD2);
	
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM0);
	_gclk_enable_channel(SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC);
	
	spi_m_sync_init(&SPI_0, SERCOM0);
    1408:	4c0f      	ldr	r4, [pc, #60]	; (1448 <SPI_init+0xf4>)
    140a:	4910      	ldr	r1, [pc, #64]	; (144c <SPI_init+0xf8>)
    140c:	0020      	movs	r0, r4
    140e:	4b10      	ldr	r3, [pc, #64]	; (1450 <SPI_init+0xfc>)
    1410:	4798      	blx	r3
	spi_m_sync_get_io_descriptor(&SPI_0, &spi0);
    1412:	4910      	ldr	r1, [pc, #64]	; (1454 <SPI_init+0x100>)
    1414:	0020      	movs	r0, r4
    1416:	4b10      	ldr	r3, [pc, #64]	; (1458 <SPI_init+0x104>)
    1418:	4798      	blx	r3
	spi_m_sync_enable(&SPI_0);
    141a:	0020      	movs	r0, r4
    141c:	4b0f      	ldr	r3, [pc, #60]	; (145c <SPI_init+0x108>)
    141e:	4798      	blx	r3
	
}
    1420:	bc04      	pop	{r2}
    1422:	4690      	mov	r8, r2
    1424:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1426:	46c0      	nop			; (mov r8, r8)
    1428:	41004400 	.word	0x41004400
    142c:	40000100 	.word	0x40000100
    1430:	40000200 	.word	0x40000200
    1434:	40020400 	.word	0x40020400
    1438:	c0020000 	.word	0xc0020000
    143c:	40000400 	.word	0x40000400
    1440:	0000400d 	.word	0x0000400d
    1444:	40000c00 	.word	0x40000c00
    1448:	2000170c 	.word	0x2000170c
    144c:	42000800 	.word	0x42000800
    1450:	00000491 	.word	0x00000491
    1454:	20001728 	.word	0x20001728
    1458:	000005d1 	.word	0x000005d1
    145c:	000004e9 	.word	0x000004e9

00001460 <I2C_init>:



void I2C_init(void){
    1460:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1462:	4a1e      	ldr	r2, [pc, #120]	; (14dc <I2C_init+0x7c>)
    1464:	6a13      	ldr	r3, [r2, #32]
    1466:	2120      	movs	r1, #32
    1468:	430b      	orrs	r3, r1
    146a:	6213      	str	r3, [r2, #32]
    146c:	4b1c      	ldr	r3, [pc, #112]	; (14e0 <I2C_init+0x80>)
    146e:	4a1d      	ldr	r2, [pc, #116]	; (14e4 <I2C_init+0x84>)
    1470:	805a      	strh	r2, [r3, #2]
    1472:	4a1d      	ldr	r2, [pc, #116]	; (14e8 <I2C_init+0x88>)
    1474:	805a      	strh	r2, [r3, #2]
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM3);
	_gclk_enable_channel(SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC);
	_gclk_enable_channel(SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC);
	
	i2c_m_sync_init(&I2C_0, SERCOM3);
    1476:	4c1d      	ldr	r4, [pc, #116]	; (14ec <I2C_init+0x8c>)
    1478:	491d      	ldr	r1, [pc, #116]	; (14f0 <I2C_init+0x90>)
    147a:	0020      	movs	r0, r4
    147c:	4b1d      	ldr	r3, [pc, #116]	; (14f4 <I2C_init+0x94>)
    147e:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1480:	4b1d      	ldr	r3, [pc, #116]	; (14f8 <I2C_init+0x98>)
    1482:	2056      	movs	r0, #86	; 0x56
    1484:	5c19      	ldrb	r1, [r3, r0]
    1486:	2204      	movs	r2, #4
    1488:	4391      	bics	r1, r2
    148a:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    148c:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    148e:	2601      	movs	r6, #1
    1490:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1492:	2501      	movs	r5, #1
    1494:	4329      	orrs	r1, r5
    1496:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1498:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    149a:	381b      	subs	r0, #27
    149c:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    149e:	270f      	movs	r7, #15
    14a0:	43b9      	bics	r1, r7
	tmp |= PORT_PMUX_PMUXE(data);
    14a2:	2702      	movs	r7, #2
    14a4:	4339      	orrs	r1, r7
    14a6:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    14a8:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    14aa:	2157      	movs	r1, #87	; 0x57
    14ac:	5c5f      	ldrb	r7, [r3, r1]
    14ae:	4397      	bics	r7, r2
    14b0:	545f      	strb	r7, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    14b2:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    14b4:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    14b6:	432a      	orrs	r2, r5
    14b8:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    14ba:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    14bc:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    14be:	3948      	subs	r1, #72	; 0x48
    14c0:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
    14c2:	2120      	movs	r1, #32
    14c4:	430a      	orrs	r2, r1
    14c6:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    14c8:	541a      	strb	r2, [r3, r0]
	gpio_set_pin_function(PA22, PINMUX_PA22C_SERCOM3_PAD0);

	gpio_set_pin_pull_mode(PA23, GPIO_PULL_OFF);
	gpio_set_pin_function(PA23, PINMUX_PA23C_SERCOM3_PAD1);

	i2c_m_sync_get_io_descriptor(&I2C_0, &i2c0);
    14ca:	490c      	ldr	r1, [pc, #48]	; (14fc <I2C_init+0x9c>)
    14cc:	0020      	movs	r0, r4
    14ce:	4b0c      	ldr	r3, [pc, #48]	; (1500 <I2C_init+0xa0>)
    14d0:	4798      	blx	r3
	i2c_m_sync_enable(&I2C_0);
    14d2:	0020      	movs	r0, r4
    14d4:	4b0b      	ldr	r3, [pc, #44]	; (1504 <I2C_init+0xa4>)
    14d6:	4798      	blx	r3
	
}
    14d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    14da:	46c0      	nop			; (mov r8, r8)
    14dc:	40000400 	.word	0x40000400
    14e0:	40000c00 	.word	0x40000c00
    14e4:	00004010 	.word	0x00004010
    14e8:	0000430c 	.word	0x0000430c
    14ec:	200016e8 	.word	0x200016e8
    14f0:	42001400 	.word	0x42001400
    14f4:	000003a9 	.word	0x000003a9
    14f8:	41004400 	.word	0x41004400
    14fc:	20001724 	.word	0x20001724
    1500:	00000451 	.word	0x00000451
    1504:	000003e9 	.word	0x000003e9

00001508 <IRQ_init>:

void IRQ_init(void){
    1508:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    150a:	4a1a      	ldr	r2, [pc, #104]	; (1574 <IRQ_init+0x6c>)
    150c:	4b1a      	ldr	r3, [pc, #104]	; (1578 <IRQ_init+0x70>)
    150e:	805a      	strh	r2, [r3, #2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1510:	27c0      	movs	r7, #192	; 0xc0
    1512:	05ff      	lsls	r7, r7, #23
    1514:	2380      	movs	r3, #128	; 0x80
    1516:	607b      	str	r3, [r7, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1518:	4b18      	ldr	r3, [pc, #96]	; (157c <IRQ_init+0x74>)
    151a:	4a19      	ldr	r2, [pc, #100]	; (1580 <IRQ_init+0x78>)
    151c:	629a      	str	r2, [r3, #40]	; 0x28
    151e:	4a19      	ldr	r2, [pc, #100]	; (1584 <IRQ_init+0x7c>)
    1520:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1522:	2047      	movs	r0, #71	; 0x47
    1524:	5c19      	ldrb	r1, [r3, r0]
    1526:	2204      	movs	r2, #4
    1528:	4391      	bics	r1, r2
    152a:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    152c:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    152e:	2501      	movs	r5, #1
    1530:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1532:	2401      	movs	r4, #1
    1534:	4321      	orrs	r1, r4
    1536:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1538:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    153a:	3814      	subs	r0, #20
    153c:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    153e:	260f      	movs	r6, #15
    1540:	4031      	ands	r1, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1542:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1544:	2180      	movs	r1, #128	; 0x80
    1546:	0489      	lsls	r1, r1, #18
    1548:	6079      	str	r1, [r7, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    154a:	490f      	ldr	r1, [pc, #60]	; (1588 <IRQ_init+0x80>)
    154c:	6299      	str	r1, [r3, #40]	; 0x28
    154e:	490f      	ldr	r1, [pc, #60]	; (158c <IRQ_init+0x84>)
    1550:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1552:	2159      	movs	r1, #89	; 0x59
    1554:	5c58      	ldrb	r0, [r3, r1]
    1556:	4390      	bics	r0, r2
    1558:	5458      	strb	r0, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    155a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    155c:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    155e:	4322      	orrs	r2, r4
    1560:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1562:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1564:	391d      	subs	r1, #29
    1566:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1568:	4032      	ands	r2, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    156a:	545a      	strb	r2, [r3, r1]
	
	gpio_set_pin_direction(RTC_INT, GPIO_DIRECTION_IN);
	gpio_set_pin_pull_mode(RTC_INT, GPIO_PULL_OFF);
	gpio_set_pin_function(RTC_INT, PINMUX_PA25A_EIC_EXTINT13);

	ext_irq_init();
    156c:	4b08      	ldr	r3, [pc, #32]	; (1590 <IRQ_init+0x88>)
    156e:	4798      	blx	r3
}
    1570:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1572:	46c0      	nop			; (mov r8, r8)
    1574:	00004003 	.word	0x00004003
    1578:	40000c00 	.word	0x40000c00
    157c:	41004400 	.word	0x41004400
    1580:	40020080 	.word	0x40020080
    1584:	c0020000 	.word	0xc0020000
    1588:	40020000 	.word	0x40020000
    158c:	c0020200 	.word	0xc0020200
    1590:	00000225 	.word	0x00000225

00001594 <mcu_init>:



void mcu_init(void)
{
    1594:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    1596:	4b0a      	ldr	r3, [pc, #40]	; (15c0 <mcu_init+0x2c>)
    1598:	4798      	blx	r3
	init_mcu();
	GPIO_init();
    159a:	4b0a      	ldr	r3, [pc, #40]	; (15c4 <mcu_init+0x30>)
    159c:	4798      	blx	r3
	SPI_init();
    159e:	4b0a      	ldr	r3, [pc, #40]	; (15c8 <mcu_init+0x34>)
    15a0:	4798      	blx	r3
	I2C_init();
    15a2:	4b0a      	ldr	r3, [pc, #40]	; (15cc <mcu_init+0x38>)
    15a4:	4798      	blx	r3
	IRQ_init();
    15a6:	4b0a      	ldr	r3, [pc, #40]	; (15d0 <mcu_init+0x3c>)
    15a8:	4798      	blx	r3
	
	
	ext_irq_register(RTC_INT, I2C_RTC_Handler);
    15aa:	490a      	ldr	r1, [pc, #40]	; (15d4 <mcu_init+0x40>)
    15ac:	2019      	movs	r0, #25
    15ae:	4c0a      	ldr	r4, [pc, #40]	; (15d8 <mcu_init+0x44>)
    15b0:	47a0      	blx	r4
	ext_irq_register(RF_INT, RF_int_Handler);	
    15b2:	490a      	ldr	r1, [pc, #40]	; (15dc <mcu_init+0x48>)
    15b4:	2007      	movs	r0, #7
    15b6:	47a0      	blx	r4
	
	delay_driver_init();
    15b8:	4b09      	ldr	r3, [pc, #36]	; (15e0 <mcu_init+0x4c>)
    15ba:	4798      	blx	r3
	//...Peripherial init
	
    15bc:	bd10      	pop	{r4, pc}
    15be:	46c0      	nop			; (mov r8, r8)
    15c0:	00000615 	.word	0x00000615
    15c4:	00001241 	.word	0x00001241
    15c8:	00001355 	.word	0x00001355
    15cc:	00001461 	.word	0x00001461
    15d0:	00001509 	.word	0x00001509
    15d4:	00001189 	.word	0x00001189
    15d8:	00000259 	.word	0x00000259
    15dc:	0000119d 	.word	0x0000119d
    15e0:	0000017d 	.word	0x0000017d

000015e4 <epdReset>:
/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	if (level) {
    15e4:	2800      	cmp	r0, #0
    15e6:	d105      	bne.n	15f4 <epdReset+0x10>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    15e8:	2280      	movs	r2, #128	; 0x80
    15ea:	0112      	lsls	r2, r2, #4
    15ec:	23c0      	movs	r3, #192	; 0xc0
    15ee:	05db      	lsls	r3, r3, #23
    15f0:	615a      	str	r2, [r3, #20]
	
}

void epdReset(bool arg){
	gpio_set_pin_level(EP_RST, arg);
}
    15f2:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    15f4:	2280      	movs	r2, #128	; 0x80
    15f6:	0112      	lsls	r2, r2, #4
    15f8:	23c0      	movs	r3, #192	; 0xc0
    15fa:	05db      	lsls	r3, r3, #23
    15fc:	619a      	str	r2, [r3, #24]
    15fe:	e7f8      	b.n	15f2 <epdReset+0xe>

00001600 <epdSelect>:
    1600:	2800      	cmp	r0, #0
    1602:	d105      	bne.n	1610 <epdSelect+0x10>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1604:	2280      	movs	r2, #128	; 0x80
    1606:	0212      	lsls	r2, r2, #8
    1608:	23c0      	movs	r3, #192	; 0xc0
    160a:	05db      	lsls	r3, r3, #23
    160c:	615a      	str	r2, [r3, #20]

void epdSelect(bool arg){
	gpio_set_pin_level(EP_CS, arg);
}
    160e:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1610:	2280      	movs	r2, #128	; 0x80
    1612:	0212      	lsls	r2, r2, #8
    1614:	23c0      	movs	r3, #192	; 0xc0
    1616:	05db      	lsls	r3, r3, #23
    1618:	619a      	str	r2, [r3, #24]
    161a:	e7f8      	b.n	160e <epdSelect+0xe>

0000161c <epdCommand>:
    161c:	2800      	cmp	r0, #0
    161e:	d105      	bne.n	162c <epdCommand+0x10>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1620:	2280      	movs	r2, #128	; 0x80
    1622:	0252      	lsls	r2, r2, #9
    1624:	23c0      	movs	r3, #192	; 0xc0
    1626:	05db      	lsls	r3, r3, #23
    1628:	615a      	str	r2, [r3, #20]

void epdCommand(bool arg){
	gpio_set_pin_level(EP_CMD, arg);
}
    162a:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    162c:	2280      	movs	r2, #128	; 0x80
    162e:	0252      	lsls	r2, r2, #9
    1630:	23c0      	movs	r3, #192	; 0xc0
    1632:	05db      	lsls	r3, r3, #23
    1634:	619a      	str	r2, [r3, #24]
    1636:	e7f8      	b.n	162a <epdCommand+0xe>

00001638 <epdWriteBuff>:

void epdWriteByte(uint8_t arg){
	SPI0_WriteBuff(arg);
}

void epdWriteBuff(uint8_t* buff, uint16_t len){
    1638:	b510      	push	{r4, lr}
	SPI0_WriteBuff(buff, len);
    163a:	4b01      	ldr	r3, [pc, #4]	; (1640 <epdWriteBuff+0x8>)
    163c:	4798      	blx	r3
}
    163e:	bd10      	pop	{r4, pc}
    1640:	000011c1 	.word	0x000011c1

00001644 <screenSpi>:

uint8_t screenSpi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    1644:	b510      	push	{r4, lr}
	
	switch(msg)
    1646:	3914      	subs	r1, #20
    1648:	b2cc      	uxtb	r4, r1
    164a:	2c37      	cmp	r4, #55	; 0x37
    164c:	d803      	bhi.n	1656 <screenSpi+0x12>
    164e:	00a1      	lsls	r1, r4, #2
    1650:	4819      	ldr	r0, [pc, #100]	; (16b8 <screenSpi+0x74>)
    1652:	5841      	ldr	r1, [r0, r1]
    1654:	468f      	mov	pc, r1
		case U8X8_MSG_BYTE_END_TRANSFER:
			epdSelect(true);
			epdCommand(true);
			break;
		default:
			return 0;
    1656:	2000      	movs	r0, #0
    1658:	e02c      	b.n	16b4 <screenSpi+0x70>
			epdReset((arg_int != 1) ?  false : true);
    165a:	3a01      	subs	r2, #1
    165c:	4250      	negs	r0, r2
    165e:	4150      	adcs	r0, r2
    1660:	b2c0      	uxtb	r0, r0
    1662:	4b16      	ldr	r3, [pc, #88]	; (16bc <screenSpi+0x78>)
    1664:	4798      	blx	r3
	}
	return 1;
    1666:	2001      	movs	r0, #1
			break;
    1668:	e024      	b.n	16b4 <screenSpi+0x70>
			delay_ms(arg_int);
    166a:	b290      	uxth	r0, r2
    166c:	4b14      	ldr	r3, [pc, #80]	; (16c0 <screenSpi+0x7c>)
    166e:	4798      	blx	r3
	return 1;
    1670:	2001      	movs	r0, #1
			break;
    1672:	e01f      	b.n	16b4 <screenSpi+0x70>
			epdWriteBuff(arg_ptr, arg_int);
    1674:	b291      	uxth	r1, r2
    1676:	0018      	movs	r0, r3
    1678:	4b12      	ldr	r3, [pc, #72]	; (16c4 <screenSpi+0x80>)
    167a:	4798      	blx	r3
	return 1;
    167c:	2001      	movs	r0, #1
			break;
    167e:	e019      	b.n	16b4 <screenSpi+0x70>
			epdSelect(false);
    1680:	2000      	movs	r0, #0
    1682:	4b11      	ldr	r3, [pc, #68]	; (16c8 <screenSpi+0x84>)
    1684:	4798      	blx	r3
	return 1;
    1686:	2001      	movs	r0, #1
			break;
    1688:	e014      	b.n	16b4 <screenSpi+0x70>
			epdCommand(arg_int);
    168a:	1e50      	subs	r0, r2, #1
    168c:	4182      	sbcs	r2, r0
    168e:	b2d0      	uxtb	r0, r2
    1690:	4b0e      	ldr	r3, [pc, #56]	; (16cc <screenSpi+0x88>)
    1692:	4798      	blx	r3
	return 1;
    1694:	2001      	movs	r0, #1
			break;
    1696:	e00d      	b.n	16b4 <screenSpi+0x70>
			epdSelect(false);
    1698:	2000      	movs	r0, #0
    169a:	4b0b      	ldr	r3, [pc, #44]	; (16c8 <screenSpi+0x84>)
    169c:	4798      	blx	r3
	return 1;
    169e:	2001      	movs	r0, #1
			break;
    16a0:	e008      	b.n	16b4 <screenSpi+0x70>
			epdSelect(true);
    16a2:	2001      	movs	r0, #1
    16a4:	4b08      	ldr	r3, [pc, #32]	; (16c8 <screenSpi+0x84>)
    16a6:	4798      	blx	r3
			epdCommand(true);
    16a8:	2001      	movs	r0, #1
    16aa:	4b08      	ldr	r3, [pc, #32]	; (16cc <screenSpi+0x88>)
    16ac:	4798      	blx	r3
	return 1;
    16ae:	2001      	movs	r0, #1
			break;
    16b0:	e000      	b.n	16b4 <screenSpi+0x70>
	return 1;
    16b2:	2001      	movs	r0, #1
}
    16b4:	bd10      	pop	{r4, pc}
    16b6:	46c0      	nop			; (mov r8, r8)
    16b8:	00002d20 	.word	0x00002d20
    16bc:	000015e5 	.word	0x000015e5
    16c0:	000001c1 	.word	0x000001c1
    16c4:	00001639 	.word	0x00001639
    16c8:	00001601 	.word	0x00001601
    16cc:	0000161d 	.word	0x0000161d

000016d0 <u8g2_send_tile_row>:
}

/*============================================*/

static void u8g2_send_tile_row(u8g2_t *u8g2, uint8_t src_tile_row, uint8_t dest_tile_row)
{
    16d0:	b510      	push	{r4, lr}
    16d2:	b082      	sub	sp, #8
  uint8_t *ptr;
  uint16_t offset;
  uint8_t w;
  
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    16d4:	6803      	ldr	r3, [r0, #0]
    16d6:	7c1b      	ldrb	r3, [r3, #16]
  offset = src_tile_row;
  ptr = u8g2->tile_buf_ptr;
  offset *= w;
    16d8:	4359      	muls	r1, r3
  offset *= 8;
    16da:	00c9      	lsls	r1, r1, #3
    16dc:	b289      	uxth	r1, r1
  ptr += offset;
    16de:	6b44      	ldr	r4, [r0, #52]	; 0x34
    16e0:	46a4      	mov	ip, r4
    16e2:	4461      	add	r1, ip
  u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr);
    16e4:	9100      	str	r1, [sp, #0]
    16e6:	2100      	movs	r1, #0
    16e8:	4c01      	ldr	r4, [pc, #4]	; (16f0 <u8g2_send_tile_row+0x20>)
    16ea:	47a0      	blx	r4
}
    16ec:	b002      	add	sp, #8
    16ee:	bd10      	pop	{r4, pc}
    16f0:	000024b9 	.word	0x000024b9

000016f4 <u8g2_send_buffer>:
  For most displays, this will make the content visible to the user.
  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()
*/
static void u8g2_send_buffer(u8g2_t *u8g2) U8X8_NOINLINE;
static void u8g2_send_buffer(u8g2_t *u8g2)
{
    16f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    16f6:	46c6      	mov	lr, r8
    16f8:	b500      	push	{lr}
    16fa:	0006      	movs	r6, r0
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t dest_max;

  src_row = 0;
  src_max = u8g2->tile_buf_height;
    16fc:	2338      	movs	r3, #56	; 0x38
    16fe:	5cc7      	ldrb	r7, [r0, r3]
  dest_row = u8g2->tile_curr_row;
    1700:	3301      	adds	r3, #1
    1702:	5cc5      	ldrb	r5, [r0, r3]
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
    1704:	6803      	ldr	r3, [r0, #0]
    1706:	7c5b      	ldrb	r3, [r3, #17]
    1708:	4698      	mov	r8, r3
  src_row = 0;
    170a:	2400      	movs	r4, #0
  
  do
  {
    u8g2_send_tile_row(u8g2, src_row, dest_row);
    170c:	002a      	movs	r2, r5
    170e:	0021      	movs	r1, r4
    1710:	0030      	movs	r0, r6
    1712:	4b06      	ldr	r3, [pc, #24]	; (172c <u8g2_send_buffer+0x38>)
    1714:	4798      	blx	r3
    src_row++;
    1716:	3401      	adds	r4, #1
    1718:	b2e4      	uxtb	r4, r4
    dest_row++;
    171a:	3501      	adds	r5, #1
    171c:	b2ed      	uxtb	r5, r5
  } while( src_row < src_max && dest_row < dest_max );
    171e:	42a7      	cmp	r7, r4
    1720:	d901      	bls.n	1726 <u8g2_send_buffer+0x32>
    1722:	45a8      	cmp	r8, r5
    1724:	d8f2      	bhi.n	170c <u8g2_send_buffer+0x18>
}
    1726:	bc04      	pop	{r2}
    1728:	4690      	mov	r8, r2
    172a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    172c:	000016d1 	.word	0x000016d1

00001730 <u8g2_ClearBuffer>:
{
    1730:	b510      	push	{r4, lr}
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    1732:	6803      	ldr	r3, [r0, #0]
    1734:	7c1b      	ldrb	r3, [r3, #16]
  cnt *= u8g2->tile_buf_height;
    1736:	2238      	movs	r2, #56	; 0x38
    1738:	5c82      	ldrb	r2, [r0, r2]
    173a:	435a      	muls	r2, r3
  cnt *= 8;
    173c:	00d2      	lsls	r2, r2, #3
  memset(u8g2->tile_buf_ptr, 0, cnt);
    173e:	6b40      	ldr	r0, [r0, #52]	; 0x34
    1740:	2100      	movs	r1, #0
    1742:	4b01      	ldr	r3, [pc, #4]	; (1748 <u8g2_ClearBuffer+0x18>)
    1744:	4798      	blx	r3
}
    1746:	bd10      	pop	{r4, pc}
    1748:	00002c59 	.word	0x00002c59

0000174c <u8g2_SendBuffer>:

/* same as u8g2_send_buffer but also send the DISPLAY_REFRESH message (used by SSD1606) */
void u8g2_SendBuffer(u8g2_t *u8g2)
{
    174c:	b510      	push	{r4, lr}
    174e:	0004      	movs	r4, r0
  u8g2_send_buffer(u8g2);
    1750:	4b02      	ldr	r3, [pc, #8]	; (175c <u8g2_SendBuffer+0x10>)
    1752:	4798      	blx	r3
  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  
    1754:	0020      	movs	r0, r4
    1756:	4b02      	ldr	r3, [pc, #8]	; (1760 <u8g2_SendBuffer+0x14>)
    1758:	4798      	blx	r3
}
    175a:	bd10      	pop	{r4, pc}
    175c:	000016f5 	.word	0x000016f5
    1760:	000024f3 	.word	0x000024f3

00001764 <u8g2_m_19_304_f>:
	#ifdef U8G2_USE_DYNAMIC_ALLOC
	*page_cnt = 19;
	return 0;
	#else
	static uint8_t buf[5776];
	*page_cnt = 19;
    1764:	2313      	movs	r3, #19
    1766:	7003      	strb	r3, [r0, #0]
	return buf;
	#endif
}
    1768:	4800      	ldr	r0, [pc, #0]	; (176c <u8g2_m_19_304_f+0x8>)
    176a:	4770      	bx	lr
    176c:	20000050 	.word	0x20000050

00001770 <u8g2_Setup_GDEY0154_152x304_f>:
  buf = u8g2_m_48_30_f(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_horizontal_right_lsb, rotation);
}

void u8g2_Setup_GDEY0154_152x304_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    1770:	b570      	push	{r4, r5, r6, lr}
    1772:	b084      	sub	sp, #16
    1774:	0004      	movs	r4, r0
    1776:	000e      	movs	r6, r1
	uint8_t tile_buf_height;
	uint8_t *buf;
	u8g2_SetupDisplay(u8g2, u8x8_d_gdey0154_152x304, u8x8_cad_011, byte_cb, gpio_and_delay_cb);
    1778:	9300      	str	r3, [sp, #0]
    177a:	0013      	movs	r3, r2
    177c:	4a08      	ldr	r2, [pc, #32]	; (17a0 <u8g2_Setup_GDEY0154_152x304_f+0x30>)
    177e:	4909      	ldr	r1, [pc, #36]	; (17a4 <u8g2_Setup_GDEY0154_152x304_f+0x34>)
    1780:	4d09      	ldr	r5, [pc, #36]	; (17a8 <u8g2_Setup_GDEY0154_152x304_f+0x38>)
    1782:	47a8      	blx	r5
	buf = u8g2_m_19_304_f(&tile_buf_height);
    1784:	250f      	movs	r5, #15
    1786:	446d      	add	r5, sp
    1788:	0028      	movs	r0, r5
    178a:	4b08      	ldr	r3, [pc, #32]	; (17ac <u8g2_Setup_GDEY0154_152x304_f+0x3c>)
    178c:	4798      	blx	r3
    178e:	0001      	movs	r1, r0
	u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
    1790:	782a      	ldrb	r2, [r5, #0]
    1792:	9600      	str	r6, [sp, #0]
    1794:	4b06      	ldr	r3, [pc, #24]	; (17b0 <u8g2_Setup_GDEY0154_152x304_f+0x40>)
    1796:	0020      	movs	r0, r4
    1798:	4c06      	ldr	r4, [pc, #24]	; (17b4 <u8g2_Setup_GDEY0154_152x304_f+0x44>)
    179a:	47a0      	blx	r4
}
    179c:	b004      	add	sp, #16
    179e:	bd70      	pop	{r4, r5, r6, pc}
    17a0:	000023ed 	.word	0x000023ed
    17a4:	00002659 	.word	0x00002659
    17a8:	00002721 	.word	0x00002721
    17ac:	00001765 	.word	0x00001765
    17b0:	000020bd 	.word	0x000020bd
    17b4:	00002291 	.word	0x00002291

000017b8 <u8g2_font_get_byte>:
/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
{
  font += offset;
  return u8x8_pgm_read( font );  
    17b8:	5c40      	ldrb	r0, [r0, r1]
}
    17ba:	4770      	bx	lr

000017bc <u8g2_font_get_word>:

static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
{
    uint16_t pos;
    font += offset;
    17bc:	1841      	adds	r1, r0, r1
    pos = u8x8_pgm_read( font );
    17be:	7808      	ldrb	r0, [r1, #0]
    font++;
    pos <<= 8;
    17c0:	0200      	lsls	r0, r0, #8
    pos += u8x8_pgm_read( font);
    17c2:	784b      	ldrb	r3, [r1, #1]
    17c4:	18c0      	adds	r0, r0, r3
    17c6:	b280      	uxth	r0, r0
    return pos;
}
    17c8:	4770      	bx	lr

000017ca <u8g2_font_calc_vref_font>:
/* callback procedures to correct the y position */

u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
{
  return 0;
}
    17ca:	2000      	movs	r0, #0
    17cc:	4770      	bx	lr
	...

000017d0 <u8g2_read_font_info>:
{
    17d0:	b570      	push	{r4, r5, r6, lr}
    17d2:	0004      	movs	r4, r0
    17d4:	000d      	movs	r5, r1
  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
    17d6:	2100      	movs	r1, #0
    17d8:	0028      	movs	r0, r5
    17da:	4e28      	ldr	r6, [pc, #160]	; (187c <u8g2_read_font_info+0xac>)
    17dc:	47b0      	blx	r6
    17de:	7020      	strb	r0, [r4, #0]
  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
    17e0:	2101      	movs	r1, #1
    17e2:	0028      	movs	r0, r5
    17e4:	47b0      	blx	r6
    17e6:	7060      	strb	r0, [r4, #1]
  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
    17e8:	2102      	movs	r1, #2
    17ea:	0028      	movs	r0, r5
    17ec:	47b0      	blx	r6
    17ee:	70a0      	strb	r0, [r4, #2]
  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
    17f0:	2103      	movs	r1, #3
    17f2:	0028      	movs	r0, r5
    17f4:	47b0      	blx	r6
    17f6:	70e0      	strb	r0, [r4, #3]
  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
    17f8:	2104      	movs	r1, #4
    17fa:	0028      	movs	r0, r5
    17fc:	47b0      	blx	r6
    17fe:	7120      	strb	r0, [r4, #4]
  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
    1800:	2105      	movs	r1, #5
    1802:	0028      	movs	r0, r5
    1804:	47b0      	blx	r6
    1806:	7160      	strb	r0, [r4, #5]
  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
    1808:	2106      	movs	r1, #6
    180a:	0028      	movs	r0, r5
    180c:	47b0      	blx	r6
    180e:	71a0      	strb	r0, [r4, #6]
  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
    1810:	2107      	movs	r1, #7
    1812:	0028      	movs	r0, r5
    1814:	47b0      	blx	r6
    1816:	71e0      	strb	r0, [r4, #7]
  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
    1818:	2108      	movs	r1, #8
    181a:	0028      	movs	r0, r5
    181c:	47b0      	blx	r6
    181e:	7220      	strb	r0, [r4, #8]
  font_info->max_char_width = u8g2_font_get_byte(font, 9);
    1820:	2109      	movs	r1, #9
    1822:	0028      	movs	r0, r5
    1824:	47b0      	blx	r6
    1826:	7260      	strb	r0, [r4, #9]
  font_info->max_char_height = u8g2_font_get_byte(font, 10);
    1828:	210a      	movs	r1, #10
    182a:	0028      	movs	r0, r5
    182c:	47b0      	blx	r6
    182e:	72a0      	strb	r0, [r4, #10]
  font_info->x_offset = u8g2_font_get_byte(font, 11);
    1830:	210b      	movs	r1, #11
    1832:	0028      	movs	r0, r5
    1834:	47b0      	blx	r6
    1836:	72e0      	strb	r0, [r4, #11]
  font_info->y_offset = u8g2_font_get_byte(font, 12);
    1838:	210c      	movs	r1, #12
    183a:	0028      	movs	r0, r5
    183c:	47b0      	blx	r6
    183e:	7320      	strb	r0, [r4, #12]
  font_info->ascent_A = u8g2_font_get_byte(font, 13);
    1840:	210d      	movs	r1, #13
    1842:	0028      	movs	r0, r5
    1844:	47b0      	blx	r6
    1846:	7360      	strb	r0, [r4, #13]
  font_info->descent_g = u8g2_font_get_byte(font, 14);
    1848:	210e      	movs	r1, #14
    184a:	0028      	movs	r0, r5
    184c:	47b0      	blx	r6
    184e:	73a0      	strb	r0, [r4, #14]
  font_info->ascent_para = u8g2_font_get_byte(font, 15);
    1850:	210f      	movs	r1, #15
    1852:	0028      	movs	r0, r5
    1854:	47b0      	blx	r6
    1856:	73e0      	strb	r0, [r4, #15]
  font_info->descent_para = u8g2_font_get_byte(font, 16);
    1858:	2110      	movs	r1, #16
    185a:	0028      	movs	r0, r5
    185c:	47b0      	blx	r6
    185e:	7420      	strb	r0, [r4, #16]
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
    1860:	2111      	movs	r1, #17
    1862:	0028      	movs	r0, r5
    1864:	4e06      	ldr	r6, [pc, #24]	; (1880 <u8g2_read_font_info+0xb0>)
    1866:	47b0      	blx	r6
    1868:	8260      	strh	r0, [r4, #18]
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
    186a:	2113      	movs	r1, #19
    186c:	0028      	movs	r0, r5
    186e:	47b0      	blx	r6
    1870:	82a0      	strh	r0, [r4, #20]
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
    1872:	2115      	movs	r1, #21
    1874:	0028      	movs	r0, r5
    1876:	47b0      	blx	r6
    1878:	82e0      	strh	r0, [r4, #22]
}
    187a:	bd70      	pop	{r4, r5, r6, pc}
    187c:	000017b9 	.word	0x000017b9
    1880:	000017bd 	.word	0x000017bd

00001884 <u8g2_font_decode_get_unsigned_bits>:
{
    1884:	b5f0      	push	{r4, r5, r6, r7, lr}
    1886:	0005      	movs	r5, r0
  uint8_t bit_pos = f->decode_bit_pos;
    1888:	7b06      	ldrb	r6, [r0, #12]
  val = u8x8_pgm_read( f->decode_ptr );  
    188a:	6807      	ldr	r7, [r0, #0]
    188c:	7838      	ldrb	r0, [r7, #0]
  val >>= bit_pos;
    188e:	4130      	asrs	r0, r6
    1890:	b2c4      	uxtb	r4, r0
  bit_pos_plus_cnt += cnt;
    1892:	1872      	adds	r2, r6, r1
    1894:	b2d2      	uxtb	r2, r2
  if ( bit_pos_plus_cnt >= 8 )
    1896:	2a07      	cmp	r2, #7
    1898:	d90a      	bls.n	18b0 <u8g2_font_decode_get_unsigned_bits+0x2c>
    s -= bit_pos;
    189a:	2308      	movs	r3, #8
    189c:	1b9b      	subs	r3, r3, r6
    189e:	b2db      	uxtb	r3, r3
    f->decode_ptr++;
    18a0:	1c7c      	adds	r4, r7, #1
    18a2:	602c      	str	r4, [r5, #0]
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
    18a4:	787c      	ldrb	r4, [r7, #1]
    18a6:	409c      	lsls	r4, r3
    18a8:	4304      	orrs	r4, r0
    18aa:	b2e4      	uxtb	r4, r4
    bit_pos_plus_cnt -= 8;
    18ac:	3a08      	subs	r2, #8
    18ae:	b2d2      	uxtb	r2, r2
  val &= (1U<<cnt)-1;
    18b0:	2301      	movs	r3, #1
    18b2:	408b      	lsls	r3, r1
    18b4:	3b01      	subs	r3, #1
    18b6:	4023      	ands	r3, r4
    18b8:	0018      	movs	r0, r3
  f->decode_bit_pos = bit_pos_plus_cnt;
    18ba:	732a      	strb	r2, [r5, #12]
}
    18bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000018c0 <u8g2_font_setup_decode>:
{
    18c0:	b570      	push	{r4, r5, r6, lr}
    18c2:	0005      	movs	r5, r0
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    18c4:	0004      	movs	r4, r0
    18c6:	3460      	adds	r4, #96	; 0x60
  decode->decode_ptr = glyph_data;
    18c8:	6601      	str	r1, [r0, #96]	; 0x60
  decode->decode_bit_pos = 0;
    18ca:	2300      	movs	r3, #0
    18cc:	7323      	strb	r3, [r4, #12]
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
    18ce:	3378      	adds	r3, #120	; 0x78
    18d0:	5cc1      	ldrb	r1, [r0, r3]
    18d2:	0020      	movs	r0, r4
    18d4:	4e07      	ldr	r6, [pc, #28]	; (18f4 <u8g2_font_setup_decode+0x34>)
    18d6:	47b0      	blx	r6
    18d8:	72a0      	strb	r0, [r4, #10]
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
    18da:	2379      	movs	r3, #121	; 0x79
    18dc:	5ce9      	ldrb	r1, [r5, r3]
    18de:	0020      	movs	r0, r4
    18e0:	47b0      	blx	r6
    18e2:	72e0      	strb	r0, [r4, #11]
  decode->fg_color = u8g2->draw_color;
    18e4:	2392      	movs	r3, #146	; 0x92
    18e6:	5ceb      	ldrb	r3, [r5, r3]
    18e8:	73a3      	strb	r3, [r4, #14]
  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
    18ea:	425a      	negs	r2, r3
    18ec:	4153      	adcs	r3, r2
    18ee:	73e3      	strb	r3, [r4, #15]
}
    18f0:	bd70      	pop	{r4, r5, r6, pc}
    18f2:	46c0      	nop			; (mov r8, r8)
    18f4:	00001885 	.word	0x00001885

000018f8 <u8g2_font_decode_get_signed_bits>:
{
    18f8:	b510      	push	{r4, lr}
    18fa:	000c      	movs	r4, r1
  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
    18fc:	4b04      	ldr	r3, [pc, #16]	; (1910 <u8g2_font_decode_get_signed_bits+0x18>)
    18fe:	4798      	blx	r3
  cnt--;
    1900:	3c01      	subs	r4, #1
    1902:	b2e4      	uxtb	r4, r4
  d <<= cnt;
    1904:	2301      	movs	r3, #1
    1906:	40a3      	lsls	r3, r4
  v -= d;
    1908:	1ac0      	subs	r0, r0, r3
    190a:	b240      	sxtb	r0, r0
}
    190c:	bd10      	pop	{r4, pc}
    190e:	46c0      	nop			; (mov r8, r8)
    1910:	00001885 	.word	0x00001885

00001914 <u8g2_add_vector_y>:
  switch(dir)
    1914:	2b01      	cmp	r3, #1
    1916:	d009      	beq.n	192c <u8g2_add_vector_y+0x18>
    1918:	2b00      	cmp	r3, #0
    191a:	d004      	beq.n	1926 <u8g2_add_vector_y+0x12>
    191c:	2b02      	cmp	r3, #2
    191e:	d008      	beq.n	1932 <u8g2_add_vector_y+0x1e>
      dy -= x;
    1920:	1a40      	subs	r0, r0, r1
    1922:	b280      	uxth	r0, r0
      break;      
    1924:	e001      	b.n	192a <u8g2_add_vector_y+0x16>
      dy += y;
    1926:	1880      	adds	r0, r0, r2
    1928:	b280      	uxth	r0, r0
}
    192a:	4770      	bx	lr
      dy += x;
    192c:	1840      	adds	r0, r0, r1
    192e:	b280      	uxth	r0, r0
      break;
    1930:	e7fb      	b.n	192a <u8g2_add_vector_y+0x16>
      dy -= y;
    1932:	1a80      	subs	r0, r0, r2
    1934:	b280      	uxth	r0, r0
      break;
    1936:	e7f8      	b.n	192a <u8g2_add_vector_y+0x16>

00001938 <u8g2_add_vector_x>:
  switch(dir)
    1938:	2b01      	cmp	r3, #1
    193a:	d009      	beq.n	1950 <u8g2_add_vector_x+0x18>
    193c:	2b00      	cmp	r3, #0
    193e:	d004      	beq.n	194a <u8g2_add_vector_x+0x12>
    1940:	2b02      	cmp	r3, #2
    1942:	d008      	beq.n	1956 <u8g2_add_vector_x+0x1e>
      dx += y;
    1944:	1880      	adds	r0, r0, r2
    1946:	b280      	uxth	r0, r0
      break;      
    1948:	e001      	b.n	194e <u8g2_add_vector_x+0x16>
      dx += x;
    194a:	1840      	adds	r0, r0, r1
    194c:	b280      	uxth	r0, r0
}
    194e:	4770      	bx	lr
      dx -= y;
    1950:	1a80      	subs	r0, r0, r2
    1952:	b280      	uxth	r0, r0
      break;
    1954:	e7fb      	b.n	194e <u8g2_add_vector_x+0x16>
      dx -= x;
    1956:	1a40      	subs	r0, r0, r1
    1958:	b280      	uxth	r0, r0
      break;
    195a:	e7f8      	b.n	194e <u8g2_add_vector_x+0x16>

0000195c <u8g2_font_decode_len>:
{
    195c:	b5f0      	push	{r4, r5, r6, r7, lr}
    195e:	46de      	mov	lr, fp
    1960:	4657      	mov	r7, sl
    1962:	464e      	mov	r6, r9
    1964:	4645      	mov	r5, r8
    1966:	b5e0      	push	{r5, r6, r7, lr}
    1968:	b089      	sub	sp, #36	; 0x24
    196a:	000d      	movs	r5, r1
    196c:	4693      	mov	fp, r2
  lx = decode->x;
    196e:	0003      	movs	r3, r0
    1970:	3360      	adds	r3, #96	; 0x60
    1972:	7a1a      	ldrb	r2, [r3, #8]
    1974:	4692      	mov	sl, r2
  ly = decode->y;
    1976:	7a5b      	ldrb	r3, [r3, #9]
    1978:	4698      	mov	r8, r3
    197a:	4646      	mov	r6, r8
    197c:	46d9      	mov	r9, fp
    197e:	4680      	mov	r8, r0
    1980:	e029      	b.n	19d6 <u8g2_font_decode_len+0x7a>
      current = cnt;
    1982:	9506      	str	r5, [sp, #24]
    x = decode->target_x;
    1984:	4643      	mov	r3, r8
    1986:	3360      	adds	r3, #96	; 0x60
    1988:	8898      	ldrh	r0, [r3, #4]
    y = decode->target_y;
    198a:	88da      	ldrh	r2, [r3, #6]
    198c:	4693      	mov	fp, r2
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
    198e:	4652      	mov	r2, sl
    1990:	4669      	mov	r1, sp
    1992:	730a      	strb	r2, [r1, #12]
    1994:	270c      	movs	r7, #12
    1996:	57cf      	ldrsb	r7, [r1, r7]
    1998:	b272      	sxtb	r2, r6
    199a:	7c1b      	ldrb	r3, [r3, #16]
    199c:	9303      	str	r3, [sp, #12]
    199e:	9204      	str	r2, [sp, #16]
    19a0:	9705      	str	r7, [sp, #20]
    19a2:	0039      	movs	r1, r7
    19a4:	4f28      	ldr	r7, [pc, #160]	; (1a48 <u8g2_font_decode_len+0xec>)
    19a6:	47b8      	blx	r7
    19a8:	9007      	str	r0, [sp, #28]
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
    19aa:	9b03      	ldr	r3, [sp, #12]
    19ac:	9a04      	ldr	r2, [sp, #16]
    19ae:	9905      	ldr	r1, [sp, #20]
    19b0:	4658      	mov	r0, fp
    19b2:	4f26      	ldr	r7, [pc, #152]	; (1a4c <u8g2_font_decode_len+0xf0>)
    19b4:	47b8      	blx	r7
    if ( is_foreground )
    19b6:	464b      	mov	r3, r9
    19b8:	2b00      	cmp	r3, #0
    19ba:	d116      	bne.n	19ea <u8g2_font_decode_len+0x8e>
    else if ( decode->is_transparent == 0 )    
    19bc:	4643      	mov	r3, r8
    19be:	3360      	adds	r3, #96	; 0x60
    19c0:	7b5b      	ldrb	r3, [r3, #13]
    19c2:	2b00      	cmp	r3, #0
    19c4:	d021      	beq.n	1a0a <u8g2_font_decode_len+0xae>
    if ( cnt < rem )
    19c6:	42a5      	cmp	r5, r4
    19c8:	d32f      	bcc.n	1a2a <u8g2_font_decode_len+0xce>
    cnt -= rem;
    19ca:	1b2d      	subs	r5, r5, r4
    19cc:	b2ed      	uxtb	r5, r5
    ly++;
    19ce:	3601      	adds	r6, #1
    19d0:	b2f6      	uxtb	r6, r6
    lx = 0;
    19d2:	2300      	movs	r3, #0
    19d4:	469a      	mov	sl, r3
    rem = decode->glyph_width;
    19d6:	4643      	mov	r3, r8
    19d8:	3360      	adds	r3, #96	; 0x60
    19da:	7a9c      	ldrb	r4, [r3, #10]
    rem -= lx;
    19dc:	4653      	mov	r3, sl
    19de:	1ae4      	subs	r4, r4, r3
    19e0:	b2e4      	uxtb	r4, r4
    if ( cnt < rem )
    19e2:	42a5      	cmp	r5, r4
    19e4:	d3cd      	bcc.n	1982 <u8g2_font_decode_len+0x26>
    current = rem;
    19e6:	9406      	str	r4, [sp, #24]
    19e8:	e7cc      	b.n	1984 <u8g2_font_decode_len+0x28>
      u8g2->draw_color = decode->fg_color;			/* draw_color will be restored later */
    19ea:	4643      	mov	r3, r8
    19ec:	3360      	adds	r3, #96	; 0x60
    19ee:	7b9a      	ldrb	r2, [r3, #14]
    19f0:	2392      	movs	r3, #146	; 0x92
    19f2:	4641      	mov	r1, r8
    19f4:	54ca      	strb	r2, [r1, r3]
      u8g2_DrawHVLine(u8g2, 
    19f6:	466b      	mov	r3, sp
    19f8:	8b1b      	ldrh	r3, [r3, #24]
    19fa:	9a03      	ldr	r2, [sp, #12]
    19fc:	9200      	str	r2, [sp, #0]
    19fe:	0002      	movs	r2, r0
    1a00:	9907      	ldr	r1, [sp, #28]
    1a02:	4640      	mov	r0, r8
    1a04:	4f12      	ldr	r7, [pc, #72]	; (1a50 <u8g2_font_decode_len+0xf4>)
    1a06:	47b8      	blx	r7
    1a08:	e7dd      	b.n	19c6 <u8g2_font_decode_len+0x6a>
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
    1a0a:	4643      	mov	r3, r8
    1a0c:	3360      	adds	r3, #96	; 0x60
    1a0e:	7bda      	ldrb	r2, [r3, #15]
    1a10:	2392      	movs	r3, #146	; 0x92
    1a12:	4641      	mov	r1, r8
    1a14:	54ca      	strb	r2, [r1, r3]
      u8g2_DrawHVLine(u8g2, 
    1a16:	466b      	mov	r3, sp
    1a18:	8b1b      	ldrh	r3, [r3, #24]
    1a1a:	9a03      	ldr	r2, [sp, #12]
    1a1c:	9200      	str	r2, [sp, #0]
    1a1e:	0002      	movs	r2, r0
    1a20:	9907      	ldr	r1, [sp, #28]
    1a22:	4640      	mov	r0, r8
    1a24:	4f0a      	ldr	r7, [pc, #40]	; (1a50 <u8g2_font_decode_len+0xf4>)
    1a26:	47b8      	blx	r7
    1a28:	e7cd      	b.n	19c6 <u8g2_font_decode_len+0x6a>
  lx += cnt;
    1a2a:	002a      	movs	r2, r5
    1a2c:	4452      	add	r2, sl
  decode->x = lx;
    1a2e:	4643      	mov	r3, r8
    1a30:	3360      	adds	r3, #96	; 0x60
    1a32:	721a      	strb	r2, [r3, #8]
  decode->y = ly;  
    1a34:	466a      	mov	r2, sp
    1a36:	7c12      	ldrb	r2, [r2, #16]
    1a38:	725a      	strb	r2, [r3, #9]
}
    1a3a:	b009      	add	sp, #36	; 0x24
    1a3c:	bc3c      	pop	{r2, r3, r4, r5}
    1a3e:	4690      	mov	r8, r2
    1a40:	4699      	mov	r9, r3
    1a42:	46a2      	mov	sl, r4
    1a44:	46ab      	mov	fp, r5
    1a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a48:	00001939 	.word	0x00001939
    1a4c:	00001915 	.word	0x00001915
    1a50:	00001e75 	.word	0x00001e75

00001a54 <u8g2_font_decode_glyph>:
{
    1a54:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a56:	46de      	mov	lr, fp
    1a58:	4657      	mov	r7, sl
    1a5a:	464e      	mov	r6, r9
    1a5c:	4645      	mov	r5, r8
    1a5e:	b5e0      	push	{r5, r6, r7, lr}
    1a60:	b087      	sub	sp, #28
    1a62:	0004      	movs	r4, r0
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    1a64:	0007      	movs	r7, r0
    1a66:	3760      	adds	r7, #96	; 0x60
  u8g2_font_setup_decode(u8g2, glyph_data);     /* set values in u8g2->font_decode data structure */
    1a68:	4b57      	ldr	r3, [pc, #348]	; (1bc8 <u8g2_font_decode_glyph+0x174>)
    1a6a:	4798      	blx	r3
  h = u8g2->font_decode.glyph_height;
    1a6c:	236b      	movs	r3, #107	; 0x6b
    1a6e:	56e3      	ldrsb	r3, [r4, r3]
    1a70:	4698      	mov	r8, r3
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    1a72:	237a      	movs	r3, #122	; 0x7a
    1a74:	5ce1      	ldrb	r1, [r4, r3]
    1a76:	0038      	movs	r0, r7
    1a78:	4e54      	ldr	r6, [pc, #336]	; (1bcc <u8g2_font_decode_glyph+0x178>)
    1a7a:	47b0      	blx	r6
    1a7c:	9002      	str	r0, [sp, #8]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    1a7e:	237b      	movs	r3, #123	; 0x7b
    1a80:	5ce1      	ldrb	r1, [r4, r3]
    1a82:	0038      	movs	r0, r7
    1a84:	47b0      	blx	r6
    1a86:	0005      	movs	r5, r0
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    1a88:	237c      	movs	r3, #124	; 0x7c
    1a8a:	5ce1      	ldrb	r1, [r4, r3]
    1a8c:	0038      	movs	r0, r7
    1a8e:	47b0      	blx	r6
    1a90:	9003      	str	r0, [sp, #12]
  if ( decode->glyph_width > 0 )
    1a92:	230a      	movs	r3, #10
    1a94:	56fb      	ldrsb	r3, [r7, r3]
    1a96:	469a      	mov	sl, r3
    1a98:	2b00      	cmp	r3, #0
    1a9a:	dd5a      	ble.n	1b52 <u8g2_font_decode_glyph+0xfe>
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    1a9c:	4445      	add	r5, r8
    1a9e:	b2ed      	uxtb	r5, r5
    1aa0:	426d      	negs	r5, r5
    1aa2:	b26b      	sxtb	r3, r5
    1aa4:	001a      	movs	r2, r3
    1aa6:	7c3e      	ldrb	r6, [r7, #16]
    1aa8:	88b8      	ldrh	r0, [r7, #4]
    1aaa:	0033      	movs	r3, r6
    1aac:	9205      	str	r2, [sp, #20]
    1aae:	9902      	ldr	r1, [sp, #8]
    1ab0:	4d47      	ldr	r5, [pc, #284]	; (1bd0 <u8g2_font_decode_glyph+0x17c>)
    1ab2:	47a8      	blx	r5
    1ab4:	4683      	mov	fp, r0
    1ab6:	9004      	str	r0, [sp, #16]
    1ab8:	003b      	movs	r3, r7
    1aba:	8098      	strh	r0, [r3, #4]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    1abc:	88f8      	ldrh	r0, [r7, #6]
    1abe:	0033      	movs	r3, r6
    1ac0:	9a05      	ldr	r2, [sp, #20]
    1ac2:	9902      	ldr	r1, [sp, #8]
    1ac4:	4d43      	ldr	r5, [pc, #268]	; (1bd4 <u8g2_font_decode_glyph+0x180>)
    1ac6:	47a8      	blx	r5
    1ac8:	0002      	movs	r2, r0
    1aca:	80f8      	strh	r0, [r7, #6]
      switch(decode->dir)
    1acc:	2e01      	cmp	r6, #1
    1ace:	d048      	beq.n	1b62 <u8g2_font_decode_glyph+0x10e>
    1ad0:	2e00      	cmp	r6, #0
    1ad2:	d005      	beq.n	1ae0 <u8g2_font_decode_glyph+0x8c>
    1ad4:	2e02      	cmp	r6, #2
    1ad6:	d054      	beq.n	1b82 <u8g2_font_decode_glyph+0x12e>
    1ad8:	2e03      	cmp	r6, #3
    1ada:	d066      	beq.n	1baa <u8g2_font_decode_glyph+0x156>
      x1 = x0;
    1adc:	465b      	mov	r3, fp
    1ade:	e007      	b.n	1af0 <u8g2_font_decode_glyph+0x9c>
	    x1 += decode->glyph_width;
    1ae0:	4653      	mov	r3, sl
    1ae2:	4669      	mov	r1, sp
    1ae4:	810b      	strh	r3, [r1, #8]
    1ae6:	890b      	ldrh	r3, [r1, #8]
    1ae8:	445b      	add	r3, fp
    1aea:	b29b      	uxth	r3, r3
	    y1 += h;
    1aec:	4440      	add	r0, r8
    1aee:	b280      	uxth	r0, r0
      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
    1af0:	9000      	str	r0, [sp, #0]
    1af2:	9904      	ldr	r1, [sp, #16]
    1af4:	0020      	movs	r0, r4
    1af6:	4d38      	ldr	r5, [pc, #224]	; (1bd8 <u8g2_font_decode_glyph+0x184>)
    1af8:	47a8      	blx	r5
    1afa:	2800      	cmp	r0, #0
    1afc:	d029      	beq.n	1b52 <u8g2_font_decode_glyph+0xfe>
    decode->x = 0;
    1afe:	0023      	movs	r3, r4
    1b00:	3360      	adds	r3, #96	; 0x60
    1b02:	2200      	movs	r2, #0
    1b04:	721a      	strb	r2, [r3, #8]
    decode->y = 0;
    1b06:	725a      	strb	r2, [r3, #9]
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    1b08:	2376      	movs	r3, #118	; 0x76
    1b0a:	5ce1      	ldrb	r1, [r4, r3]
    1b0c:	0038      	movs	r0, r7
    1b0e:	4d33      	ldr	r5, [pc, #204]	; (1bdc <u8g2_font_decode_glyph+0x188>)
    1b10:	47a8      	blx	r5
    1b12:	0006      	movs	r6, r0
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
    1b14:	2377      	movs	r3, #119	; 0x77
    1b16:	5ce1      	ldrb	r1, [r4, r3]
    1b18:	0038      	movs	r0, r7
    1b1a:	47a8      	blx	r5
    1b1c:	9002      	str	r0, [sp, #8]
	u8g2_font_decode_len(u8g2, a, 0);
    1b1e:	2200      	movs	r2, #0
    1b20:	0031      	movs	r1, r6
    1b22:	0020      	movs	r0, r4
    1b24:	4d2e      	ldr	r5, [pc, #184]	; (1be0 <u8g2_font_decode_glyph+0x18c>)
    1b26:	47a8      	blx	r5
	u8g2_font_decode_len(u8g2, b, 1);
    1b28:	2201      	movs	r2, #1
    1b2a:	9902      	ldr	r1, [sp, #8]
    1b2c:	0020      	movs	r0, r4
    1b2e:	47a8      	blx	r5
      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
    1b30:	2101      	movs	r1, #1
    1b32:	0038      	movs	r0, r7
    1b34:	4b29      	ldr	r3, [pc, #164]	; (1bdc <u8g2_font_decode_glyph+0x188>)
    1b36:	4798      	blx	r3
    1b38:	2800      	cmp	r0, #0
    1b3a:	d1f0      	bne.n	1b1e <u8g2_font_decode_glyph+0xca>
      if ( decode->y >= h )
    1b3c:	0023      	movs	r3, r4
    1b3e:	3360      	adds	r3, #96	; 0x60
    1b40:	7a5b      	ldrb	r3, [r3, #9]
    1b42:	b25b      	sxtb	r3, r3
    1b44:	4598      	cmp	r8, r3
    1b46:	dcdf      	bgt.n	1b08 <u8g2_font_decode_glyph+0xb4>
    u8g2->draw_color = decode->fg_color;
    1b48:	0023      	movs	r3, r4
    1b4a:	3360      	adds	r3, #96	; 0x60
    1b4c:	7b9a      	ldrb	r2, [r3, #14]
    1b4e:	2392      	movs	r3, #146	; 0x92
    1b50:	54e2      	strb	r2, [r4, r3]
}
    1b52:	9803      	ldr	r0, [sp, #12]
    1b54:	b007      	add	sp, #28
    1b56:	bc3c      	pop	{r2, r3, r4, r5}
    1b58:	4690      	mov	r8, r2
    1b5a:	4699      	mov	r9, r3
    1b5c:	46a2      	mov	sl, r4
    1b5e:	46ab      	mov	fp, r5
    1b60:	bdf0      	pop	{r4, r5, r6, r7, pc}
	    x0 -= h;
    1b62:	465b      	mov	r3, fp
    1b64:	4641      	mov	r1, r8
    1b66:	1a59      	subs	r1, r3, r1
    1b68:	b289      	uxth	r1, r1
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1b6a:	3101      	adds	r1, #1
	    x1++;
    1b6c:	3301      	adds	r3, #1
    1b6e:	b29b      	uxth	r3, r3
	    y1 += decode->glyph_width;
    1b70:	4655      	mov	r5, sl
    1b72:	466e      	mov	r6, sp
    1b74:	8135      	strh	r5, [r6, #8]
    1b76:	8936      	ldrh	r6, [r6, #8]
    1b78:	1980      	adds	r0, r0, r6
    1b7a:	b280      	uxth	r0, r0
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1b7c:	b289      	uxth	r1, r1
    1b7e:	9104      	str	r1, [sp, #16]
	    break;
    1b80:	e7b6      	b.n	1af0 <u8g2_font_decode_glyph+0x9c>
	    x0 -= decode->glyph_width;
    1b82:	4653      	mov	r3, sl
    1b84:	466a      	mov	r2, sp
    1b86:	8113      	strh	r3, [r2, #8]
    1b88:	8911      	ldrh	r1, [r2, #8]
    1b8a:	465b      	mov	r3, fp
    1b8c:	1a59      	subs	r1, r3, r1
    1b8e:	b289      	uxth	r1, r1
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1b90:	3101      	adds	r1, #1
	    x1++;
    1b92:	3301      	adds	r3, #1
    1b94:	b29b      	uxth	r3, r3
	    y0 -= h;
    1b96:	4642      	mov	r2, r8
    1b98:	1a82      	subs	r2, r0, r2
    1b9a:	b292      	uxth	r2, r2
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1b9c:	3201      	adds	r2, #1
	    y1++;
    1b9e:	3001      	adds	r0, #1
    1ba0:	b280      	uxth	r0, r0
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1ba2:	b292      	uxth	r2, r2
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1ba4:	b289      	uxth	r1, r1
    1ba6:	9104      	str	r1, [sp, #16]
	    break;	  
    1ba8:	e7a2      	b.n	1af0 <u8g2_font_decode_glyph+0x9c>
	    x1 += h;
    1baa:	465b      	mov	r3, fp
    1bac:	4443      	add	r3, r8
    1bae:	b29b      	uxth	r3, r3
	    y0 -= decode->glyph_width;
    1bb0:	4652      	mov	r2, sl
    1bb2:	4669      	mov	r1, sp
    1bb4:	810a      	strh	r2, [r1, #8]
    1bb6:	890a      	ldrh	r2, [r1, #8]
    1bb8:	1a82      	subs	r2, r0, r2
    1bba:	b292      	uxth	r2, r2
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bbc:	3201      	adds	r2, #1
	    y1++;
    1bbe:	3001      	adds	r0, #1
    1bc0:	b280      	uxth	r0, r0
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1bc2:	b292      	uxth	r2, r2
	    break;	  
    1bc4:	e794      	b.n	1af0 <u8g2_font_decode_glyph+0x9c>
    1bc6:	46c0      	nop			; (mov r8, r8)
    1bc8:	000018c1 	.word	0x000018c1
    1bcc:	000018f9 	.word	0x000018f9
    1bd0:	00001939 	.word	0x00001939
    1bd4:	00001915 	.word	0x00001915
    1bd8:	00001fad 	.word	0x00001fad
    1bdc:	00001885 	.word	0x00001885
    1be0:	0000195d 	.word	0x0000195d

00001be4 <u8g2_font_get_glyph_data>:
{
    1be4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1be6:	000e      	movs	r6, r1
  font += U8G2_FONT_DATA_STRUCT_SIZE;
    1be8:	6d84      	ldr	r4, [r0, #88]	; 0x58
    1bea:	3417      	adds	r4, #23
  if ( encoding <= 255 )
    1bec:	29ff      	cmp	r1, #255	; 0xff
    1bee:	d814      	bhi.n	1c1a <u8g2_font_get_glyph_data+0x36>
    if ( encoding >= 'a' )
    1bf0:	2960      	cmp	r1, #96	; 0x60
    1bf2:	d90a      	bls.n	1c0a <u8g2_font_get_glyph_data+0x26>
      font += u8g2->font_info.start_pos_lower_a;
    1bf4:	2388      	movs	r3, #136	; 0x88
    1bf6:	5ac3      	ldrh	r3, [r0, r3]
    1bf8:	18e4      	adds	r4, r4, r3
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    1bfa:	7863      	ldrb	r3, [r4, #1]
    1bfc:	2b00      	cmp	r3, #0
    1bfe:	d027      	beq.n	1c50 <u8g2_font_get_glyph_data+0x6c>
      if ( u8x8_pgm_read( font ) == encoding )
    1c00:	7822      	ldrb	r2, [r4, #0]
    1c02:	4296      	cmp	r6, r2
    1c04:	d007      	beq.n	1c16 <u8g2_font_get_glyph_data+0x32>
      font += u8x8_pgm_read( font + 1 );
    1c06:	18e4      	adds	r4, r4, r3
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    1c08:	e7f7      	b.n	1bfa <u8g2_font_get_glyph_data+0x16>
    else if ( encoding >= 'A' )
    1c0a:	2940      	cmp	r1, #64	; 0x40
    1c0c:	d9f5      	bls.n	1bfa <u8g2_font_get_glyph_data+0x16>
      font += u8g2->font_info.start_pos_upper_A;
    1c0e:	2386      	movs	r3, #134	; 0x86
    1c10:	5ac3      	ldrh	r3, [r0, r3]
    1c12:	18e4      	adds	r4, r4, r3
    1c14:	e7f1      	b.n	1bfa <u8g2_font_get_glyph_data+0x16>
	return font+2;	/* skip encoding and glyph size */
    1c16:	1ca0      	adds	r0, r4, #2
    1c18:	e01b      	b.n	1c52 <u8g2_font_get_glyph_data+0x6e>
    font += u8g2->font_info.start_pos_unicode;
    1c1a:	238a      	movs	r3, #138	; 0x8a
    1c1c:	5ac0      	ldrh	r0, [r0, r3]
    1c1e:	1824      	adds	r4, r4, r0
    unicode_lookup_table = font; 
    1c20:	0025      	movs	r5, r4
      font += u8g2_font_get_word(unicode_lookup_table, 0);
    1c22:	2100      	movs	r1, #0
    1c24:	0028      	movs	r0, r5
    1c26:	4f0c      	ldr	r7, [pc, #48]	; (1c58 <u8g2_font_get_glyph_data+0x74>)
    1c28:	47b8      	blx	r7
    1c2a:	1824      	adds	r4, r4, r0
      e = u8g2_font_get_word(unicode_lookup_table, 2);
    1c2c:	2102      	movs	r1, #2
    1c2e:	0028      	movs	r0, r5
    1c30:	47b8      	blx	r7
      unicode_lookup_table+=4;
    1c32:	3504      	adds	r5, #4
    } while( e < encoding );
    1c34:	4286      	cmp	r6, r0
    1c36:	d8f4      	bhi.n	1c22 <u8g2_font_get_glyph_data+0x3e>
      e = u8x8_pgm_read( font );
    1c38:	7823      	ldrb	r3, [r4, #0]
      e <<= 8;
    1c3a:	021b      	lsls	r3, r3, #8
      e |= u8x8_pgm_read( font + 1 );
    1c3c:	7862      	ldrb	r2, [r4, #1]
    1c3e:	4313      	orrs	r3, r2
      if ( e == 0 )
    1c40:	d008      	beq.n	1c54 <u8g2_font_get_glyph_data+0x70>
      if ( e == encoding )
    1c42:	429e      	cmp	r6, r3
    1c44:	d002      	beq.n	1c4c <u8g2_font_get_glyph_data+0x68>
      font += u8x8_pgm_read( font + 2 );
    1c46:	78a3      	ldrb	r3, [r4, #2]
    1c48:	18e4      	adds	r4, r4, r3
      e = u8x8_pgm_read( font );
    1c4a:	e7f5      	b.n	1c38 <u8g2_font_get_glyph_data+0x54>
	return font+3;	/* skip encoding and glyph size */
    1c4c:	1ce0      	adds	r0, r4, #3
    1c4e:	e000      	b.n	1c52 <u8g2_font_get_glyph_data+0x6e>
  return NULL;
    1c50:	2000      	movs	r0, #0
}
    1c52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return NULL;
    1c54:	2000      	movs	r0, #0
    1c56:	e7fc      	b.n	1c52 <u8g2_font_get_glyph_data+0x6e>
    1c58:	000017bd 	.word	0x000017bd

00001c5c <u8g2_font_draw_glyph>:
{
    1c5c:	b510      	push	{r4, lr}
    1c5e:	0004      	movs	r4, r0
  u8g2->font_decode.target_x = x;
    1c60:	2064      	movs	r0, #100	; 0x64
    1c62:	5221      	strh	r1, [r4, r0]
  u8g2->font_decode.target_y = y;
    1c64:	2166      	movs	r1, #102	; 0x66
    1c66:	5262      	strh	r2, [r4, r1]
  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
    1c68:	0019      	movs	r1, r3
    1c6a:	0020      	movs	r0, r4
    1c6c:	4b05      	ldr	r3, [pc, #20]	; (1c84 <u8g2_font_draw_glyph+0x28>)
    1c6e:	4798      	blx	r3
  if ( glyph_data != NULL )
    1c70:	2800      	cmp	r0, #0
    1c72:	d005      	beq.n	1c80 <u8g2_font_draw_glyph+0x24>
    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
    1c74:	0001      	movs	r1, r0
    1c76:	0020      	movs	r0, r4
    1c78:	4b03      	ldr	r3, [pc, #12]	; (1c88 <u8g2_font_draw_glyph+0x2c>)
    1c7a:	4798      	blx	r3
    1c7c:	b280      	uxth	r0, r0
}
    1c7e:	bd10      	pop	{r4, pc}
  u8g2_uint_t dx = 0;
    1c80:	2000      	movs	r0, #0
    1c82:	e7fc      	b.n	1c7e <u8g2_font_draw_glyph+0x22>
    1c84:	00001be5 	.word	0x00001be5
    1c88:	00001a55 	.word	0x00001a55

00001c8c <u8g2_DrawGlyph>:
{
    1c8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1c8e:	0004      	movs	r4, r0
    1c90:	000d      	movs	r5, r1
    1c92:	0016      	movs	r6, r2
    1c94:	001f      	movs	r7, r3
  switch(u8g2->font_decode.dir)
    1c96:	2370      	movs	r3, #112	; 0x70
    1c98:	5cc3      	ldrb	r3, [r0, r3]
    1c9a:	2b01      	cmp	r3, #1
    1c9c:	d011      	beq.n	1cc2 <u8g2_DrawGlyph+0x36>
    1c9e:	2b00      	cmp	r3, #0
    1ca0:	d00a      	beq.n	1cb8 <u8g2_DrawGlyph+0x2c>
    1ca2:	2b02      	cmp	r3, #2
    1ca4:	d012      	beq.n	1ccc <u8g2_DrawGlyph+0x40>
    1ca6:	2b03      	cmp	r3, #3
    1ca8:	d015      	beq.n	1cd6 <u8g2_DrawGlyph+0x4a>
  return u8g2_font_draw_glyph(u8g2, x, y, encoding);
    1caa:	003b      	movs	r3, r7
    1cac:	0032      	movs	r2, r6
    1cae:	0029      	movs	r1, r5
    1cb0:	0020      	movs	r0, r4
    1cb2:	4c0b      	ldr	r4, [pc, #44]	; (1ce0 <u8g2_DrawGlyph+0x54>)
    1cb4:	47a0      	blx	r4
}
    1cb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      y += u8g2->font_calc_vref(u8g2);
    1cb8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1cba:	4798      	blx	r3
    1cbc:	1836      	adds	r6, r6, r0
    1cbe:	b2b6      	uxth	r6, r6
      break;
    1cc0:	e7f3      	b.n	1caa <u8g2_DrawGlyph+0x1e>
      x -= u8g2->font_calc_vref(u8g2);
    1cc2:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1cc4:	4798      	blx	r3
    1cc6:	1a2d      	subs	r5, r5, r0
    1cc8:	b2ad      	uxth	r5, r5
      break;
    1cca:	e7ee      	b.n	1caa <u8g2_DrawGlyph+0x1e>
      y -= u8g2->font_calc_vref(u8g2);
    1ccc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1cce:	4798      	blx	r3
    1cd0:	1a36      	subs	r6, r6, r0
    1cd2:	b2b6      	uxth	r6, r6
      break;
    1cd4:	e7e9      	b.n	1caa <u8g2_DrawGlyph+0x1e>
      x += u8g2->font_calc_vref(u8g2);
    1cd6:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1cd8:	4798      	blx	r3
    1cda:	182d      	adds	r5, r5, r0
    1cdc:	b2ad      	uxth	r5, r5
      break;
    1cde:	e7e4      	b.n	1caa <u8g2_DrawGlyph+0x1e>
    1ce0:	00001c5d 	.word	0x00001c5d

00001ce4 <u8g2_draw_string>:
{
    1ce4:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ce6:	46ce      	mov	lr, r9
    1ce8:	4647      	mov	r7, r8
    1cea:	b580      	push	{r7, lr}
    1cec:	b083      	sub	sp, #12
    1cee:	0004      	movs	r4, r0
    1cf0:	000f      	movs	r7, r1
    1cf2:	9201      	str	r2, [sp, #4]
    1cf4:	001d      	movs	r5, r3
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
    1cf6:	4b1c      	ldr	r3, [pc, #112]	; (1d68 <u8g2_draw_string+0x84>)
    1cf8:	4798      	blx	r3
  sum = 0;
    1cfa:	2300      	movs	r3, #0
    1cfc:	4698      	mov	r8, r3
    1cfe:	e004      	b.n	1d0a <u8g2_draw_string+0x26>
	  x += delta;
    1d00:	183f      	adds	r7, r7, r0
    1d02:	b2bf      	uxth	r7, r7
      sum += delta;    
    1d04:	4440      	add	r0, r8
    1d06:	b283      	uxth	r3, r0
    1d08:	4698      	mov	r8, r3
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    1d0a:	7829      	ldrb	r1, [r5, #0]
    1d0c:	0020      	movs	r0, r4
    1d0e:	6863      	ldr	r3, [r4, #4]
    1d10:	4798      	blx	r3
    if ( e == 0x0ffff )
    1d12:	4b16      	ldr	r3, [pc, #88]	; (1d6c <u8g2_draw_string+0x88>)
    1d14:	4298      	cmp	r0, r3
    1d16:	d020      	beq.n	1d5a <u8g2_draw_string+0x76>
    str++;
    1d18:	3501      	adds	r5, #1
    if ( e != 0x0fffe )
    1d1a:	4b15      	ldr	r3, [pc, #84]	; (1d70 <u8g2_draw_string+0x8c>)
    1d1c:	4298      	cmp	r0, r3
    1d1e:	d0f4      	beq.n	1d0a <u8g2_draw_string+0x26>
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
    1d20:	0003      	movs	r3, r0
    1d22:	9a01      	ldr	r2, [sp, #4]
    1d24:	0039      	movs	r1, r7
    1d26:	0020      	movs	r0, r4
    1d28:	4e12      	ldr	r6, [pc, #72]	; (1d74 <u8g2_draw_string+0x90>)
    1d2a:	47b0      	blx	r6
      switch(u8g2->font_decode.dir)
    1d2c:	2370      	movs	r3, #112	; 0x70
    1d2e:	5ce3      	ldrb	r3, [r4, r3]
    1d30:	2b01      	cmp	r3, #1
    1d32:	d00a      	beq.n	1d4a <u8g2_draw_string+0x66>
    1d34:	2b00      	cmp	r3, #0
    1d36:	d0e3      	beq.n	1d00 <u8g2_draw_string+0x1c>
    1d38:	2b02      	cmp	r3, #2
    1d3a:	d00b      	beq.n	1d54 <u8g2_draw_string+0x70>
    1d3c:	2b03      	cmp	r3, #3
    1d3e:	d1e1      	bne.n	1d04 <u8g2_draw_string+0x20>
	  y -= delta;
    1d40:	9b01      	ldr	r3, [sp, #4]
    1d42:	1a1e      	subs	r6, r3, r0
    1d44:	b2b3      	uxth	r3, r6
    1d46:	9301      	str	r3, [sp, #4]
	  break;
    1d48:	e7dc      	b.n	1d04 <u8g2_draw_string+0x20>
	  y += delta;
    1d4a:	9b01      	ldr	r3, [sp, #4]
    1d4c:	181e      	adds	r6, r3, r0
    1d4e:	b2b3      	uxth	r3, r6
    1d50:	9301      	str	r3, [sp, #4]
	  break;
    1d52:	e7d7      	b.n	1d04 <u8g2_draw_string+0x20>
	  x -= delta;
    1d54:	1a3f      	subs	r7, r7, r0
    1d56:	b2bf      	uxth	r7, r7
	  break;
    1d58:	e7d4      	b.n	1d04 <u8g2_draw_string+0x20>
}
    1d5a:	4640      	mov	r0, r8
    1d5c:	b003      	add	sp, #12
    1d5e:	bc0c      	pop	{r2, r3}
    1d60:	4690      	mov	r8, r2
    1d62:	4699      	mov	r9, r3
    1d64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d66:	46c0      	nop			; (mov r8, r8)
    1d68:	000022f9 	.word	0x000022f9
    1d6c:	0000ffff 	.word	0x0000ffff
    1d70:	0000fffe 	.word	0x0000fffe
    1d74:	00001c8d 	.word	0x00001c8d

00001d78 <u8g2_DrawStr>:
{
    1d78:	b510      	push	{r4, lr}
  u8g2->u8x8.next_cb = u8x8_ascii_next;
    1d7a:	4c02      	ldr	r4, [pc, #8]	; (1d84 <u8g2_DrawStr+0xc>)
    1d7c:	6044      	str	r4, [r0, #4]
  return u8g2_draw_string(u8g2, x, y, str);
    1d7e:	4c02      	ldr	r4, [pc, #8]	; (1d88 <u8g2_DrawStr+0x10>)
    1d80:	47a0      	blx	r4
}
    1d82:	bd10      	pop	{r4, pc}
    1d84:	000022e1 	.word	0x000022e1
    1d88:	00001ce5 	.word	0x00001ce5

00001d8c <u8g2_UpdateRefHeight>:
{
    1d8c:	b530      	push	{r4, r5, lr}
  if ( u8g2->font == NULL )
    1d8e:	6d83      	ldr	r3, [r0, #88]	; 0x58
    1d90:	2b00      	cmp	r3, #0
    1d92:	d01d      	beq.n	1dd0 <u8g2_UpdateRefHeight+0x44>
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
    1d94:	2381      	movs	r3, #129	; 0x81
    1d96:	56c1      	ldrsb	r1, [r0, r3]
    1d98:	330d      	adds	r3, #13
    1d9a:	54c1      	strb	r1, [r0, r3]
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
    1d9c:	3b0c      	subs	r3, #12
    1d9e:	56c2      	ldrsb	r2, [r0, r3]
    1da0:	330d      	adds	r3, #13
    1da2:	54c2      	strb	r2, [r0, r3]
  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
    1da4:	3b02      	subs	r3, #2
    1da6:	5cc3      	ldrb	r3, [r0, r3]
    1da8:	2b00      	cmp	r3, #0
    1daa:	d011      	beq.n	1dd0 <u8g2_UpdateRefHeight+0x44>
  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
    1dac:	2b01      	cmp	r3, #1
    1dae:	d010      	beq.n	1dd2 <u8g2_UpdateRefHeight+0x46>
    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
    1db0:	237e      	movs	r3, #126	; 0x7e
    1db2:	56c3      	ldrsb	r3, [r0, r3]
    1db4:	2480      	movs	r4, #128	; 0x80
    1db6:	5704      	ldrsb	r4, [r0, r4]
    1db8:	191d      	adds	r5, r3, r4
    1dba:	42a9      	cmp	r1, r5
    1dbc:	da04      	bge.n	1dc8 <u8g2_UpdateRefHeight+0x3c>
      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
    1dbe:	b2db      	uxtb	r3, r3
    1dc0:	b2e1      	uxtb	r1, r4
    1dc2:	185b      	adds	r3, r3, r1
    1dc4:	218e      	movs	r1, #142	; 0x8e
    1dc6:	5443      	strb	r3, [r0, r1]
    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
    1dc8:	42a2      	cmp	r2, r4
    1dca:	dd01      	ble.n	1dd0 <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.y_offset;
    1dcc:	238f      	movs	r3, #143	; 0x8f
    1dce:	54c4      	strb	r4, [r0, r3]
}
    1dd0:	bd30      	pop	{r4, r5, pc}
    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
    1dd2:	3382      	adds	r3, #130	; 0x82
    1dd4:	56c3      	ldrsb	r3, [r0, r3]
    1dd6:	4299      	cmp	r1, r3
    1dd8:	da01      	bge.n	1dde <u8g2_UpdateRefHeight+0x52>
      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
    1dda:	218e      	movs	r1, #142	; 0x8e
    1ddc:	5443      	strb	r3, [r0, r1]
    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
    1dde:	2384      	movs	r3, #132	; 0x84
    1de0:	56c3      	ldrsb	r3, [r0, r3]
    1de2:	429a      	cmp	r2, r3
    1de4:	ddf4      	ble.n	1dd0 <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.descent_para;
    1de6:	228f      	movs	r2, #143	; 0x8f
    1de8:	5483      	strb	r3, [r0, r2]
    1dea:	e7f1      	b.n	1dd0 <u8g2_UpdateRefHeight+0x44>

00001dec <u8g2_SetFontPosBaseline>:

void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
{
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
    1dec:	4b01      	ldr	r3, [pc, #4]	; (1df4 <u8g2_SetFontPosBaseline+0x8>)
    1dee:	65c3      	str	r3, [r0, #92]	; 0x5c
}
    1df0:	4770      	bx	lr
    1df2:	46c0      	nop			; (mov r8, r8)
    1df4:	000017cb 	.word	0x000017cb

00001df8 <u8g2_SetFont>:
}

/*===============================================*/

void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
{
    1df8:	b510      	push	{r4, lr}
    1dfa:	0004      	movs	r4, r0
  if ( u8g2->font != font )
    1dfc:	6d83      	ldr	r3, [r0, #88]	; 0x58
    1dfe:	428b      	cmp	r3, r1
    1e00:	d006      	beq.n	1e10 <u8g2_SetFont+0x18>
  {
//#ifdef  __unix__
//	u8g2->last_font_data = NULL;
//	u8g2->last_unicode = 0x0ffff;
//#endif 
    u8g2->font = font;
    1e02:	6581      	str	r1, [r0, #88]	; 0x58
    u8g2_read_font_info(&(u8g2->font_info), font);
    1e04:	3074      	adds	r0, #116	; 0x74
    1e06:	4b03      	ldr	r3, [pc, #12]	; (1e14 <u8g2_SetFont+0x1c>)
    1e08:	4798      	blx	r3
    u8g2_UpdateRefHeight(u8g2);
    1e0a:	0020      	movs	r0, r4
    1e0c:	4b02      	ldr	r3, [pc, #8]	; (1e18 <u8g2_SetFont+0x20>)
    1e0e:	4798      	blx	r3
    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
  }
}
    1e10:	bd10      	pop	{r4, pc}
    1e12:	46c0      	nop			; (mov r8, r8)
    1e14:	000017d1 	.word	0x000017d1
    1e18:	00001d8d 	.word	0x00001d8d

00001e1c <u8g2_clip_intersection2>:
  will return 0 if there is no intersection and if a > b

*/

static uint8_t u8g2_clip_intersection2(u8g2_uint_t *ap, u8g2_uint_t *len, u8g2_uint_t c, u8g2_uint_t d)
{
    1e1c:	b530      	push	{r4, r5, lr}
  u8g2_uint_t a = *ap;
    1e1e:	8805      	ldrh	r5, [r0, #0]
  u8g2_uint_t b;
  b  = a;
  b += *len;
    1e20:	880c      	ldrh	r4, [r1, #0]
    1e22:	192c      	adds	r4, r5, r4
    1e24:	b2a4      	uxth	r4, r4
  /* be removed completly (be aware about memory curruption for wrong */
  /* arguments) or return 0 for a>b (will lead to skipped lines for wrong */
  /* arguments) */  
  
  /* removing the following if clause completly may lead to memory corruption of a>b */
  if ( a > b )
    1e26:	42a5      	cmp	r5, r4
    1e28:	d903      	bls.n	1e32 <u8g2_clip_intersection2+0x16>
  {    
    /* replacing this if with a simple "return 0;" will not handle the case with negative a */    
    if ( a < d )
    1e2a:	429d      	cmp	r5, r3
    1e2c:	d210      	bcs.n	1e50 <u8g2_clip_intersection2+0x34>
    {
      b = d;
      b--;
    1e2e:	1e5c      	subs	r4, r3, #1
    1e30:	b2a4      	uxth	r4, r4
    }
  }
  
  /* from now on, the asumption a <= b is ok */
  
  if ( a >= d )
    1e32:	429d      	cmp	r5, r3
    1e34:	d20e      	bcs.n	1e54 <u8g2_clip_intersection2+0x38>
    return 0;
  if ( b <= c )
    1e36:	4294      	cmp	r4, r2
    1e38:	d90e      	bls.n	1e58 <u8g2_clip_intersection2+0x3c>
    return 0;
  if ( a < c )		
    1e3a:	4295      	cmp	r5, r2
    1e3c:	d300      	bcc.n	1e40 <u8g2_clip_intersection2+0x24>
    1e3e:	002a      	movs	r2, r5
    a = c;
  if ( b > d )
    1e40:	429c      	cmp	r4, r3
    1e42:	d800      	bhi.n	1e46 <u8g2_clip_intersection2+0x2a>
    1e44:	0023      	movs	r3, r4
    b = d;
  
  *ap = a;
    1e46:	8002      	strh	r2, [r0, #0]
  b -= a;
    1e48:	1a9b      	subs	r3, r3, r2
  *len = b;
    1e4a:	800b      	strh	r3, [r1, #0]
  return 1;
    1e4c:	2001      	movs	r0, #1
    1e4e:	e002      	b.n	1e56 <u8g2_clip_intersection2+0x3a>
      a = c;
    1e50:	0015      	movs	r5, r2
    1e52:	e7ee      	b.n	1e32 <u8g2_clip_intersection2+0x16>
    return 0;
    1e54:	2000      	movs	r0, #0
}
    1e56:	bd30      	pop	{r4, r5, pc}
    return 0;
    1e58:	2000      	movs	r0, #0
    1e5a:	e7fc      	b.n	1e56 <u8g2_clip_intersection2+0x3a>

00001e5c <u8g2_draw_hv_line_2dir>:
  This function first adjusts the y position to the local buffer. Then it
  will clip the line and call u8g2_draw_low_level_hv_line()

*/
void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    1e5c:	b530      	push	{r4, r5, lr}
    1e5e:	b083      	sub	sp, #12
    1e60:	ac06      	add	r4, sp, #24
    1e62:	7825      	ldrb	r5, [r4, #0]

  /* clipping happens before the display rotation */

  /* transform to pixel buffer coordinates */
  y -= u8g2->pixel_curr_row;
    1e64:	8fc4      	ldrh	r4, [r0, #62]	; 0x3e
    1e66:	1b12      	subs	r2, r2, r4
    1e68:	b292      	uxth	r2, r2
  
  u8g2->ll_hvline(u8g2, x, y, len, dir);
    1e6a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    1e6c:	9500      	str	r5, [sp, #0]
    1e6e:	47a0      	blx	r4
}
    1e70:	b003      	add	sp, #12
    1e72:	bd30      	pop	{r4, r5, pc}

00001e74 <u8g2_DrawHVLine>:
  This function should be called by the user.
  
  "dir" may have 4 directions: 0 (left to right), 1, 2, 3 (down up)
*/
void u8g2_DrawHVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    1e74:	b570      	push	{r4, r5, r6, lr}
    1e76:	b084      	sub	sp, #16
    1e78:	0004      	movs	r4, r0
    1e7a:	a808      	add	r0, sp, #32
    1e7c:	7805      	ldrb	r5, [r0, #0]
    1e7e:	200e      	movs	r0, #14
    1e80:	4468      	add	r0, sp
    1e82:	8001      	strh	r1, [r0, #0]
    1e84:	a903      	add	r1, sp, #12
    1e86:	800a      	strh	r2, [r1, #0]
    1e88:	220a      	movs	r2, #10
    1e8a:	446a      	add	r2, sp
    1e8c:	8013      	strh	r3, [r2, #0]
  /* Make a call to the callback function (e.g. u8g2_draw_l90_r0). */
  /* The callback may rotate the hv line */
  /* after rotation this will call u8g2_draw_hv_line_4dir() */
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  if ( u8g2->is_page_clip_window_intersection != 0 )
    1e8e:	238c      	movs	r3, #140	; 0x8c
    1e90:	5ce3      	ldrb	r3, [r4, r3]
    1e92:	2b00      	cmp	r3, #0
    1e94:	d015      	beq.n	1ec2 <u8g2_DrawHVLine+0x4e>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
    if ( len != 0 )
    1e96:	8813      	ldrh	r3, [r2, #0]
    1e98:	2b00      	cmp	r3, #0
    1e9a:	d012      	beq.n	1ec2 <u8g2_DrawHVLine+0x4e>
    {
    
      /* convert to two directions */    
      if ( len > 1 )
    1e9c:	2b01      	cmp	r3, #1
    1e9e:	d903      	bls.n	1ea8 <u8g2_DrawHVLine+0x34>
      {
	if ( dir == 2 )
    1ea0:	2d02      	cmp	r5, #2
    1ea2:	d010      	beq.n	1ec6 <u8g2_DrawHVLine+0x52>
	{
	  x -= len;
	  x++;
	}
	else if ( dir == 3 )
    1ea4:	2d03      	cmp	r5, #3
    1ea6:	d014      	beq.n	1ed2 <u8g2_DrawHVLine+0x5e>
	{
	  y -= len;
	  y++;
	}
      }
      dir &= 1;  
    1ea8:	2301      	movs	r3, #1
    1eaa:	401d      	ands	r5, r3
      
      /* clip against the user window */
      if ( dir == 0 )
    1eac:	d132      	bne.n	1f14 <u8g2_DrawHVLine+0xa0>
      {
	if ( y < u8g2->user_y0 )
    1eae:	334b      	adds	r3, #75	; 0x4b
    1eb0:	5ae2      	ldrh	r2, [r4, r3]
    1eb2:	ab03      	add	r3, sp, #12
    1eb4:	881b      	ldrh	r3, [r3, #0]
    1eb6:	429a      	cmp	r2, r3
    1eb8:	d803      	bhi.n	1ec2 <u8g2_DrawHVLine+0x4e>
	  return;
	if ( y >= u8g2->user_y1 )
    1eba:	224e      	movs	r2, #78	; 0x4e
    1ebc:	5aa2      	ldrh	r2, [r4, r2]
    1ebe:	4293      	cmp	r3, r2
    1ec0:	d30e      	bcc.n	1ee0 <u8g2_DrawHVLine+0x6c>
      }
      
      
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    }
}
    1ec2:	b004      	add	sp, #16
    1ec4:	bd70      	pop	{r4, r5, r6, pc}
	  x -= len;
    1ec6:	8802      	ldrh	r2, [r0, #0]
    1ec8:	1ad3      	subs	r3, r2, r3
    1eca:	b29b      	uxth	r3, r3
	  x++;
    1ecc:	3301      	adds	r3, #1
    1ece:	8003      	strh	r3, [r0, #0]
    1ed0:	e7ea      	b.n	1ea8 <u8g2_DrawHVLine+0x34>
	  y -= len;
    1ed2:	a903      	add	r1, sp, #12
    1ed4:	880a      	ldrh	r2, [r1, #0]
    1ed6:	1ad3      	subs	r3, r2, r3
    1ed8:	b29b      	uxth	r3, r3
	  y++;
    1eda:	3301      	adds	r3, #1
    1edc:	800b      	strh	r3, [r1, #0]
    1ede:	e7e3      	b.n	1ea8 <u8g2_DrawHVLine+0x34>
	if ( u8g2_clip_intersection2(&x, &len, u8g2->user_x0, u8g2->user_x1) == 0 )
    1ee0:	234a      	movs	r3, #74	; 0x4a
    1ee2:	5ae3      	ldrh	r3, [r4, r3]
    1ee4:	2248      	movs	r2, #72	; 0x48
    1ee6:	5aa2      	ldrh	r2, [r4, r2]
    1ee8:	210a      	movs	r1, #10
    1eea:	4469      	add	r1, sp
    1eec:	200e      	movs	r0, #14
    1eee:	4468      	add	r0, sp
    1ef0:	4e14      	ldr	r6, [pc, #80]	; (1f44 <u8g2_DrawHVLine+0xd0>)
    1ef2:	47b0      	blx	r6
    1ef4:	2800      	cmp	r0, #0
    1ef6:	d0e4      	beq.n	1ec2 <u8g2_DrawHVLine+0x4e>
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    1ef8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1efa:	689e      	ldr	r6, [r3, #8]
    1efc:	230a      	movs	r3, #10
    1efe:	446b      	add	r3, sp
    1f00:	881b      	ldrh	r3, [r3, #0]
    1f02:	aa03      	add	r2, sp, #12
    1f04:	8812      	ldrh	r2, [r2, #0]
    1f06:	210e      	movs	r1, #14
    1f08:	4469      	add	r1, sp
    1f0a:	8809      	ldrh	r1, [r1, #0]
    1f0c:	9500      	str	r5, [sp, #0]
    1f0e:	0020      	movs	r0, r4
    1f10:	47b0      	blx	r6
    1f12:	e7d6      	b.n	1ec2 <u8g2_DrawHVLine+0x4e>
	if ( x < u8g2->user_x0 )
    1f14:	2348      	movs	r3, #72	; 0x48
    1f16:	5ae2      	ldrh	r2, [r4, r3]
    1f18:	3b3a      	subs	r3, #58	; 0x3a
    1f1a:	446b      	add	r3, sp
    1f1c:	881b      	ldrh	r3, [r3, #0]
    1f1e:	429a      	cmp	r2, r3
    1f20:	d8cf      	bhi.n	1ec2 <u8g2_DrawHVLine+0x4e>
	if ( x >= u8g2->user_x1 )
    1f22:	224a      	movs	r2, #74	; 0x4a
    1f24:	5aa2      	ldrh	r2, [r4, r2]
    1f26:	4293      	cmp	r3, r2
    1f28:	d2cb      	bcs.n	1ec2 <u8g2_DrawHVLine+0x4e>
	if ( u8g2_clip_intersection2(&y, &len, u8g2->user_y0, u8g2->user_y1) == 0 )
    1f2a:	234e      	movs	r3, #78	; 0x4e
    1f2c:	5ae3      	ldrh	r3, [r4, r3]
    1f2e:	224c      	movs	r2, #76	; 0x4c
    1f30:	5aa2      	ldrh	r2, [r4, r2]
    1f32:	210a      	movs	r1, #10
    1f34:	4469      	add	r1, sp
    1f36:	a803      	add	r0, sp, #12
    1f38:	4e02      	ldr	r6, [pc, #8]	; (1f44 <u8g2_DrawHVLine+0xd0>)
    1f3a:	47b0      	blx	r6
    1f3c:	2800      	cmp	r0, #0
    1f3e:	d1db      	bne.n	1ef8 <u8g2_DrawHVLine+0x84>
    1f40:	e7bf      	b.n	1ec2 <u8g2_DrawHVLine+0x4e>
    1f42:	46c0      	nop			; (mov r8, r8)
    1f44:	00001e1d 	.word	0x00001e1d

00001f48 <u8g2_DrawPixel>:
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 1);
}

void u8g2_DrawPixel(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y)
{
    1f48:	b510      	push	{r4, lr}
    1f4a:	b082      	sub	sp, #8
#ifdef U8G2_WITH_INTERSECTION
  if ( y < u8g2->user_y0 )
    1f4c:	234c      	movs	r3, #76	; 0x4c
    1f4e:	5ac3      	ldrh	r3, [r0, r3]
    1f50:	4293      	cmp	r3, r2
    1f52:	d80b      	bhi.n	1f6c <u8g2_DrawPixel+0x24>
    return;
  if ( y >= u8g2->user_y1 )
    1f54:	234e      	movs	r3, #78	; 0x4e
    1f56:	5ac3      	ldrh	r3, [r0, r3]
    1f58:	429a      	cmp	r2, r3
    1f5a:	d207      	bcs.n	1f6c <u8g2_DrawPixel+0x24>
    return;
  if ( x < u8g2->user_x0 )
    1f5c:	2348      	movs	r3, #72	; 0x48
    1f5e:	5ac3      	ldrh	r3, [r0, r3]
    1f60:	428b      	cmp	r3, r1
    1f62:	d803      	bhi.n	1f6c <u8g2_DrawPixel+0x24>
    return;
  if ( x >= u8g2->user_x1 )
    1f64:	234a      	movs	r3, #74	; 0x4a
    1f66:	5ac3      	ldrh	r3, [r0, r3]
    1f68:	4299      	cmp	r1, r3
    1f6a:	d301      	bcc.n	1f70 <u8g2_DrawPixel+0x28>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
}
    1f6c:	b002      	add	sp, #8
    1f6e:	bd10      	pop	{r4, pc}
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
    1f70:	2300      	movs	r3, #0
    1f72:	9300      	str	r3, [sp, #0]
    1f74:	3301      	adds	r3, #1
    1f76:	4c01      	ldr	r4, [pc, #4]	; (1f7c <u8g2_DrawPixel+0x34>)
    1f78:	47a0      	blx	r4
    1f7a:	e7f7      	b.n	1f6c <u8g2_DrawPixel+0x24>
    1f7c:	00001e75 	.word	0x00001e75

00001f80 <u8g2_is_intersection_decision_tree>:
  a1 and v1 are excluded
  v0 == v1 is not support end return 1
*/
uint8_t u8g2_is_intersection_decision_tree(u8g2_uint_t a0, u8g2_uint_t a1, u8g2_uint_t v0, u8g2_uint_t v1)
{
  if ( v0 < a1 )		// v0 <= a1
    1f80:	428a      	cmp	r2, r1
    1f82:	d205      	bcs.n	1f90 <u8g2_is_intersection_decision_tree+0x10>
  {
    if ( v1 > a0 )	// v1 >= a0
    1f84:	4283      	cmp	r3, r0
    1f86:	d80b      	bhi.n	1fa0 <u8g2_is_intersection_decision_tree+0x20>
    {
      return 1;
    }
    else
    {
      if ( v0 > v1 )	// v0 > v1
    1f88:	429a      	cmp	r2, r3
    1f8a:	d90b      	bls.n	1fa4 <u8g2_is_intersection_decision_tree+0x24>
      {
	return 1;
    1f8c:	2001      	movs	r0, #1
    1f8e:	e008      	b.n	1fa2 <u8g2_is_intersection_decision_tree+0x22>
      }
    }
  }
  else
  {
    if ( v1 > a0 )	// v1 >= a0
    1f90:	4283      	cmp	r3, r0
    1f92:	d909      	bls.n	1fa8 <u8g2_is_intersection_decision_tree+0x28>
    {
      if ( v0 > v1 )	// v0 > v1
    1f94:	429a      	cmp	r2, r3
    1f96:	d801      	bhi.n	1f9c <u8g2_is_intersection_decision_tree+0x1c>
      {
	return 1;
      }
      else
      {
	return 0;
    1f98:	2000      	movs	r0, #0
    1f9a:	e002      	b.n	1fa2 <u8g2_is_intersection_decision_tree+0x22>
	return 1;
    1f9c:	2001      	movs	r0, #1
    1f9e:	e000      	b.n	1fa2 <u8g2_is_intersection_decision_tree+0x22>
      return 1;
    1fa0:	2001      	movs	r0, #1
    else
    {
      return 0;
    }
  }
}
    1fa2:	4770      	bx	lr
	return 0;
    1fa4:	2000      	movs	r0, #0
    1fa6:	e7fc      	b.n	1fa2 <u8g2_is_intersection_decision_tree+0x22>
      return 0;
    1fa8:	2000      	movs	r0, #0
    1faa:	e7fa      	b.n	1fa2 <u8g2_is_intersection_decision_tree+0x22>

00001fac <u8g2_IsIntersection>:



/* upper limits are not included (asymetric boundaries) */
uint8_t u8g2_IsIntersection(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)
{
    1fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1fae:	0006      	movs	r6, r0
    1fb0:	000c      	movs	r4, r1
    1fb2:	001d      	movs	r5, r3
    1fb4:	ab06      	add	r3, sp, #24
    1fb6:	881b      	ldrh	r3, [r3, #0]
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    1fb8:	214e      	movs	r1, #78	; 0x4e
    1fba:	5a41      	ldrh	r1, [r0, r1]
    1fbc:	204c      	movs	r0, #76	; 0x4c
    1fbe:	5a30      	ldrh	r0, [r6, r0]
    1fc0:	4f05      	ldr	r7, [pc, #20]	; (1fd8 <u8g2_IsIntersection+0x2c>)
    1fc2:	47b8      	blx	r7
    1fc4:	2800      	cmp	r0, #0
    1fc6:	d006      	beq.n	1fd6 <u8g2_IsIntersection+0x2a>
    return 0; 
  
  return u8g2_is_intersection_decision_tree(u8g2->user_x0, u8g2->user_x1, x0, x1);
    1fc8:	234a      	movs	r3, #74	; 0x4a
    1fca:	5af1      	ldrh	r1, [r6, r3]
    1fcc:	3b02      	subs	r3, #2
    1fce:	5af0      	ldrh	r0, [r6, r3]
    1fd0:	002b      	movs	r3, r5
    1fd2:	0022      	movs	r2, r4
    1fd4:	47b8      	blx	r7
}
    1fd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1fd8:	00001f81 	.word	0x00001f81

00001fdc <u8g2_DrawLine>:

#include "u8g2.h"


void u8g2_DrawLine(u8g2_t *u8g2, u8g2_uint_t x1, u8g2_uint_t y1, u8g2_uint_t x2, u8g2_uint_t y2)
{
    1fdc:	b5f0      	push	{r4, r5, r6, r7, lr}
    1fde:	46de      	mov	lr, fp
    1fe0:	4657      	mov	r7, sl
    1fe2:	464e      	mov	r6, r9
    1fe4:	b5c0      	push	{r6, r7, lr}
    1fe6:	b082      	sub	sp, #8
    1fe8:	9000      	str	r0, [sp, #0]
    1fea:	0017      	movs	r7, r2
    1fec:	001e      	movs	r6, r3
    1fee:	ab0a      	add	r3, sp, #40	; 0x28
    1ff0:	881d      	ldrh	r5, [r3, #0]

  uint8_t swapxy = 0;
  
  /* no intersection check at the moment, should be added... */

  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    1ff2:	42b1      	cmp	r1, r6
    1ff4:	d929      	bls.n	204a <u8g2_DrawLine+0x6e>
    1ff6:	1b8b      	subs	r3, r1, r6
    1ff8:	b29b      	uxth	r3, r3
    1ffa:	4699      	mov	r9, r3
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    1ffc:	42af      	cmp	r7, r5
    1ffe:	d928      	bls.n	2052 <u8g2_DrawLine+0x76>
    2000:	1b7b      	subs	r3, r7, r5
    2002:	b29b      	uxth	r3, r3
    2004:	469b      	mov	fp, r3

  if ( dy > dx ) 
    2006:	45d9      	cmp	r9, fp
    2008:	d327      	bcc.n	205a <u8g2_DrawLine+0x7e>
    200a:	465b      	mov	r3, fp
    200c:	46cb      	mov	fp, r9
    200e:	4699      	mov	r9, r3
    2010:	002b      	movs	r3, r5
    2012:	0035      	movs	r5, r6
    2014:	001e      	movs	r6, r3
    2016:	003b      	movs	r3, r7
    2018:	000f      	movs	r7, r1
    201a:	0019      	movs	r1, r3
  uint8_t swapxy = 0;
    201c:	2300      	movs	r3, #0
    201e:	469a      	mov	sl, r3
    swapxy = 1;
    tmp = dx; dx =dy; dy = tmp;
    tmp = x1; x1 =y1; y1 = tmp;
    tmp = x2; x2 =y2; y2 = tmp;
  }
  if ( x1 > x2 ) 
    2020:	42af      	cmp	r7, r5
    2022:	d805      	bhi.n	2030 <u8g2_DrawLine+0x54>
    2024:	0033      	movs	r3, r6
    2026:	000e      	movs	r6, r1
    2028:	0019      	movs	r1, r3
    202a:	002b      	movs	r3, r5
    202c:	003d      	movs	r5, r7
    202e:	001f      	movs	r7, r3
  {
    tmp = x1; x1 =x2; x2 = tmp;
    tmp = y1; y1 =y2; y2 = tmp;
  }
  err = dx >> 1;
    2030:	465b      	mov	r3, fp
    2032:	085c      	lsrs	r4, r3, #1
    2034:	b224      	sxth	r4, r4
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    2036:	428e      	cmp	r6, r1
    2038:	d212      	bcs.n	2060 <u8g2_DrawLine+0x84>
    203a:	2301      	movs	r3, #1
    203c:	9301      	str	r3, [sp, #4]

#ifndef  U8G2_16BIT
  if ( x2 == 255 )
    x2--;
#else
  if ( x2 == 0xffff )
    203e:	4b1d      	ldr	r3, [pc, #116]	; (20b4 <u8g2_DrawLine+0xd8>)
    2040:	429f      	cmp	r7, r3
    2042:	d11e      	bne.n	2082 <u8g2_DrawLine+0xa6>
    x2--;
    2044:	3f01      	subs	r7, #1
    2046:	b2bf      	uxth	r7, r7
#endif

  for( x = x1; x <= x2; x++ )
    2048:	e01b      	b.n	2082 <u8g2_DrawLine+0xa6>
  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    204a:	1a73      	subs	r3, r6, r1
    204c:	b29b      	uxth	r3, r3
    204e:	4699      	mov	r9, r3
    2050:	e7d4      	b.n	1ffc <u8g2_DrawLine+0x20>
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    2052:	1beb      	subs	r3, r5, r7
    2054:	b29b      	uxth	r3, r3
    2056:	469b      	mov	fp, r3
    2058:	e7d5      	b.n	2006 <u8g2_DrawLine+0x2a>
    swapxy = 1;
    205a:	2301      	movs	r3, #1
    205c:	469a      	mov	sl, r3
    205e:	e7df      	b.n	2020 <u8g2_DrawLine+0x44>
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    2060:	2301      	movs	r3, #1
    2062:	425b      	negs	r3, r3
    2064:	9301      	str	r3, [sp, #4]
    2066:	e7ea      	b.n	203e <u8g2_DrawLine+0x62>
  {
    if ( swapxy == 0 ) 
      u8g2_DrawPixel(u8g2, x, y); 
    else 
      u8g2_DrawPixel(u8g2, y, x); 
    2068:	002a      	movs	r2, r5
    206a:	0031      	movs	r1, r6
    206c:	9800      	ldr	r0, [sp, #0]
    206e:	4b12      	ldr	r3, [pc, #72]	; (20b8 <u8g2_DrawLine+0xdc>)
    2070:	4798      	blx	r3
    err -= (u8g2_uint_t)dy;
    2072:	464b      	mov	r3, r9
    2074:	1ae4      	subs	r4, r4, r3
    2076:	b2a3      	uxth	r3, r4
    2078:	b21c      	sxth	r4, r3
    if ( err < 0 ) 
    207a:	2c00      	cmp	r4, #0
    207c:	db0c      	blt.n	2098 <u8g2_DrawLine+0xbc>
  for( x = x1; x <= x2; x++ )
    207e:	3501      	adds	r5, #1
    2080:	b2ad      	uxth	r5, r5
    2082:	42af      	cmp	r7, r5
    2084:	d30f      	bcc.n	20a6 <u8g2_DrawLine+0xca>
    if ( swapxy == 0 ) 
    2086:	4653      	mov	r3, sl
    2088:	2b00      	cmp	r3, #0
    208a:	d1ed      	bne.n	2068 <u8g2_DrawLine+0x8c>
      u8g2_DrawPixel(u8g2, x, y); 
    208c:	0032      	movs	r2, r6
    208e:	0029      	movs	r1, r5
    2090:	9800      	ldr	r0, [sp, #0]
    2092:	4b09      	ldr	r3, [pc, #36]	; (20b8 <u8g2_DrawLine+0xdc>)
    2094:	4798      	blx	r3
    2096:	e7ec      	b.n	2072 <u8g2_DrawLine+0x96>
    {
      y += (u8g2_uint_t)ystep;
    2098:	466a      	mov	r2, sp
    209a:	8892      	ldrh	r2, [r2, #4]
    209c:	18b6      	adds	r6, r6, r2
    209e:	b2b6      	uxth	r6, r6
      err += (u8g2_uint_t)dx;
    20a0:	445b      	add	r3, fp
    20a2:	b21c      	sxth	r4, r3
    20a4:	e7eb      	b.n	207e <u8g2_DrawLine+0xa2>
    }
  }
}
    20a6:	b002      	add	sp, #8
    20a8:	bc1c      	pop	{r2, r3, r4}
    20aa:	4691      	mov	r9, r2
    20ac:	469a      	mov	sl, r3
    20ae:	46a3      	mov	fp, r4
    20b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    20b2:	46c0      	nop			; (mov r8, r8)
    20b4:	0000ffff 	.word	0x0000ffff
    20b8:	00001f49 	.word	0x00001f49

000020bc <u8g2_ll_hvline_vertical_top_lsb>:
		1: vertical line (top to bottom)
  asumption: 
    all clipping done
*/
void u8g2_ll_hvline_vertical_top_lsb(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    20bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    20be:	46c6      	mov	lr, r8
    20c0:	b500      	push	{lr}
    20c2:	4688      	mov	r8, r1
    20c4:	ac06      	add	r4, sp, #24
    20c6:	7827      	ldrb	r7, [r4, #0]
  //assert(y >= u8g2->buf_y0);
  //assert(y < u8g2_GetU8x8(u8g2)->display_info->tile_height*8);
  
  /* bytes are vertical, lsb on top (y=0), msb at bottom (y=7) */
  bit_pos = y;		/* overflow truncate is ok here... */
  bit_pos &= 7; 	/* ... because only the lowest 3 bits are needed */
    20c8:	2407      	movs	r4, #7
    20ca:	4014      	ands	r4, r2
  mask = 1;
  mask <<= bit_pos;
    20cc:	2501      	movs	r5, #1
    20ce:	40a5      	lsls	r5, r4
    20d0:	b2ed      	uxtb	r5, r5

  or_mask = 0;
  xor_mask = 0;
  if ( u8g2->draw_color <= 1 )
    20d2:	2692      	movs	r6, #146	; 0x92
    20d4:	5d86      	ldrb	r6, [r0, r6]
    20d6:	46b4      	mov	ip, r6
    20d8:	2e01      	cmp	r6, #1
    20da:	d91f      	bls.n	211c <u8g2_ll_hvline_vertical_top_lsb+0x60>
  or_mask = 0;
    20dc:	2600      	movs	r6, #0
    or_mask  = mask;
  if ( u8g2->draw_color != 1 )
    20de:	4661      	mov	r1, ip
    20e0:	2901      	cmp	r1, #1
    20e2:	d01d      	beq.n	2120 <u8g2_ll_hvline_vertical_top_lsb+0x64>
    xor_mask = mask;


  offset = y;		/* y might be 8 or 16 bit, but we need 16 bit, so use a 16 bit variable */
  offset &= ~7;
    20e4:	2107      	movs	r1, #7
    20e6:	438a      	bics	r2, r1
    20e8:	4694      	mov	ip, r2
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
    20ea:	6802      	ldr	r2, [r0, #0]
    20ec:	7c12      	ldrb	r2, [r2, #16]
    20ee:	4661      	mov	r1, ip
    20f0:	434a      	muls	r2, r1
    20f2:	b292      	uxth	r2, r2
  ptr = u8g2->tile_buf_ptr;
  ptr += offset;
  ptr += x;
    20f4:	4442      	add	r2, r8
    20f6:	0011      	movs	r1, r2
    20f8:	6b42      	ldr	r2, [r0, #52]	; 0x34
    20fa:	4694      	mov	ip, r2
    20fc:	4461      	add	r1, ip
  
  if ( dir == 0 )
    20fe:	2f00      	cmp	r7, #0
    2100:	d118      	bne.n	2134 <u8g2_ll_hvline_vertical_top_lsb+0x78>
      do
      {
#ifdef __unix
	assert(ptr < max_ptr);
#endif
	*ptr |= or_mask;
    2102:	780a      	ldrb	r2, [r1, #0]
    2104:	4332      	orrs	r2, r6
    2106:	b2d2      	uxtb	r2, r2
	*ptr ^= xor_mask;
    2108:	406a      	eors	r2, r5
    210a:	700a      	strb	r2, [r1, #0]
	ptr++;
    210c:	3101      	adds	r1, #1
	len--;
    210e:	3b01      	subs	r3, #1
    2110:	b29b      	uxth	r3, r3
      } while( len != 0 );
    2112:	2b00      	cmp	r3, #0
    2114:	d1f5      	bne.n	2102 <u8g2_ll_hvline_vertical_top_lsb+0x46>
	or_mask <<= 1;
	xor_mask <<= 1;
      }
    } while( len != 0 );
  }
}
    2116:	bc04      	pop	{r2}
    2118:	4690      	mov	r8, r2
    211a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    or_mask  = mask;
    211c:	002e      	movs	r6, r5
    211e:	e7de      	b.n	20de <u8g2_ll_hvline_vertical_top_lsb+0x22>
  xor_mask = 0;
    2120:	2500      	movs	r5, #0
    2122:	e7df      	b.n	20e4 <u8g2_ll_hvline_vertical_top_lsb+0x28>
	  or_mask  = 1;
    2124:	2601      	movs	r6, #1
    2126:	e017      	b.n	2158 <u8g2_ll_hvline_vertical_top_lsb+0x9c>
	or_mask <<= 1;
    2128:	0076      	lsls	r6, r6, #1
    212a:	b2f6      	uxtb	r6, r6
	xor_mask <<= 1;
    212c:	006d      	lsls	r5, r5, #1
    212e:	b2ed      	uxtb	r5, r5
    } while( len != 0 );
    2130:	2b00      	cmp	r3, #0
    2132:	d0f0      	beq.n	2116 <u8g2_ll_hvline_vertical_top_lsb+0x5a>
      *ptr |= or_mask;
    2134:	780a      	ldrb	r2, [r1, #0]
    2136:	4332      	orrs	r2, r6
    2138:	b2d2      	uxtb	r2, r2
      *ptr ^= xor_mask;
    213a:	406a      	eors	r2, r5
    213c:	700a      	strb	r2, [r1, #0]
      bit_pos++;
    213e:	3401      	adds	r4, #1
      bit_pos &= 7;
    2140:	2207      	movs	r2, #7
    2142:	4014      	ands	r4, r2
      len--;
    2144:	3b01      	subs	r3, #1
    2146:	b29b      	uxth	r3, r3
      if ( bit_pos == 0 )
    2148:	2c00      	cmp	r4, #0
    214a:	d1ed      	bne.n	2128 <u8g2_ll_hvline_vertical_top_lsb+0x6c>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    214c:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
    214e:	1889      	adds	r1, r1, r2
	if ( u8g2->draw_color <= 1 )
    2150:	2292      	movs	r2, #146	; 0x92
    2152:	5c82      	ldrb	r2, [r0, r2]
    2154:	2a01      	cmp	r2, #1
    2156:	d9e5      	bls.n	2124 <u8g2_ll_hvline_vertical_top_lsb+0x68>
	if ( u8g2->draw_color != 1 )
    2158:	2a01      	cmp	r2, #1
    215a:	d0e9      	beq.n	2130 <u8g2_ll_hvline_vertical_top_lsb+0x74>
	  xor_mask = 1;
    215c:	2501      	movs	r5, #1
    215e:	e7e7      	b.n	2130 <u8g2_ll_hvline_vertical_top_lsb+0x74>

00002160 <u8g2_update_dimension_common>:
    u8g2_uint_t buf_y0;
    u8g2_uint_t buf_y1; 	
*/

static void u8g2_update_dimension_common(u8g2_t *u8g2)
{
    2160:	b5f0      	push	{r4, r5, r6, r7, lr}
  const u8x8_display_info_t *display_info = u8g2_GetU8x8(u8g2)->display_info;
    2162:	6801      	ldr	r1, [r0, #0]
  u8g2_uint_t t;
  
  t = u8g2->tile_buf_height;
    2164:	2338      	movs	r3, #56	; 0x38
    2166:	5cc4      	ldrb	r4, [r0, r3]
    2168:	b2a3      	uxth	r3, r4
  t *= 8;
    216a:	00da      	lsls	r2, r3, #3
  u8g2->pixel_buf_height = t;
    216c:	8782      	strh	r2, [r0, #60]	; 0x3c
  
  t = display_info->tile_width;
    216e:	7c0a      	ldrb	r2, [r1, #16]
#ifndef U8G2_16BIT
  if ( t >= 32 )
    t = 31;
#endif
  t *= 8;
    2170:	00d2      	lsls	r2, r2, #3
  u8g2->pixel_buf_width = t;
    2172:	8742      	strh	r2, [r0, #58]	; 0x3a
  
  t = u8g2->tile_curr_row;
    2174:	2239      	movs	r2, #57	; 0x39
    2176:	5c86      	ldrb	r6, [r0, r2]
    2178:	b2b7      	uxth	r7, r6
  t *= 8;
    217a:	00fa      	lsls	r2, r7, #3
  u8g2->pixel_curr_row = t;
    217c:	87c2      	strh	r2, [r0, #62]	; 0x3e
  
  t = u8g2->tile_buf_height;
  /* handle the case, where the buffer is larger than the (remaining) part of the display */
  if ( t + u8g2->tile_curr_row > display_info->tile_height )
    217e:	19a4      	adds	r4, r4, r6
    2180:	7c4d      	ldrb	r5, [r1, #17]
    2182:	42ac      	cmp	r4, r5
    2184:	dd01      	ble.n	218a <u8g2_update_dimension_common+0x2a>
    t = display_info->tile_height - u8g2->tile_curr_row;
    2186:	1beb      	subs	r3, r5, r7
    2188:	b29b      	uxth	r3, r3
  t *= 8;
    218a:	00db      	lsls	r3, r3, #3
    218c:	b29b      	uxth	r3, r3
  
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
    218e:	2440      	movs	r4, #64	; 0x40
    2190:	5302      	strh	r2, [r0, r4]
  u8g2->buf_y1 = u8g2->buf_y0;
  u8g2->buf_y1 += t;
    2192:	18d3      	adds	r3, r2, r3
    2194:	2242      	movs	r2, #66	; 0x42
    2196:	5283      	strh	r3, [r0, r2]

  
#ifdef U8G2_16BIT
  u8g2->width = display_info->pixel_width;
    2198:	8a8a      	ldrh	r2, [r1, #20]
    219a:	2344      	movs	r3, #68	; 0x44
    219c:	52c2      	strh	r2, [r0, r3]
  u8g2->height = display_info->pixel_height;
    219e:	8aca      	ldrh	r2, [r1, #22]
    21a0:	3302      	adds	r3, #2
    21a2:	52c2      	strh	r2, [r0, r3]
  if ( display_info->pixel_width <= 240 )
    u8g2->width = display_info->pixel_width;
  u8g2->height = display_info->pixel_height;
#endif

}
    21a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000021a8 <u8g2_update_dimension_r0>:

/*==========================================================*/


void u8g2_update_dimension_r0(u8g2_t *u8g2)
{
    21a8:	b510      	push	{r4, lr}
  u8g2_update_dimension_common(u8g2);  
    21aa:	4b01      	ldr	r3, [pc, #4]	; (21b0 <u8g2_update_dimension_r0+0x8>)
    21ac:	4798      	blx	r3
}
    21ae:	bd10      	pop	{r4, pc}
    21b0:	00002161 	.word	0x00002161

000021b4 <u8g2_apply_clip_window>:
{
    21b4:	b530      	push	{r4, r5, lr}
    21b6:	b083      	sub	sp, #12
    21b8:	0004      	movs	r4, r0
  if ( u8g2_IsIntersection(u8g2, u8g2->clip_x0, u8g2->clip_y0, u8g2->clip_x1, u8g2->clip_y1) == 0 ) 
    21ba:	2352      	movs	r3, #82	; 0x52
    21bc:	5ac3      	ldrh	r3, [r0, r3]
    21be:	2254      	movs	r2, #84	; 0x54
    21c0:	5a82      	ldrh	r2, [r0, r2]
    21c2:	2150      	movs	r1, #80	; 0x50
    21c4:	5a41      	ldrh	r1, [r0, r1]
    21c6:	2056      	movs	r0, #86	; 0x56
    21c8:	5a20      	ldrh	r0, [r4, r0]
    21ca:	9000      	str	r0, [sp, #0]
    21cc:	0020      	movs	r0, r4
    21ce:	4d16      	ldr	r5, [pc, #88]	; (2228 <u8g2_apply_clip_window+0x74>)
    21d0:	47a8      	blx	r5
    21d2:	2800      	cmp	r0, #0
    21d4:	d023      	beq.n	221e <u8g2_apply_clip_window+0x6a>
    u8g2->is_page_clip_window_intersection = 1;
    21d6:	2201      	movs	r2, #1
    21d8:	238c      	movs	r3, #140	; 0x8c
    21da:	54e2      	strb	r2, [r4, r3]
    if ( u8g2->user_x0 < u8g2->clip_x0 )
    21dc:	3b44      	subs	r3, #68	; 0x44
    21de:	5ae2      	ldrh	r2, [r4, r3]
    21e0:	3308      	adds	r3, #8
    21e2:	5ae3      	ldrh	r3, [r4, r3]
    21e4:	429a      	cmp	r2, r3
    21e6:	d201      	bcs.n	21ec <u8g2_apply_clip_window+0x38>
      u8g2->user_x0 = u8g2->clip_x0;
    21e8:	2248      	movs	r2, #72	; 0x48
    21ea:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_x1 > u8g2->clip_x1 )
    21ec:	234a      	movs	r3, #74	; 0x4a
    21ee:	5ae2      	ldrh	r2, [r4, r3]
    21f0:	3308      	adds	r3, #8
    21f2:	5ae3      	ldrh	r3, [r4, r3]
    21f4:	429a      	cmp	r2, r3
    21f6:	d901      	bls.n	21fc <u8g2_apply_clip_window+0x48>
      u8g2->user_x1 = u8g2->clip_x1;
    21f8:	224a      	movs	r2, #74	; 0x4a
    21fa:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
    21fc:	234c      	movs	r3, #76	; 0x4c
    21fe:	5ae2      	ldrh	r2, [r4, r3]
    2200:	3308      	adds	r3, #8
    2202:	5ae3      	ldrh	r3, [r4, r3]
    2204:	429a      	cmp	r2, r3
    2206:	d201      	bcs.n	220c <u8g2_apply_clip_window+0x58>
      u8g2->user_y0 = u8g2->clip_y0;
    2208:	224c      	movs	r2, #76	; 0x4c
    220a:	52a3      	strh	r3, [r4, r2]
    if ( u8g2->user_y1 > u8g2->clip_y1 )
    220c:	234e      	movs	r3, #78	; 0x4e
    220e:	5ae2      	ldrh	r2, [r4, r3]
    2210:	3308      	adds	r3, #8
    2212:	5ae3      	ldrh	r3, [r4, r3]
    2214:	429a      	cmp	r2, r3
    2216:	d905      	bls.n	2224 <u8g2_apply_clip_window+0x70>
      u8g2->user_y1 = u8g2->clip_y1;
    2218:	224e      	movs	r2, #78	; 0x4e
    221a:	52a3      	strh	r3, [r4, r2]
}
    221c:	e002      	b.n	2224 <u8g2_apply_clip_window+0x70>
    u8g2->is_page_clip_window_intersection = 0;
    221e:	2200      	movs	r2, #0
    2220:	238c      	movs	r3, #140	; 0x8c
    2222:	54e2      	strb	r2, [r4, r3]
}
    2224:	b003      	add	sp, #12
    2226:	bd30      	pop	{r4, r5, pc}
    2228:	00001fad 	.word	0x00001fad

0000222c <u8g2_update_page_win_r0>:

void u8g2_update_page_win_r0(u8g2_t *u8g2)
{
    222c:	b510      	push	{r4, lr}
  u8g2->user_x0 = 0;
    222e:	2200      	movs	r2, #0
    2230:	2348      	movs	r3, #72	; 0x48
    2232:	52c2      	strh	r2, [r0, r3]
  u8g2->user_x1 = u8g2->width;			/* pixel_buf_width replaced with width */
    2234:	3b04      	subs	r3, #4
    2236:	5ac2      	ldrh	r2, [r0, r3]
    2238:	3306      	adds	r3, #6
    223a:	52c2      	strh	r2, [r0, r3]
  
  u8g2->user_y0 = u8g2->buf_y0;
    223c:	3b0a      	subs	r3, #10
    223e:	5ac2      	ldrh	r2, [r0, r3]
    2240:	330c      	adds	r3, #12
    2242:	52c2      	strh	r2, [r0, r3]
  u8g2->user_y1 = u8g2->buf_y1;
    2244:	3b0a      	subs	r3, #10
    2246:	5ac2      	ldrh	r2, [r0, r3]
    2248:	330c      	adds	r3, #12
    224a:	52c2      	strh	r2, [r0, r3]
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_apply_clip_window(u8g2);
    224c:	4b01      	ldr	r3, [pc, #4]	; (2254 <u8g2_update_page_win_r0+0x28>)
    224e:	4798      	blx	r3
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
}
    2250:	bd10      	pop	{r4, pc}
    2252:	46c0      	nop			; (mov r8, r8)
    2254:	000021b5 	.word	0x000021b5

00002258 <u8g2_draw_l90_r0>:
/*============================================*/
extern void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir);


void u8g2_draw_l90_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    2258:	b510      	push	{r4, lr}
    225a:	b082      	sub	sp, #8
    225c:	ac04      	add	r4, sp, #16
    225e:	7824      	ldrb	r4, [r4, #0]
#ifdef __unix
  assert( dir <= 1 );
#endif
  u8g2_draw_hv_line_2dir(u8g2, x, y, len, dir);
    2260:	9400      	str	r4, [sp, #0]
    2262:	4c02      	ldr	r4, [pc, #8]	; (226c <u8g2_draw_l90_r0+0x14>)
    2264:	47a0      	blx	r4
}
    2266:	b002      	add	sp, #8
    2268:	bd10      	pop	{r4, pc}
    226a:	46c0      	nop			; (mov r8, r8)
    226c:	00001e5d 	.word	0x00001e5d

00002270 <u8g2_SetMaxClipWindow>:
{
    2270:	b510      	push	{r4, lr}
  u8g2->clip_x0 = 0;
    2272:	2300      	movs	r3, #0
    2274:	2250      	movs	r2, #80	; 0x50
    2276:	5283      	strh	r3, [r0, r2]
  u8g2->clip_y0 = 0;
    2278:	3204      	adds	r2, #4
    227a:	5283      	strh	r3, [r0, r2]
  u8g2->clip_x1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    227c:	3b01      	subs	r3, #1
    227e:	3a02      	subs	r2, #2
    2280:	5283      	strh	r3, [r0, r2]
  u8g2->clip_y1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    2282:	3204      	adds	r2, #4
    2284:	5283      	strh	r3, [r0, r2]
  u8g2->cb->update_page_win(u8g2);
    2286:	6b03      	ldr	r3, [r0, #48]	; 0x30
    2288:	685b      	ldr	r3, [r3, #4]
    228a:	4798      	blx	r3
}
    228c:	bd10      	pop	{r4, pc}
	...

00002290 <u8g2_SetupBuffer>:
{
    2290:	b570      	push	{r4, r5, r6, lr}
    2292:	0004      	movs	r4, r0
    2294:	9804      	ldr	r0, [sp, #16]
  u8g2->font = NULL;
    2296:	2500      	movs	r5, #0
    2298:	65a5      	str	r5, [r4, #88]	; 0x58
  u8g2->ll_hvline = ll_hvline_cb;
    229a:	62e3      	str	r3, [r4, #44]	; 0x2c
  u8g2->tile_buf_ptr = buf;
    229c:	6361      	str	r1, [r4, #52]	; 0x34
  u8g2->tile_buf_height = tile_buf_height;
    229e:	2338      	movs	r3, #56	; 0x38
    22a0:	54e2      	strb	r2, [r4, r3]
  u8g2->tile_curr_row = 0;
    22a2:	3301      	adds	r3, #1
    22a4:	54e5      	strb	r5, [r4, r3]
  u8g2->font_decode.is_transparent = 0; /* issue 443 */
    22a6:	3334      	adds	r3, #52	; 0x34
    22a8:	54e5      	strb	r5, [r4, r3]
  u8g2->bitmap_transparency = 0;
    22aa:	3324      	adds	r3, #36	; 0x24
    22ac:	54e5      	strb	r5, [r4, r3]
  u8g2->font_height_mode = 0; /* issue 2046 */
    22ae:	3b04      	subs	r3, #4
    22b0:	54e5      	strb	r5, [r4, r3]
  u8g2->draw_color = 1;
    22b2:	3b8c      	subs	r3, #140	; 0x8c
    22b4:	2292      	movs	r2, #146	; 0x92
    22b6:	54a3      	strb	r3, [r4, r2]
  u8g2->is_auto_page_clear = 1;
    22b8:	3201      	adds	r2, #1
    22ba:	54a3      	strb	r3, [r4, r2]
  u8g2->cb = u8g2_cb;
    22bc:	6320      	str	r0, [r4, #48]	; 0x30
  u8g2->cb->update_dimension(u8g2);
    22be:	6803      	ldr	r3, [r0, #0]
    22c0:	0020      	movs	r0, r4
    22c2:	4798      	blx	r3
  u8g2_SetMaxClipWindow(u8g2);		/* assign a clip window and call the update() procedure */
    22c4:	0020      	movs	r0, r4
    22c6:	4b04      	ldr	r3, [pc, #16]	; (22d8 <u8g2_SetupBuffer+0x48>)
    22c8:	4798      	blx	r3
  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
    22ca:	0020      	movs	r0, r4
    22cc:	4b03      	ldr	r3, [pc, #12]	; (22dc <u8g2_SetupBuffer+0x4c>)
    22ce:	4798      	blx	r3
  u8g2->font_decode.dir = 0;
    22d0:	2370      	movs	r3, #112	; 0x70
    22d2:	54e5      	strb	r5, [r4, r3]
}
    22d4:	bd70      	pop	{r4, r5, r6, pc}
    22d6:	46c0      	nop			; (mov r8, r8)
    22d8:	00002271 	.word	0x00002271
    22dc:	00001ded 	.word	0x00001ded

000022e0 <u8x8_ascii_next>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
}

uint16_t u8x8_ascii_next(U8X8_UNUSED u8x8_t *u8x8, uint8_t b)
{
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    22e0:	2900      	cmp	r1, #0
    22e2:	d101      	bne.n	22e8 <u8x8_ascii_next+0x8>
    return 0x0ffff;	/* end of string detected*/
    22e4:	4803      	ldr	r0, [pc, #12]	; (22f4 <u8x8_ascii_next+0x14>)
  return b;
}
    22e6:	4770      	bx	lr
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    22e8:	290a      	cmp	r1, #10
    22ea:	d001      	beq.n	22f0 <u8x8_ascii_next+0x10>
  return b;
    22ec:	b288      	uxth	r0, r1
    22ee:	e7fa      	b.n	22e6 <u8x8_ascii_next+0x6>
    return 0x0ffff;	/* end of string detected*/
    22f0:	4800      	ldr	r0, [pc, #0]	; (22f4 <u8x8_ascii_next+0x14>)
    22f2:	e7f8      	b.n	22e6 <u8x8_ascii_next+0x6>
    22f4:	0000ffff 	.word	0x0000ffff

000022f8 <u8x8_utf8_init>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
    22f8:	2200      	movs	r2, #0
    22fa:	2326      	movs	r3, #38	; 0x26
    22fc:	54c2      	strb	r2, [r0, r3]
}
    22fe:	4770      	bx	lr

00002300 <u8x8_byte_SetDC>:
*/

#include "u8x8.h"

uint8_t u8x8_byte_SetDC(u8x8_t *u8x8, uint8_t dc)
{
    2300:	b510      	push	{r4, lr}
    2302:	000a      	movs	r2, r1
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SET_DC, dc, NULL);
    2304:	6904      	ldr	r4, [r0, #16]
    2306:	2300      	movs	r3, #0
    2308:	2120      	movs	r1, #32
    230a:	47a0      	blx	r4
}
    230c:	bd10      	pop	{r4, pc}

0000230e <u8x8_byte_SendBytes>:

uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    230e:	b510      	push	{r4, lr}
    2310:	0013      	movs	r3, r2
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SEND, cnt, (void *)data);
    2312:	6904      	ldr	r4, [r0, #16]
    2314:	000a      	movs	r2, r1
    2316:	2117      	movs	r1, #23
    2318:	47a0      	blx	r4
}
    231a:	bd10      	pop	{r4, pc}

0000231c <u8x8_byte_SendByte>:

uint8_t u8x8_byte_SendByte(u8x8_t *u8x8, uint8_t byte)
{
    231c:	b500      	push	{lr}
    231e:	b083      	sub	sp, #12
    2320:	466b      	mov	r3, sp
    2322:	1dda      	adds	r2, r3, #7
    2324:	7011      	strb	r1, [r2, #0]
  return u8x8_byte_SendBytes(u8x8, 1, &byte);
    2326:	2101      	movs	r1, #1
    2328:	4b01      	ldr	r3, [pc, #4]	; (2330 <u8x8_byte_SendByte+0x14>)
    232a:	4798      	blx	r3
}
    232c:	b003      	add	sp, #12
    232e:	bd00      	pop	{pc}
    2330:	0000230f 	.word	0x0000230f

00002334 <u8x8_cad_SendCmd>:
*/

#include "u8x8.h"

uint8_t u8x8_cad_SendCmd(u8x8_t *u8x8, uint8_t cmd)
{
    2334:	b510      	push	{r4, lr}
    2336:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_CMD, cmd, NULL);
    2338:	68c4      	ldr	r4, [r0, #12]
    233a:	2300      	movs	r3, #0
    233c:	2115      	movs	r1, #21
    233e:	47a0      	blx	r4
}
    2340:	bd10      	pop	{r4, pc}

00002342 <u8x8_cad_SendArg>:

uint8_t u8x8_cad_SendArg(u8x8_t *u8x8, uint8_t arg)
{
    2342:	b510      	push	{r4, lr}
    2344:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_ARG, arg, NULL);
    2346:	68c4      	ldr	r4, [r0, #12]
    2348:	2300      	movs	r3, #0
    234a:	2116      	movs	r1, #22
    234c:	47a0      	blx	r4
}
    234e:	bd10      	pop	{r4, pc}

00002350 <u8x8_cad_SendData>:
  }
  return 1;
}

uint8_t u8x8_cad_SendData(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    2350:	b510      	push	{r4, lr}
    2352:	0013      	movs	r3, r2
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, cnt, data);
    2354:	68c4      	ldr	r4, [r0, #12]
    2356:	000a      	movs	r2, r1
    2358:	2117      	movs	r1, #23
    235a:	47a0      	blx	r4
}
    235c:	bd10      	pop	{r4, pc}

0000235e <u8x8_cad_StartTransfer>:

uint8_t u8x8_cad_StartTransfer(u8x8_t *u8x8)
{
    235e:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
    2360:	68c4      	ldr	r4, [r0, #12]
    2362:	2300      	movs	r3, #0
    2364:	2200      	movs	r2, #0
    2366:	2118      	movs	r1, #24
    2368:	47a0      	blx	r4
}
    236a:	bd10      	pop	{r4, pc}

0000236c <u8x8_cad_EndTransfer>:

uint8_t u8x8_cad_EndTransfer(u8x8_t *u8x8)
{
    236c:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
    236e:	68c4      	ldr	r4, [r0, #12]
    2370:	2300      	movs	r3, #0
    2372:	2200      	movs	r2, #0
    2374:	2119      	movs	r1, #25
    2376:	47a0      	blx	r4
}
    2378:	bd10      	pop	{r4, pc}
	...

0000237c <u8x8_cad_SendSequence>:
  254 milli	delay by milliseconds
  255		end of sequence
*/

void u8x8_cad_SendSequence(u8x8_t *u8x8, uint8_t const *data)
{
    237c:	b570      	push	{r4, r5, r6, lr}
    237e:	b082      	sub	sp, #8
    2380:	0006      	movs	r6, r0
    2382:	000c      	movs	r4, r1
  uint8_t cmd;
  uint8_t v;

  for(;;)
  {
    cmd = *data;
    2384:	7821      	ldrb	r1, [r4, #0]
    data++;
    2386:	1c65      	adds	r5, r4, #1
    switch( cmd )
    2388:	2917      	cmp	r1, #23
    238a:	d018      	beq.n	23be <u8x8_cad_SendSequence+0x42>
    238c:	d90c      	bls.n	23a8 <u8x8_cad_SendSequence+0x2c>
    238e:	2919      	cmp	r1, #25
    2390:	d91f      	bls.n	23d2 <u8x8_cad_SendSequence+0x56>
    2392:	29fe      	cmp	r1, #254	; 0xfe
    2394:	d124      	bne.n	23e0 <u8x8_cad_SendSequence+0x64>
      case U8X8_MSG_CAD_START_TRANSFER:
      case U8X8_MSG_CAD_END_TRANSFER:
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
	  break;
      case 0x0fe:
	  v = *data;
    2396:	782a      	ldrb	r2, [r5, #0]
    2398:	466b      	mov	r3, sp
    239a:	71da      	strb	r2, [r3, #7]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
    239c:	2129      	movs	r1, #41	; 0x29
    239e:	0030      	movs	r0, r6
    23a0:	4b10      	ldr	r3, [pc, #64]	; (23e4 <u8x8_cad_SendSequence+0x68>)
    23a2:	4798      	blx	r3
	  data++;
    23a4:	3402      	adds	r4, #2
	  break;
    23a6:	e7ed      	b.n	2384 <u8x8_cad_SendSequence+0x8>
    switch( cmd )
    23a8:	2915      	cmp	r1, #21
    23aa:	d319      	bcc.n	23e0 <u8x8_cad_SendSequence+0x64>
	  v = *data;
    23ac:	782a      	ldrb	r2, [r5, #0]
    23ae:	466b      	mov	r3, sp
    23b0:	71da      	strb	r2, [r3, #7]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
    23b2:	2300      	movs	r3, #0
    23b4:	0030      	movs	r0, r6
    23b6:	68f5      	ldr	r5, [r6, #12]
    23b8:	47a8      	blx	r5
	  data++;
    23ba:	3402      	adds	r4, #2
	  break;
    23bc:	e7e2      	b.n	2384 <u8x8_cad_SendSequence+0x8>
	  v = *data;
    23be:	7863      	ldrb	r3, [r4, #1]
    23c0:	466a      	mov	r2, sp
    23c2:	3207      	adds	r2, #7
    23c4:	7013      	strb	r3, [r2, #0]
	  u8x8_cad_SendData(u8x8, 1, &v);
    23c6:	2101      	movs	r1, #1
    23c8:	0030      	movs	r0, r6
    23ca:	4b07      	ldr	r3, [pc, #28]	; (23e8 <u8x8_cad_SendSequence+0x6c>)
    23cc:	4798      	blx	r3
	  data++;
    23ce:	3402      	adds	r4, #2
	  break;
    23d0:	e7d8      	b.n	2384 <u8x8_cad_SendSequence+0x8>
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
    23d2:	2300      	movs	r3, #0
    23d4:	2200      	movs	r2, #0
    23d6:	0030      	movs	r0, r6
    23d8:	68f4      	ldr	r4, [r6, #12]
    23da:	47a0      	blx	r4
    data++;
    23dc:	002c      	movs	r4, r5
	  break;
    23de:	e7d1      	b.n	2384 <u8x8_cad_SendSequence+0x8>
      default:
	return;
    }
  }
}
    23e0:	b002      	add	sp, #8
    23e2:	bd70      	pop	{r4, r5, r6, pc}
    23e4:	000026e9 	.word	0x000026e9
    23e8:	00002351 	.word	0x00002351

000023ec <u8x8_cad_011>:
  convert to bytes by using 
    dc = 0 for commands 
    dc = 1 for args and data
*/
uint8_t u8x8_cad_011(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    23ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    23ee:	b083      	sub	sp, #12
    23f0:	0004      	movs	r4, r0
    23f2:	000d      	movs	r5, r1
    23f4:	0016      	movs	r6, r2
    23f6:	9301      	str	r3, [sp, #4]
  switch(msg)
    23f8:	000b      	movs	r3, r1
    23fa:	3b14      	subs	r3, #20
    23fc:	b2da      	uxtb	r2, r3
    23fe:	2a05      	cmp	r2, #5
    2400:	d820      	bhi.n	2444 <u8x8_cad_011+0x58>
    2402:	0093      	lsls	r3, r2, #2
    2404:	4a10      	ldr	r2, [pc, #64]	; (2448 <u8x8_cad_011+0x5c>)
    2406:	58d3      	ldr	r3, [r2, r3]
    2408:	469f      	mov	pc, r3
  {
    case U8X8_MSG_CAD_SEND_CMD:
      u8x8_byte_SetDC(u8x8, 0);
    240a:	2100      	movs	r1, #0
    240c:	4b0f      	ldr	r3, [pc, #60]	; (244c <u8x8_cad_011+0x60>)
    240e:	4798      	blx	r3
      u8x8_byte_SendByte(u8x8, arg_int);
    2410:	0031      	movs	r1, r6
    2412:	0020      	movs	r0, r4
    2414:	4b0e      	ldr	r3, [pc, #56]	; (2450 <u8x8_cad_011+0x64>)
    2416:	4798      	blx	r3
    case U8X8_MSG_CAD_END_TRANSFER:
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    default:
      return 0;
  }
  return 1;
    2418:	2001      	movs	r0, #1
      break;
    241a:	e011      	b.n	2440 <u8x8_cad_011+0x54>
      u8x8_byte_SetDC(u8x8, 1);
    241c:	2101      	movs	r1, #1
    241e:	4b0b      	ldr	r3, [pc, #44]	; (244c <u8x8_cad_011+0x60>)
    2420:	4798      	blx	r3
      u8x8_byte_SendByte(u8x8, arg_int);
    2422:	0031      	movs	r1, r6
    2424:	0020      	movs	r0, r4
    2426:	4b0a      	ldr	r3, [pc, #40]	; (2450 <u8x8_cad_011+0x64>)
    2428:	4798      	blx	r3
  return 1;
    242a:	2001      	movs	r0, #1
      break;
    242c:	e008      	b.n	2440 <u8x8_cad_011+0x54>
      u8x8_byte_SetDC(u8x8, 1);
    242e:	2101      	movs	r1, #1
    2430:	4b06      	ldr	r3, [pc, #24]	; (244c <u8x8_cad_011+0x60>)
    2432:	4798      	blx	r3
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    2434:	6927      	ldr	r7, [r4, #16]
    2436:	9b01      	ldr	r3, [sp, #4]
    2438:	0032      	movs	r2, r6
    243a:	0029      	movs	r1, r5
    243c:	0020      	movs	r0, r4
    243e:	47b8      	blx	r7
}
    2440:	b003      	add	sp, #12
    2442:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return 0;
    2444:	2000      	movs	r0, #0
    2446:	e7fb      	b.n	2440 <u8x8_cad_011+0x54>
    2448:	00003f3c 	.word	0x00003f3c
    244c:	00002301 	.word	0x00002301
    2450:	0000231d 	.word	0x0000231d

00002454 <u8x8_d_helper_display_setup_memory>:
  
*/
void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8, const u8x8_display_info_t *display_info)
{
      /* 1) set display info struct */
      u8x8->display_info = display_info;
    2454:	6001      	str	r1, [r0, #0]
      u8x8->x_offset = u8x8->display_info->default_x_offset;
    2456:	7c8a      	ldrb	r2, [r1, #18]
    2458:	2322      	movs	r3, #34	; 0x22
    245a:	54c2      	strb	r2, [r0, r3]
}
    245c:	4770      	bx	lr
	...

00002460 <u8x8_d_helper_display_init>:
  this is a helper function for the U8X8_MSG_DISPLAY_INIT function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_init(u8x8_t *u8x8)
{
    2460:	b570      	push	{r4, r5, r6, lr}
    2462:	0004      	movs	r4, r0
      /* 2) apply port directions to the GPIO lines and apply default values for the IO lines*/
      u8x8_gpio_Init(u8x8);
    2464:	2300      	movs	r3, #0
    2466:	2200      	movs	r2, #0
    2468:	2128      	movs	r1, #40	; 0x28
    246a:	6945      	ldr	r5, [r0, #20]
    246c:	47a8      	blx	r5
      u8x8_cad_Init(u8x8);              /* this will also call U8X8_MSG_BYTE_INIT, byte init will NOT call GPIO_INIT */
    246e:	2300      	movs	r3, #0
    2470:	2200      	movs	r2, #0
    2472:	2114      	movs	r1, #20
    2474:	0020      	movs	r0, r4
    2476:	68e5      	ldr	r5, [r4, #12]
    2478:	47a8      	blx	r5

      /* 3) do reset */
      u8x8_gpio_SetReset(u8x8, 1);
    247a:	2201      	movs	r2, #1
    247c:	214b      	movs	r1, #75	; 0x4b
    247e:	0020      	movs	r0, r4
    2480:	4d0c      	ldr	r5, [pc, #48]	; (24b4 <u8x8_d_helper_display_init+0x54>)
    2482:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    2484:	6823      	ldr	r3, [r4, #0]
    2486:	791a      	ldrb	r2, [r3, #4]
    2488:	2129      	movs	r1, #41	; 0x29
    248a:	0020      	movs	r0, r4
    248c:	47a8      	blx	r5
      u8x8_gpio_SetReset(u8x8, 0);
    248e:	2200      	movs	r2, #0
    2490:	214b      	movs	r1, #75	; 0x4b
    2492:	0020      	movs	r0, r4
    2494:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    2496:	6823      	ldr	r3, [r4, #0]
    2498:	791a      	ldrb	r2, [r3, #4]
    249a:	2129      	movs	r1, #41	; 0x29
    249c:	0020      	movs	r0, r4
    249e:	47a8      	blx	r5
      u8x8_gpio_SetReset(u8x8, 1);
    24a0:	2201      	movs	r2, #1
    24a2:	214b      	movs	r1, #75	; 0x4b
    24a4:	0020      	movs	r0, r4
    24a6:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->post_reset_wait_ms);
    24a8:	6823      	ldr	r3, [r4, #0]
    24aa:	795a      	ldrb	r2, [r3, #5]
    24ac:	2129      	movs	r1, #41	; 0x29
    24ae:	0020      	movs	r0, r4
    24b0:	47a8      	blx	r5
}    
    24b2:	bd70      	pop	{r4, r5, r6, pc}
    24b4:	000026e9 	.word	0x000026e9

000024b8 <u8x8_DrawTile>:

/*==========================================*/
/* official functions */

uint8_t u8x8_DrawTile(u8x8_t *u8x8, uint8_t x, uint8_t y, uint8_t cnt, uint8_t *tile_ptr)
{
    24b8:	b510      	push	{r4, lr}
    24ba:	b082      	sub	sp, #8
  u8x8_tile_t tile;
  tile.x_pos = x;
    24bc:	466c      	mov	r4, sp
    24be:	7161      	strb	r1, [r4, #5]
  tile.y_pos = y;
    24c0:	71a2      	strb	r2, [r4, #6]
  tile.cnt = cnt;
    24c2:	7123      	strb	r3, [r4, #4]
  tile.tile_ptr = tile_ptr;
    24c4:	9b04      	ldr	r3, [sp, #16]
    24c6:	9300      	str	r3, [sp, #0]
  return u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_DRAW_TILE, 1, (void *)&tile);
    24c8:	6884      	ldr	r4, [r0, #8]
    24ca:	466b      	mov	r3, sp
    24cc:	2201      	movs	r2, #1
    24ce:	210f      	movs	r1, #15
    24d0:	47a0      	blx	r4
}
    24d2:	b002      	add	sp, #8
    24d4:	bd10      	pop	{r4, pc}

000024d6 <u8x8_SetupMemory>:

/* should be implemented as macro */
void u8x8_SetupMemory(u8x8_t *u8x8)
{
    24d6:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    24d8:	6884      	ldr	r4, [r0, #8]
    24da:	2300      	movs	r3, #0
    24dc:	2200      	movs	r2, #0
    24de:	2109      	movs	r1, #9
    24e0:	47a0      	blx	r4
}
    24e2:	bd10      	pop	{r4, pc}

000024e4 <u8x8_InitDisplay>:
  In some cases it is not required to init the display (for example if the display is already running, but the controller comes out of deep sleep mode).
  Then InitDisplay can be skipped, but u8x8_InitInterface()  (== u8x8_gpio_Init() and u8x8_cad_Init()) need to be executed.

*/
void u8x8_InitDisplay(u8x8_t *u8x8)
{
    24e4:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);       /* this will call u8x8_d_helper_display_init() and send the init seqence to the display */
    24e6:	6884      	ldr	r4, [r0, #8]
    24e8:	2300      	movs	r3, #0
    24ea:	2200      	movs	r2, #0
    24ec:	210a      	movs	r1, #10
    24ee:	47a0      	blx	r4
  /* u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, 0, NULL);  */ /* It would make sense to call flip mode 0 here after U8X8_MSG_DISPLAY_INIT */
}
    24f0:	bd10      	pop	{r4, pc}

000024f2 <u8x8_RefreshDisplay>:
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_CONTRAST, value, NULL);  
}

void u8x8_RefreshDisplay(u8x8_t *u8x8)
{
    24f2:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    24f4:	6884      	ldr	r4, [r0, #8]
    24f6:	2300      	movs	r3, #0
    24f8:	2200      	movs	r2, #0
    24fa:	2110      	movs	r1, #16
    24fc:	47a0      	blx	r4
}
    24fe:	bd10      	pop	{r4, pc}

00002500 <u8x8_convert_tile_for_ssd1607>:

static uint8_t *u8x8_convert_tile_for_ssd1607(uint8_t *t)
{
	uint8_t i;
	static uint8_t buf[8];
	uint8_t *pbuf = buf;
    2500:	4a06      	ldr	r2, [pc, #24]	; (251c <u8x8_convert_tile_for_ssd1607+0x1c>)

	for( i = 0; i < 8; i++ )
    2502:	2300      	movs	r3, #0
    2504:	e005      	b.n	2512 <u8x8_convert_tile_for_ssd1607+0x12>
	{
		*pbuf++ = (*t++);
    2506:	7801      	ldrb	r1, [r0, #0]
    2508:	7011      	strb	r1, [r2, #0]
	for( i = 0; i < 8; i++ )
    250a:	3301      	adds	r3, #1
    250c:	b2db      	uxtb	r3, r3
		*pbuf++ = (*t++);
    250e:	3201      	adds	r2, #1
    2510:	3001      	adds	r0, #1
	for( i = 0; i < 8; i++ )
    2512:	2b07      	cmp	r3, #7
    2514:	d9f7      	bls.n	2506 <u8x8_convert_tile_for_ssd1607+0x6>
	}
	return buf;
}
    2516:	4801      	ldr	r0, [pc, #4]	; (251c <u8x8_convert_tile_for_ssd1607+0x1c>)
    2518:	4770      	bx	lr
    251a:	46c0      	nop			; (mov r8, r8)
    251c:	200016e0 	.word	0x200016e0

00002520 <u8x8_d_gdey0154_152x304_first_init>:
{
    2520:	b530      	push	{r4, r5, lr}
    2522:	b087      	sub	sp, #28
    2524:	0005      	movs	r5, r0
	u8x8_cad_StartTransfer(u8x8);
    2526:	4b17      	ldr	r3, [pc, #92]	; (2584 <u8x8_d_gdey0154_152x304_first_init+0x64>)
    2528:	4798      	blx	r3
	u8x8_cad_SendCmd(u8x8, 0x10);
    252a:	2110      	movs	r1, #16
    252c:	0028      	movs	r0, r5
    252e:	4b16      	ldr	r3, [pc, #88]	; (2588 <u8x8_d_gdey0154_152x304_first_init+0x68>)
    2530:	4798      	blx	r3
	uint8_t dat[19] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    2532:	2213      	movs	r2, #19
    2534:	2100      	movs	r1, #0
    2536:	a801      	add	r0, sp, #4
    2538:	4b14      	ldr	r3, [pc, #80]	; (258c <u8x8_d_gdey0154_152x304_first_init+0x6c>)
    253a:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    253c:	2400      	movs	r4, #0
    253e:	e006      	b.n	254e <u8x8_d_gdey0154_152x304_first_init+0x2e>
		u8x8_cad_SendData(u8x8, 19, dat);
    2540:	aa01      	add	r2, sp, #4
    2542:	2113      	movs	r1, #19
    2544:	0028      	movs	r0, r5
    2546:	4b12      	ldr	r3, [pc, #72]	; (2590 <u8x8_d_gdey0154_152x304_first_init+0x70>)
    2548:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    254a:	3401      	adds	r4, #1
    254c:	b2a4      	uxth	r4, r4
    254e:	2330      	movs	r3, #48	; 0x30
    2550:	33ff      	adds	r3, #255	; 0xff
    2552:	429c      	cmp	r4, r3
    2554:	d9f4      	bls.n	2540 <u8x8_d_gdey0154_152x304_first_init+0x20>
	u8x8_cad_SendCmd(u8x8, 0x13);
    2556:	2113      	movs	r1, #19
    2558:	0028      	movs	r0, r5
    255a:	4b0b      	ldr	r3, [pc, #44]	; (2588 <u8x8_d_gdey0154_152x304_first_init+0x68>)
    255c:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    255e:	2400      	movs	r4, #0
    2560:	e006      	b.n	2570 <u8x8_d_gdey0154_152x304_first_init+0x50>
		u8x8_cad_SendData(u8x8, 19, dat);
    2562:	aa01      	add	r2, sp, #4
    2564:	2113      	movs	r1, #19
    2566:	0028      	movs	r0, r5
    2568:	4b09      	ldr	r3, [pc, #36]	; (2590 <u8x8_d_gdey0154_152x304_first_init+0x70>)
    256a:	4798      	blx	r3
	for(uint16_t bytesY = 0; bytesY < 304; bytesY ++){
    256c:	3401      	adds	r4, #1
    256e:	b2a4      	uxth	r4, r4
    2570:	2330      	movs	r3, #48	; 0x30
    2572:	33ff      	adds	r3, #255	; 0xff
    2574:	429c      	cmp	r4, r3
    2576:	d9f4      	bls.n	2562 <u8x8_d_gdey0154_152x304_first_init+0x42>
	u8x8_cad_EndTransfer(u8x8);
    2578:	0028      	movs	r0, r5
    257a:	4b06      	ldr	r3, [pc, #24]	; (2594 <u8x8_d_gdey0154_152x304_first_init+0x74>)
    257c:	4798      	blx	r3
}
    257e:	b007      	add	sp, #28
    2580:	bd30      	pop	{r4, r5, pc}
    2582:	46c0      	nop			; (mov r8, r8)
    2584:	0000235f 	.word	0x0000235f
    2588:	00002335 	.word	0x00002335
    258c:	00002c59 	.word	0x00002c59
    2590:	00002351 	.word	0x00002351
    2594:	0000236d 	.word	0x0000236d

00002598 <u8x8_d_ssd1607_draw_tile>:

static void u8x8_d_ssd1607_draw_tile(u8x8_t *u8x8, uint8_t arg_int, void *arg_ptr) U8X8_NOINLINE;
static void u8x8_d_ssd1607_draw_tile(u8x8_t *u8x8, uint8_t arg_int, void *arg_ptr)
{
    2598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    259a:	46ce      	mov	lr, r9
    259c:	4647      	mov	r7, r8
    259e:	b580      	push	{r7, lr}
    25a0:	0006      	movs	r6, r0
    25a2:	000f      	movs	r7, r1
    25a4:	4690      	mov	r8, r2
	uint16_t x;
	uint16_t c, page;
	uint8_t *ptr;
	u8x8_cad_StartTransfer(u8x8);
    25a6:	4b26      	ldr	r3, [pc, #152]	; (2640 <u8x8_d_ssd1607_draw_tile+0xa8>)
    25a8:	4798      	blx	r3

	page = u8x8->display_info->tile_height;
    25aa:	6833      	ldr	r3, [r6, #0]
    25ac:	7c5c      	ldrb	r4, [r3, #17]
	page --;
    25ae:	3c01      	subs	r4, #1
    25b0:	b2a4      	uxth	r4, r4
	page -= (((u8x8_tile_t *)arg_ptr)->y_pos);
    25b2:	4643      	mov	r3, r8
    25b4:	799b      	ldrb	r3, [r3, #6]
    25b6:	1ae4      	subs	r4, r4, r3
    25b8:	b2a4      	uxth	r4, r4
	
	x = ((u8x8_tile_t *)arg_ptr)->x_pos;
	x *= 8;
	x += u8x8->x_offset;
	
	u8x8_cad_SendCmd(u8x8, 0x91);			//Partial Window (PTL)
    25ba:	2191      	movs	r1, #145	; 0x91
    25bc:	0030      	movs	r0, r6
    25be:	4b21      	ldr	r3, [pc, #132]	; (2644 <u8x8_d_ssd1607_draw_tile+0xac>)
    25c0:	4699      	mov	r9, r3
    25c2:	4798      	blx	r3
	u8x8_cad_SendCmd(u8x8, 0x90);			//Partial In (PTIN)
    25c4:	2190      	movs	r1, #144	; 0x90
    25c6:	0030      	movs	r0, r6
    25c8:	47c8      	blx	r9
	
	u8x8_cad_SendArg(u8x8, page << 3);		//HRST[7:3]
    25ca:	00e4      	lsls	r4, r4, #3
    25cc:	b2e4      	uxtb	r4, r4
    25ce:	0021      	movs	r1, r4
    25d0:	0030      	movs	r0, r6
    25d2:	4d1d      	ldr	r5, [pc, #116]	; (2648 <u8x8_d_ssd1607_draw_tile+0xb0>)
    25d4:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, page << 3);		//HRED[7:3]
    25d6:	0021      	movs	r1, r4
    25d8:	0030      	movs	r0, r6
    25da:	47a8      	blx	r5

	u8x8_cad_SendArg(u8x8, 0x00);			//VRST[8]
    25dc:	2100      	movs	r1, #0
    25de:	0030      	movs	r0, r6
    25e0:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, 0x00);			//VRST[7:0]
    25e2:	2100      	movs	r1, #0
    25e4:	0030      	movs	r0, r6
    25e6:	47a8      	blx	r5

	u8x8_cad_SendArg(u8x8, 0x01);			//VRED[8]
    25e8:	2101      	movs	r1, #1
    25ea:	0030      	movs	r0, r6
    25ec:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, 0x30);			//VRED[7:0]
    25ee:	2130      	movs	r1, #48	; 0x30
    25f0:	0030      	movs	r0, r6
    25f2:	47a8      	blx	r5
	u8x8_cad_SendArg(u8x8, 1);				//PT_SCAN
    25f4:	2101      	movs	r1, #1
    25f6:	0030      	movs	r0, r6
    25f8:	47a8      	blx	r5
	u8x8_cad_SendCmd(u8x8, 0x10 );
    25fa:	2110      	movs	r1, #16
    25fc:	0030      	movs	r0, r6
    25fe:	47c8      	blx	r9
	
	do
	{
		c = ((u8x8_tile_t *)arg_ptr)->cnt;
    2600:	4643      	mov	r3, r8
    2602:	791c      	ldrb	r4, [r3, #4]
		
		ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;
    2604:	681d      	ldr	r5, [r3, #0]
		do
		{
			u8x8_cad_SendData(u8x8, 8, u8x8_convert_tile_for_ssd1607(ptr));
    2606:	0028      	movs	r0, r5
    2608:	4b10      	ldr	r3, [pc, #64]	; (264c <u8x8_d_ssd1607_draw_tile+0xb4>)
    260a:	4798      	blx	r3
    260c:	0002      	movs	r2, r0
    260e:	2108      	movs	r1, #8
    2610:	0030      	movs	r0, r6
    2612:	4b0f      	ldr	r3, [pc, #60]	; (2650 <u8x8_d_ssd1607_draw_tile+0xb8>)
    2614:	4798      	blx	r3
			ptr += 8;
    2616:	3508      	adds	r5, #8
			x += 8;
			c--;
    2618:	3c01      	subs	r4, #1
    261a:	b2a4      	uxth	r4, r4
		} while( c > 0 );
    261c:	2c00      	cmp	r4, #0
    261e:	d1f2      	bne.n	2606 <u8x8_d_ssd1607_draw_tile+0x6e>
		arg_int--;
    2620:	3f01      	subs	r7, #1
    2622:	b2ff      	uxtb	r7, r7
	} while( arg_int > 0 );
    2624:	2f00      	cmp	r7, #0
    2626:	d1eb      	bne.n	2600 <u8x8_d_ssd1607_draw_tile+0x68>
	u8x8_cad_SendCmd(u8x8, 0x92);		//Partial Out (PTOUT)
    2628:	2192      	movs	r1, #146	; 0x92
    262a:	0030      	movs	r0, r6
    262c:	4b05      	ldr	r3, [pc, #20]	; (2644 <u8x8_d_ssd1607_draw_tile+0xac>)
    262e:	4798      	blx	r3
	u8x8_cad_EndTransfer(u8x8);
    2630:	0030      	movs	r0, r6
    2632:	4b08      	ldr	r3, [pc, #32]	; (2654 <u8x8_d_ssd1607_draw_tile+0xbc>)
    2634:	4798      	blx	r3
}
    2636:	bc0c      	pop	{r2, r3}
    2638:	4690      	mov	r8, r2
    263a:	4699      	mov	r9, r3
    263c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    263e:	46c0      	nop			; (mov r8, r8)
    2640:	0000235f 	.word	0x0000235f
    2644:	00002335 	.word	0x00002335
    2648:	00002343 	.word	0x00002343
    264c:	00002501 	.word	0x00002501
    2650:	00002351 	.word	0x00002351
    2654:	0000236d 	.word	0x0000236d

00002658 <u8x8_d_gdey0154_152x304>:
	U8X8_END_TRANSFER(),             	/* disable chip */
	U8X8_END()             			/* end of sequence */
};

uint8_t u8x8_d_gdey0154_152x304(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2658:	b570      	push	{r4, r5, r6, lr}
    265a:	0004      	movs	r4, r0
    265c:	0010      	movs	r0, r2
	switch(msg)
    265e:	3909      	subs	r1, #9
    2660:	b2cd      	uxtb	r5, r1
    2662:	2d07      	cmp	r5, #7
    2664:	d803      	bhi.n	266e <u8x8_d_gdey0154_152x304+0x16>
    2666:	00a9      	lsls	r1, r5, #2
    2668:	4a15      	ldr	r2, [pc, #84]	; (26c0 <u8x8_d_gdey0154_152x304+0x68>)
    266a:	5852      	ldr	r2, [r2, r1]
    266c:	4697      	mov	pc, r2
		break;
		case U8X8_MSG_DISPLAY_REFRESH:
		u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1607_to_display_seq);
		break;
		default:
		return 0;
    266e:	2000      	movs	r0, #0
    2670:	e024      	b.n	26bc <u8x8_d_gdey0154_152x304+0x64>
		u8x8_d_helper_display_setup_memory(u8x8, &u8x8_ssd1607_200x200_display_info);
    2672:	4914      	ldr	r1, [pc, #80]	; (26c4 <u8x8_d_gdey0154_152x304+0x6c>)
    2674:	0020      	movs	r0, r4
    2676:	4b14      	ldr	r3, [pc, #80]	; (26c8 <u8x8_d_gdey0154_152x304+0x70>)
    2678:	4798      	blx	r3
	}
	return 1;
    267a:	2001      	movs	r0, #1
		break;
    267c:	e01e      	b.n	26bc <u8x8_d_gdey0154_152x304+0x64>
		u8x8_d_helper_display_init(u8x8);
    267e:	0020      	movs	r0, r4
    2680:	4b12      	ldr	r3, [pc, #72]	; (26cc <u8x8_d_gdey0154_152x304+0x74>)
    2682:	4798      	blx	r3
		u8x8_cad_SendSequence(u8x8, u8x8_d_gdey0154_152x304_init_seq);
    2684:	4912      	ldr	r1, [pc, #72]	; (26d0 <u8x8_d_gdey0154_152x304+0x78>)
    2686:	0020      	movs	r0, r4
    2688:	4b12      	ldr	r3, [pc, #72]	; (26d4 <u8x8_d_gdey0154_152x304+0x7c>)
    268a:	4798      	blx	r3
		delay_ms(20);
    268c:	2014      	movs	r0, #20
    268e:	4d12      	ldr	r5, [pc, #72]	; (26d8 <u8x8_d_gdey0154_152x304+0x80>)
    2690:	47a8      	blx	r5
		u8x8_d_gdey0154_152x304_first_init(u8x8);
    2692:	0020      	movs	r0, r4
    2694:	4b11      	ldr	r3, [pc, #68]	; (26dc <u8x8_d_gdey0154_152x304+0x84>)
    2696:	4798      	blx	r3
		delay_ms(20);
    2698:	2014      	movs	r0, #20
    269a:	47a8      	blx	r5
	return 1;
    269c:	2001      	movs	r0, #1
		break;
    269e:	e00d      	b.n	26bc <u8x8_d_gdey0154_152x304+0x64>
		u8x8_d_ssd1607_draw_tile(u8x8, arg_int, arg_ptr);
    26a0:	001a      	movs	r2, r3
    26a2:	0001      	movs	r1, r0
    26a4:	0020      	movs	r0, r4
    26a6:	4b0e      	ldr	r3, [pc, #56]	; (26e0 <u8x8_d_gdey0154_152x304+0x88>)
    26a8:	4798      	blx	r3
	return 1;
    26aa:	2001      	movs	r0, #1
		break;
    26ac:	e006      	b.n	26bc <u8x8_d_gdey0154_152x304+0x64>
		u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1607_to_display_seq);
    26ae:	490d      	ldr	r1, [pc, #52]	; (26e4 <u8x8_d_gdey0154_152x304+0x8c>)
    26b0:	0020      	movs	r0, r4
    26b2:	4b08      	ldr	r3, [pc, #32]	; (26d4 <u8x8_d_gdey0154_152x304+0x7c>)
    26b4:	4798      	blx	r3
	return 1;
    26b6:	2001      	movs	r0, #1
		break;
    26b8:	e000      	b.n	26bc <u8x8_d_gdey0154_152x304+0x64>
	return 1;
    26ba:	2001      	movs	r0, #1
}
    26bc:	bd70      	pop	{r4, r5, r6, pc}
    26be:	46c0      	nop			; (mov r8, r8)
    26c0:	00003f54 	.word	0x00003f54
    26c4:	00003fb4 	.word	0x00003fb4
    26c8:	00002455 	.word	0x00002455
    26cc:	00002461 	.word	0x00002461
    26d0:	00003f74 	.word	0x00003f74
    26d4:	0000237d 	.word	0x0000237d
    26d8:	000001c1 	.word	0x000001c1
    26dc:	00002521 	.word	0x00002521
    26e0:	00002599 	.word	0x00002599
    26e4:	00003fac 	.word	0x00003fac

000026e8 <u8x8_gpio_call>:

#include "u8x8.h"


void u8x8_gpio_call(u8x8_t *u8x8, uint8_t msg, uint8_t arg)
{
    26e8:	b510      	push	{r4, lr}
  u8x8->gpio_and_delay_cb(u8x8, msg, arg, NULL);
    26ea:	6944      	ldr	r4, [r0, #20]
    26ec:	2300      	movs	r3, #0
    26ee:	47a0      	blx	r4
}
    26f0:	bd10      	pop	{r4, pc}

000026f2 <u8x8_dummy_cb>:
/* universal dummy callback, which will be default for all callbacks */
uint8_t u8x8_dummy_cb(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
  /* the dummy callback will not handle any message and will fail for all messages */
  return 0;
}
    26f2:	2000      	movs	r0, #0
    26f4:	4770      	bx	lr
	...

000026f8 <u8x8_SetupDefaults>:
  Args:
    u8x8	An empty u8x8 structure
*/
void u8x8_SetupDefaults(u8x8_t *u8x8)
{
    u8x8->display_info = NULL;
    26f8:	2300      	movs	r3, #0
    26fa:	6003      	str	r3, [r0, #0]
    u8x8->display_cb = u8x8_dummy_cb;
    26fc:	4a07      	ldr	r2, [pc, #28]	; (271c <u8x8_SetupDefaults+0x24>)
    26fe:	6082      	str	r2, [r0, #8]
    u8x8->cad_cb = u8x8_dummy_cb;
    2700:	60c2      	str	r2, [r0, #12]
    u8x8->byte_cb = u8x8_dummy_cb;
    2702:	6102      	str	r2, [r0, #16]
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    2704:	6142      	str	r2, [r0, #20]
    u8x8->is_font_inverse_mode = 0;
    2706:	2223      	movs	r2, #35	; 0x23
    2708:	5483      	strb	r3, [r0, r2]
    //u8x8->device_address = 0;
    u8x8->utf8_state = 0;		/* also reset by u8x8_utf8_init */
    270a:	3203      	adds	r2, #3
    270c:	5483      	strb	r3, [r0, r2]
    u8x8->bus_clock = 0;		/* issue 769 */
    270e:	6183      	str	r3, [r0, #24]
    u8x8->i2c_address = 255;
    2710:	33ff      	adds	r3, #255	; 0xff
    2712:	3a02      	subs	r2, #2
    2714:	5483      	strb	r3, [r0, r2]
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    2716:	3204      	adds	r2, #4
    2718:	5483      	strb	r3, [r0, r2]
    uint8_t i;
    for( i = 0; i < U8X8_PIN_CNT; i++ )
      u8x8->pins[i] = U8X8_PIN_NONE;
  }
#endif
}
    271a:	4770      	bx	lr
    271c:	000026f3 	.word	0x000026f3

00002720 <u8x8_Setup>:
    byte_cb			Display controller/communication specific callback funtion
    gpio_and_delay_cb	Environment specific callback function

*/
void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    2720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2722:	0004      	movs	r4, r0
    2724:	000f      	movs	r7, r1
    2726:	0016      	movs	r6, r2
    2728:	001d      	movs	r5, r3
  /* setup defaults and reset pins to U8X8_PIN_NONE */
  u8x8_SetupDefaults(u8x8);
    272a:	4b05      	ldr	r3, [pc, #20]	; (2740 <u8x8_Setup+0x20>)
    272c:	4798      	blx	r3

  /* setup specific callbacks */
  u8x8->display_cb = display_cb;
    272e:	60a7      	str	r7, [r4, #8]
  u8x8->cad_cb = cad_cb;
    2730:	60e6      	str	r6, [r4, #12]
  u8x8->byte_cb = byte_cb;
    2732:	6125      	str	r5, [r4, #16]
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    2734:	9b06      	ldr	r3, [sp, #24]
    2736:	6163      	str	r3, [r4, #20]

  /* setup display info */
  u8x8_SetupMemory(u8x8);
    2738:	0020      	movs	r0, r4
    273a:	4b02      	ldr	r3, [pc, #8]	; (2744 <u8x8_Setup+0x24>)
    273c:	4798      	blx	r3
}
    273e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2740:	000026f9 	.word	0x000026f9
    2744:	000024d7 	.word	0x000024d7

00002748 <rtc_int_enable>:
	"Sat"
};



void rtc_int_enable(rtc_date *RTCx){
    2748:	b570      	push	{r4, r5, r6, lr}
	rtc_config_3[1] |= (1 << TIE);
    274a:	4d0c      	ldr	r5, [pc, #48]	; (277c <rtc_int_enable+0x34>)
    274c:	786b      	ldrb	r3, [r5, #1]
    274e:	2210      	movs	r2, #16
    2750:	4313      	orrs	r3, r2
    2752:	706b      	strb	r3, [r5, #1]
	rtc_config_2[1] |= (1 << TD) | (1 << TE);
    2754:	4e0a      	ldr	r6, [pc, #40]	; (2780 <rtc_int_enable+0x38>)
    2756:	7873      	ldrb	r3, [r6, #1]
    2758:	2211      	movs	r2, #17
    275a:	4313      	orrs	r3, r2
    275c:	7073      	strb	r3, [r6, #1]
	
	RTC_write_batch(RTC_ADDR, rtc_config_1,sizeof(rtc_config_1));
    275e:	2203      	movs	r2, #3
    2760:	4908      	ldr	r1, [pc, #32]	; (2784 <rtc_int_enable+0x3c>)
    2762:	2032      	movs	r0, #50	; 0x32
    2764:	4c08      	ldr	r4, [pc, #32]	; (2788 <rtc_int_enable+0x40>)
    2766:	47a0      	blx	r4
	RTC_write_batch(RTC_ADDR, rtc_config_2,sizeof(rtc_config_2));
    2768:	2202      	movs	r2, #2
    276a:	0031      	movs	r1, r6
    276c:	2032      	movs	r0, #50	; 0x32
    276e:	47a0      	blx	r4
	RTC_write_batch(RTC_ADDR, rtc_config_3,sizeof(rtc_config_3));
    2770:	2202      	movs	r2, #2
    2772:	0029      	movs	r1, r5
    2774:	2032      	movs	r0, #50	; 0x32
    2776:	47a0      	blx	r4
	
	
}
    2778:	bd70      	pop	{r4, r5, r6, pc}
    277a:	46c0      	nop			; (mov r8, r8)
    277c:	20000008 	.word	0x20000008
    2780:	20000004 	.word	0x20000004
    2784:	20000000 	.word	0x20000000
    2788:	000011dd 	.word	0x000011dd

0000278c <BCDtoDEC>:
	rtc_raw[7]=DECtoBCD(RTCx->year);
	RTC_write_batch(RTC_ADDR, rtc_raw,sizeof(rtc_raw));
}

uint8_t BCDtoDEC(uint8_t val)
{
    278c:	0001      	movs	r1, r0
	return ((val / 0x10) * 10) + (val % 0x10);
    278e:	0902      	lsrs	r2, r0, #4
    2790:	0093      	lsls	r3, r2, #2
    2792:	18d2      	adds	r2, r2, r3
    2794:	0053      	lsls	r3, r2, #1
    2796:	b2db      	uxtb	r3, r3
    2798:	200f      	movs	r0, #15
    279a:	4008      	ands	r0, r1
    279c:	1818      	adds	r0, r3, r0
    279e:	b2c0      	uxtb	r0, r0
}
    27a0:	4770      	bx	lr
	...

000027a4 <rtc_sync>:
void rtc_sync(rtc_date *RTCx){
    27a4:	b530      	push	{r4, r5, lr}
    27a6:	b083      	sub	sp, #12
    27a8:	0004      	movs	r4, r0
	RTC_read_batch(RTC_ADDR, rtc_raw, sizeof(rtc_raw));
    27aa:	2207      	movs	r2, #7
    27ac:	4669      	mov	r1, sp
    27ae:	2032      	movs	r0, #50	; 0x32
    27b0:	4b0f      	ldr	r3, [pc, #60]	; (27f0 <rtc_sync+0x4c>)
    27b2:	4798      	blx	r3
	RTCx->second=BCDtoDEC(rtc_raw[0]);
    27b4:	466b      	mov	r3, sp
    27b6:	7818      	ldrb	r0, [r3, #0]
    27b8:	4d0e      	ldr	r5, [pc, #56]	; (27f4 <rtc_sync+0x50>)
    27ba:	47a8      	blx	r5
    27bc:	7020      	strb	r0, [r4, #0]
	RTCx->minute=BCDtoDEC(rtc_raw[1]);
    27be:	466b      	mov	r3, sp
    27c0:	7858      	ldrb	r0, [r3, #1]
    27c2:	47a8      	blx	r5
    27c4:	7060      	strb	r0, [r4, #1]
	RTCx->hour=BCDtoDEC(rtc_raw[2]);
    27c6:	466b      	mov	r3, sp
    27c8:	7898      	ldrb	r0, [r3, #2]
    27ca:	47a8      	blx	r5
    27cc:	70a0      	strb	r0, [r4, #2]
	RTCx->dayofweek=rtc_raw[3];
    27ce:	466b      	mov	r3, sp
    27d0:	78db      	ldrb	r3, [r3, #3]
    27d2:	7223      	strb	r3, [r4, #8]
	RTCx->date=BCDtoDEC(rtc_raw[4]);
    27d4:	466b      	mov	r3, sp
    27d6:	7918      	ldrb	r0, [r3, #4]
    27d8:	47a8      	blx	r5
    27da:	70e0      	strb	r0, [r4, #3]
	RTCx->month=BCDtoDEC(rtc_raw[5]);
    27dc:	466b      	mov	r3, sp
    27de:	7958      	ldrb	r0, [r3, #5]
    27e0:	47a8      	blx	r5
    27e2:	7120      	strb	r0, [r4, #4]
	RTCx->year=BCDtoDEC(rtc_raw[6]);
    27e4:	466b      	mov	r3, sp
    27e6:	7998      	ldrb	r0, [r3, #6]
    27e8:	47a8      	blx	r5
    27ea:	80e0      	strh	r0, [r4, #6]
}
    27ec:	b003      	add	sp, #12
    27ee:	bd30      	pop	{r4, r5, pc}
    27f0:	00001211 	.word	0x00001211
    27f4:	0000278d 	.word	0x0000278d

000027f8 <DECtoBCD>:

// BCDtoDEC -- convert decimal to binary-coded decimal (BCD)
uint8_t DECtoBCD(uint8_t val)
{
    27f8:	b570      	push	{r4, r5, r6, lr}
    27fa:	0005      	movs	r5, r0
	return ((val / 10) * 0x10) + (val % 10);
    27fc:	210a      	movs	r1, #10
    27fe:	4b05      	ldr	r3, [pc, #20]	; (2814 <DECtoBCD+0x1c>)
    2800:	4798      	blx	r3
    2802:	0100      	lsls	r0, r0, #4
    2804:	b2c4      	uxtb	r4, r0
    2806:	210a      	movs	r1, #10
    2808:	0028      	movs	r0, r5
    280a:	4b03      	ldr	r3, [pc, #12]	; (2818 <DECtoBCD+0x20>)
    280c:	4798      	blx	r3
    280e:	1864      	adds	r4, r4, r1
    2810:	b2e0      	uxtb	r0, r4
}
    2812:	bd70      	pop	{r4, r5, r6, pc}
    2814:	00002aa5 	.word	0x00002aa5
    2818:	00002bb1 	.word	0x00002bb1

0000281c <rtc_set>:
void rtc_set(rtc_date *RTCx){
    281c:	b530      	push	{r4, r5, lr}
    281e:	b083      	sub	sp, #12
    2820:	0004      	movs	r4, r0
	rtc_raw[0] = 0;
    2822:	2300      	movs	r3, #0
    2824:	466a      	mov	r2, sp
    2826:	7013      	strb	r3, [r2, #0]
	rtc_raw[1]=DECtoBCD(RTCx->second);
    2828:	7800      	ldrb	r0, [r0, #0]
    282a:	4d11      	ldr	r5, [pc, #68]	; (2870 <rtc_set+0x54>)
    282c:	47a8      	blx	r5
    282e:	466b      	mov	r3, sp
    2830:	7058      	strb	r0, [r3, #1]
	rtc_raw[2]=DECtoBCD(RTCx->minute);
    2832:	7860      	ldrb	r0, [r4, #1]
    2834:	47a8      	blx	r5
    2836:	466b      	mov	r3, sp
    2838:	7098      	strb	r0, [r3, #2]
	rtc_raw[3]=DECtoBCD(RTCx->hour);
    283a:	78a0      	ldrb	r0, [r4, #2]
    283c:	47a8      	blx	r5
    283e:	466b      	mov	r3, sp
    2840:	70d8      	strb	r0, [r3, #3]
	rtc_raw[4]=RTCx->dayofweek;
    2842:	7a23      	ldrb	r3, [r4, #8]
    2844:	466a      	mov	r2, sp
    2846:	7113      	strb	r3, [r2, #4]
	rtc_raw[5]=DECtoBCD(RTCx->date);
    2848:	78e0      	ldrb	r0, [r4, #3]
    284a:	47a8      	blx	r5
    284c:	466b      	mov	r3, sp
    284e:	7158      	strb	r0, [r3, #5]
	rtc_raw[6]=DECtoBCD(RTCx->month);
    2850:	7920      	ldrb	r0, [r4, #4]
    2852:	47a8      	blx	r5
    2854:	466b      	mov	r3, sp
    2856:	7198      	strb	r0, [r3, #6]
	rtc_raw[7]=DECtoBCD(RTCx->year);
    2858:	79a0      	ldrb	r0, [r4, #6]
    285a:	47a8      	blx	r5
    285c:	466b      	mov	r3, sp
    285e:	71d8      	strb	r0, [r3, #7]
	RTC_write_batch(RTC_ADDR, rtc_raw,sizeof(rtc_raw));
    2860:	2208      	movs	r2, #8
    2862:	4669      	mov	r1, sp
    2864:	2032      	movs	r0, #50	; 0x32
    2866:	4b03      	ldr	r3, [pc, #12]	; (2874 <rtc_set+0x58>)
    2868:	4798      	blx	r3
}
    286a:	b003      	add	sp, #12
    286c:	bd30      	pop	{r4, r5, pc}
    286e:	46c0      	nop			; (mov r8, r8)
    2870:	000027f9 	.word	0x000027f9
    2874:	000011dd 	.word	0x000011dd

00002878 <main>:
	.second = 00
};


int main(void)
{
    2878:	b5f0      	push	{r4, r5, r6, r7, lr}
    287a:	b085      	sub	sp, #20
	/* Initializes MCU, drivers and middleware */
	//atmel_start_init();
	mcu_init();
    287c:	4b66      	ldr	r3, [pc, #408]	; (2a18 <main+0x1a0>)
    287e:	4798      	blx	r3
	
	rtc_set(&sys_rtc);
    2880:	4c66      	ldr	r4, [pc, #408]	; (2a1c <main+0x1a4>)
    2882:	0020      	movs	r0, r4
    2884:	4b66      	ldr	r3, [pc, #408]	; (2a20 <main+0x1a8>)
    2886:	4798      	blx	r3
	rtc_int_enable(&sys_rtc);
    2888:	0020      	movs	r0, r4
    288a:	4b66      	ldr	r3, [pc, #408]	; (2a24 <main+0x1ac>)
    288c:	4798      	blx	r3

	u8g2_Setup_GDEY0154_152x304_f(&lcd, U8G2_R0, screenSpi, screenSpi);
    288e:	4a66      	ldr	r2, [pc, #408]	; (2a28 <main+0x1b0>)
    2890:	4c66      	ldr	r4, [pc, #408]	; (2a2c <main+0x1b4>)
    2892:	0013      	movs	r3, r2
    2894:	4966      	ldr	r1, [pc, #408]	; (2a30 <main+0x1b8>)
    2896:	0020      	movs	r0, r4
    2898:	4d66      	ldr	r5, [pc, #408]	; (2a34 <main+0x1bc>)
    289a:	47a8      	blx	r5
	
	
	u8g2_InitDisplay(&lcd);
    289c:	0020      	movs	r0, r4
    289e:	4b66      	ldr	r3, [pc, #408]	; (2a38 <main+0x1c0>)
    28a0:	4798      	blx	r3
	u8g2_ClearBuffer(&lcd);
    28a2:	0020      	movs	r0, r4
    28a4:	4b65      	ldr	r3, [pc, #404]	; (2a3c <main+0x1c4>)
    28a6:	4798      	blx	r3
	
	
	
	
	
	u8g2_DrawLine(&lcd, 70, 1, 70 , 90);
    28a8:	265a      	movs	r6, #90	; 0x5a
    28aa:	9600      	str	r6, [sp, #0]
    28ac:	2346      	movs	r3, #70	; 0x46
    28ae:	2201      	movs	r2, #1
    28b0:	2146      	movs	r1, #70	; 0x46
    28b2:	0020      	movs	r0, r4
    28b4:	4d62      	ldr	r5, [pc, #392]	; (2a40 <main+0x1c8>)
    28b6:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 140, 1, 140 , 90);
    28b8:	9600      	str	r6, [sp, #0]
    28ba:	238c      	movs	r3, #140	; 0x8c
    28bc:	2201      	movs	r2, #1
    28be:	218c      	movs	r1, #140	; 0x8c
    28c0:	0020      	movs	r0, r4
    28c2:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 210, 1, 210 , 90);
    28c4:	9600      	str	r6, [sp, #0]
    28c6:	23d2      	movs	r3, #210	; 0xd2
    28c8:	2201      	movs	r2, #1
    28ca:	21d2      	movs	r1, #210	; 0xd2
    28cc:	0020      	movs	r0, r4
    28ce:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 280, 1, 280 , 90);
    28d0:	218c      	movs	r1, #140	; 0x8c
    28d2:	0049      	lsls	r1, r1, #1
    28d4:	9600      	str	r6, [sp, #0]
    28d6:	000b      	movs	r3, r1
    28d8:	2201      	movs	r2, #1
    28da:	0020      	movs	r0, r4
    28dc:	47a8      	blx	r5
	u8g2_DrawLine(&lcd, 1, 90, 320 , 90);
    28de:	9600      	str	r6, [sp, #0]
    28e0:	23a0      	movs	r3, #160	; 0xa0
    28e2:	005b      	lsls	r3, r3, #1
    28e4:	225a      	movs	r2, #90	; 0x5a
    28e6:	2101      	movs	r1, #1
    28e8:	0020      	movs	r0, r4
    28ea:	47a8      	blx	r5
	
	
	u8g2_SetFont(&lcd, u8g2_font_open_iconic_weather_6x_t);
    28ec:	4955      	ldr	r1, [pc, #340]	; (2a44 <main+0x1cc>)
    28ee:	0020      	movs	r0, r4
    28f0:	4e55      	ldr	r6, [pc, #340]	; (2a48 <main+0x1d0>)
    28f2:	47b0      	blx	r6
	u8g2_DrawGlyph(&lcd, 10, 51, 69);
    28f4:	2345      	movs	r3, #69	; 0x45
    28f6:	2233      	movs	r2, #51	; 0x33
    28f8:	210a      	movs	r1, #10
    28fa:	0020      	movs	r0, r4
    28fc:	4d53      	ldr	r5, [pc, #332]	; (2a4c <main+0x1d4>)
    28fe:	47a8      	blx	r5
	u8g2_DrawGlyph(&lcd, 81, 51, 64);
    2900:	2340      	movs	r3, #64	; 0x40
    2902:	2233      	movs	r2, #51	; 0x33
    2904:	2151      	movs	r1, #81	; 0x51
    2906:	0020      	movs	r0, r4
    2908:	47a8      	blx	r5
	u8g2_DrawGlyph(&lcd, 151, 51, 65);
    290a:	2341      	movs	r3, #65	; 0x41
    290c:	2233      	movs	r2, #51	; 0x33
    290e:	2197      	movs	r1, #151	; 0x97
    2910:	0020      	movs	r0, r4
    2912:	47a8      	blx	r5
	u8g2_DrawGlyph(&lcd, 221, 51, 67);
    2914:	2343      	movs	r3, #67	; 0x43
    2916:	2233      	movs	r2, #51	; 0x33
    2918:	21dd      	movs	r1, #221	; 0xdd
    291a:	0020      	movs	r0, r4
    291c:	47a8      	blx	r5
	
	
	
	
	u8g2_SetFont(&lcd, u8g2_font_ncenB14_tr);
    291e:	494c      	ldr	r1, [pc, #304]	; (2a50 <main+0x1d8>)
    2920:	0020      	movs	r0, r4
    2922:	47b0      	blx	r6
	
	u8g2_DrawStr(&lcd, 10, 70, (void *)"+13°C");
    2924:	4b4b      	ldr	r3, [pc, #300]	; (2a54 <main+0x1dc>)
    2926:	2246      	movs	r2, #70	; 0x46
    2928:	210a      	movs	r1, #10
    292a:	0020      	movs	r0, r4
    292c:	4d4a      	ldr	r5, [pc, #296]	; (2a58 <main+0x1e0>)
    292e:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10, 86, (void *)"734P");
    2930:	4b4a      	ldr	r3, [pc, #296]	; (2a5c <main+0x1e4>)
    2932:	2256      	movs	r2, #86	; 0x56
    2934:	210a      	movs	r1, #10
    2936:	0020      	movs	r0, r4
    2938:	47a8      	blx	r5
	
	u8g2_DrawStr(&lcd, 10+70, 70, (void *)"+16°C");
    293a:	4b49      	ldr	r3, [pc, #292]	; (2a60 <main+0x1e8>)
    293c:	2246      	movs	r2, #70	; 0x46
    293e:	2150      	movs	r1, #80	; 0x50
    2940:	0020      	movs	r0, r4
    2942:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10+70, 86, (void *)"736P");
    2944:	4b47      	ldr	r3, [pc, #284]	; (2a64 <main+0x1ec>)
    2946:	2256      	movs	r2, #86	; 0x56
    2948:	2150      	movs	r1, #80	; 0x50
    294a:	0020      	movs	r0, r4
    294c:	47a8      	blx	r5
	
	u8g2_DrawStr(&lcd, 10+140, 70, (void *)"+14°C");
    294e:	4b46      	ldr	r3, [pc, #280]	; (2a68 <main+0x1f0>)
    2950:	2246      	movs	r2, #70	; 0x46
    2952:	2196      	movs	r1, #150	; 0x96
    2954:	0020      	movs	r0, r4
    2956:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10+140, 86, (void *)"737P");
    2958:	4f44      	ldr	r7, [pc, #272]	; (2a6c <main+0x1f4>)
    295a:	003b      	movs	r3, r7
    295c:	2256      	movs	r2, #86	; 0x56
    295e:	2196      	movs	r1, #150	; 0x96
    2960:	0020      	movs	r0, r4
    2962:	47a8      	blx	r5

	u8g2_DrawStr(&lcd, 10+210, 70, (void *)"+10°C");
    2964:	4b42      	ldr	r3, [pc, #264]	; (2a70 <main+0x1f8>)
    2966:	2246      	movs	r2, #70	; 0x46
    2968:	21dc      	movs	r1, #220	; 0xdc
    296a:	0020      	movs	r0, r4
    296c:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 10+210, 86, (void *)"737P");
    296e:	003b      	movs	r3, r7
    2970:	2256      	movs	r2, #86	; 0x56
    2972:	21dc      	movs	r1, #220	; 0xdc
    2974:	0020      	movs	r0, r4
    2976:	47a8      	blx	r5
	
	u8g2_DrawStr(&lcd, 15, 110, (void *)"Thursday 25-04-2024");
    2978:	4b3e      	ldr	r3, [pc, #248]	; (2a74 <main+0x1fc>)
    297a:	226e      	movs	r2, #110	; 0x6e
    297c:	210f      	movs	r1, #15
    297e:	0020      	movs	r0, r4
    2980:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 15, 132, (void *)"Now 13.6C , 735mm, 63%");
    2982:	4b3d      	ldr	r3, [pc, #244]	; (2a78 <main+0x200>)
    2984:	2284      	movs	r2, #132	; 0x84
    2986:	210f      	movs	r1, #15
    2988:	0020      	movs	r0, r4
    298a:	47a8      	blx	r5
	
	u8g2_SetFont(&lcd, u8g2_font_5x8_tf);
    298c:	493b      	ldr	r1, [pc, #236]	; (2a7c <main+0x204>)
    298e:	0020      	movs	r0, r4
    2990:	47b0      	blx	r6
	u8g2_DrawStr(&lcd, 260, 142, (void *)"RF-79dB");
    2992:	2682      	movs	r6, #130	; 0x82
    2994:	0076      	lsls	r6, r6, #1
    2996:	4b3a      	ldr	r3, [pc, #232]	; (2a80 <main+0x208>)
    2998:	228e      	movs	r2, #142	; 0x8e
    299a:	0031      	movs	r1, r6
    299c:	0020      	movs	r0, r4
    299e:	47a8      	blx	r5
	u8g2_DrawStr(&lcd, 260, 150, (void *)"B 3.94V");
    29a0:	4b38      	ldr	r3, [pc, #224]	; (2a84 <main+0x20c>)
    29a2:	2296      	movs	r2, #150	; 0x96
    29a4:	0031      	movs	r1, r6
    29a6:	0020      	movs	r0, r4
    29a8:	47a8      	blx	r5

	//u8g2_DrawRFrame(&lcd, 50 , 120, 20, 20, 3);
	//u8g2_DrawCircle(&lcd, 200, 120, 25, U8G2_DRAW_ALL);
	
	u8g2_SendBuffer(&lcd);
    29aa:	0020      	movs	r0, r4
    29ac:	4b36      	ldr	r3, [pc, #216]	; (2a88 <main+0x210>)
    29ae:	4798      	blx	r3
	delay_ms(50);
    29b0:	2032      	movs	r0, #50	; 0x32
    29b2:	4b36      	ldr	r3, [pc, #216]	; (2a8c <main+0x214>)
    29b4:	4798      	blx	r3
	
	
	while(!gpio_get_pin_level(EP_BUSY)){
    29b6:	e007      	b.n	29c8 <main+0x150>
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    29b8:	2280      	movs	r2, #128	; 0x80
    29ba:	02d2      	lsls	r2, r2, #11
    29bc:	23c0      	movs	r3, #192	; 0xc0
    29be:	05db      	lsls	r3, r3, #23
    29c0:	61da      	str	r2, [r3, #28]
		gpio_toggle_pin_level(GLD);
		delay_ms(50);
    29c2:	2032      	movs	r0, #50	; 0x32
    29c4:	4b31      	ldr	r3, [pc, #196]	; (2a8c <main+0x214>)
    29c6:	4798      	blx	r3
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
    29c8:	a803      	add	r0, sp, #12
    29ca:	4b31      	ldr	r3, [pc, #196]	; (2a90 <main+0x218>)
    29cc:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    29ce:	23c0      	movs	r3, #192	; 0xc0
    29d0:	05db      	lsls	r3, r3, #23
    29d2:	681c      	ldr	r4, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    29d4:	4a2f      	ldr	r2, [pc, #188]	; (2a94 <main+0x21c>)
    29d6:	6a12      	ldr	r2, [r2, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    29d8:	691b      	ldr	r3, [r3, #16]

	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT_IOBUS, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    29da:	4053      	eors	r3, r2
    29dc:	401c      	ands	r4, r3
    29de:	4054      	eors	r4, r2

	CRITICAL_SECTION_LEAVE();
    29e0:	a803      	add	r0, sp, #12
    29e2:	4b2d      	ldr	r3, [pc, #180]	; (2a98 <main+0x220>)
    29e4:	4798      	blx	r3
	while(!gpio_get_pin_level(EP_BUSY)){
    29e6:	03a3      	lsls	r3, r4, #14
    29e8:	d5e6      	bpl.n	29b8 <main+0x140>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    29ea:	23c0      	movs	r3, #192	; 0xc0
    29ec:	05db      	lsls	r3, r3, #23
    29ee:	2280      	movs	r2, #128	; 0x80
    29f0:	0112      	lsls	r2, r2, #4
    29f2:	615a      	str	r2, [r3, #20]
    29f4:	2280      	movs	r2, #128	; 0x80
    29f6:	0512      	lsls	r2, r2, #20
    29f8:	615a      	str	r2, [r3, #20]
    29fa:	2280      	movs	r2, #128	; 0x80
    29fc:	02d2      	lsls	r2, r2, #11
    29fe:	615a      	str	r2, [r3, #20]
    2a00:	e002      	b.n	2a08 <main+0x190>
		if(RTC_IRQ_Ready()){
			rtc_sync(&sys_rtc);
		}
		
		//gpio_toggle_pin_level(GLD);
		delay_ms(50);
    2a02:	2032      	movs	r0, #50	; 0x32
    2a04:	4b21      	ldr	r3, [pc, #132]	; (2a8c <main+0x214>)
    2a06:	4798      	blx	r3
		if(RTC_IRQ_Ready()){
    2a08:	4b24      	ldr	r3, [pc, #144]	; (2a9c <main+0x224>)
    2a0a:	4798      	blx	r3
    2a0c:	2800      	cmp	r0, #0
    2a0e:	d0f8      	beq.n	2a02 <main+0x18a>
			rtc_sync(&sys_rtc);
    2a10:	4802      	ldr	r0, [pc, #8]	; (2a1c <main+0x1a4>)
    2a12:	4b23      	ldr	r3, [pc, #140]	; (2aa0 <main+0x228>)
    2a14:	4798      	blx	r3
    2a16:	e7f4      	b.n	2a02 <main+0x18a>
    2a18:	00001595 	.word	0x00001595
    2a1c:	2000000c 	.word	0x2000000c
    2a20:	0000281d 	.word	0x0000281d
    2a24:	00002749 	.word	0x00002749
    2a28:	00001645 	.word	0x00001645
    2a2c:	2000172c 	.word	0x2000172c
    2a30:	00003f30 	.word	0x00003f30
    2a34:	00001771 	.word	0x00001771
    2a38:	000024e5 	.word	0x000024e5
    2a3c:	00001731 	.word	0x00001731
    2a40:	00001fdd 	.word	0x00001fdd
    2a44:	00003cdc 	.word	0x00003cdc
    2a48:	00001df9 	.word	0x00001df9
    2a4c:	00001c8d 	.word	0x00001c8d
    2a50:	000034b4 	.word	0x000034b4
    2a54:	00003fcc 	.word	0x00003fcc
    2a58:	00001d79 	.word	0x00001d79
    2a5c:	00003fd4 	.word	0x00003fd4
    2a60:	00003fdc 	.word	0x00003fdc
    2a64:	00003fe4 	.word	0x00003fe4
    2a68:	00003fec 	.word	0x00003fec
    2a6c:	00003ff4 	.word	0x00003ff4
    2a70:	00003ffc 	.word	0x00003ffc
    2a74:	00004004 	.word	0x00004004
    2a78:	00004018 	.word	0x00004018
    2a7c:	00002e00 	.word	0x00002e00
    2a80:	00004030 	.word	0x00004030
    2a84:	00004038 	.word	0x00004038
    2a88:	0000174d 	.word	0x0000174d
    2a8c:	000001c1 	.word	0x000001c1
    2a90:	00000191 	.word	0x00000191
    2a94:	41004400 	.word	0x41004400
    2a98:	0000019f 	.word	0x0000019f
    2a9c:	000011b1 	.word	0x000011b1
    2aa0:	000027a5 	.word	0x000027a5

00002aa4 <__udivsi3>:
    2aa4:	2200      	movs	r2, #0
    2aa6:	0843      	lsrs	r3, r0, #1
    2aa8:	428b      	cmp	r3, r1
    2aaa:	d374      	bcc.n	2b96 <__udivsi3+0xf2>
    2aac:	0903      	lsrs	r3, r0, #4
    2aae:	428b      	cmp	r3, r1
    2ab0:	d35f      	bcc.n	2b72 <__udivsi3+0xce>
    2ab2:	0a03      	lsrs	r3, r0, #8
    2ab4:	428b      	cmp	r3, r1
    2ab6:	d344      	bcc.n	2b42 <__udivsi3+0x9e>
    2ab8:	0b03      	lsrs	r3, r0, #12
    2aba:	428b      	cmp	r3, r1
    2abc:	d328      	bcc.n	2b10 <__udivsi3+0x6c>
    2abe:	0c03      	lsrs	r3, r0, #16
    2ac0:	428b      	cmp	r3, r1
    2ac2:	d30d      	bcc.n	2ae0 <__udivsi3+0x3c>
    2ac4:	22ff      	movs	r2, #255	; 0xff
    2ac6:	0209      	lsls	r1, r1, #8
    2ac8:	ba12      	rev	r2, r2
    2aca:	0c03      	lsrs	r3, r0, #16
    2acc:	428b      	cmp	r3, r1
    2ace:	d302      	bcc.n	2ad6 <__udivsi3+0x32>
    2ad0:	1212      	asrs	r2, r2, #8
    2ad2:	0209      	lsls	r1, r1, #8
    2ad4:	d065      	beq.n	2ba2 <__udivsi3+0xfe>
    2ad6:	0b03      	lsrs	r3, r0, #12
    2ad8:	428b      	cmp	r3, r1
    2ada:	d319      	bcc.n	2b10 <__udivsi3+0x6c>
    2adc:	e000      	b.n	2ae0 <__udivsi3+0x3c>
    2ade:	0a09      	lsrs	r1, r1, #8
    2ae0:	0bc3      	lsrs	r3, r0, #15
    2ae2:	428b      	cmp	r3, r1
    2ae4:	d301      	bcc.n	2aea <__udivsi3+0x46>
    2ae6:	03cb      	lsls	r3, r1, #15
    2ae8:	1ac0      	subs	r0, r0, r3
    2aea:	4152      	adcs	r2, r2
    2aec:	0b83      	lsrs	r3, r0, #14
    2aee:	428b      	cmp	r3, r1
    2af0:	d301      	bcc.n	2af6 <__udivsi3+0x52>
    2af2:	038b      	lsls	r3, r1, #14
    2af4:	1ac0      	subs	r0, r0, r3
    2af6:	4152      	adcs	r2, r2
    2af8:	0b43      	lsrs	r3, r0, #13
    2afa:	428b      	cmp	r3, r1
    2afc:	d301      	bcc.n	2b02 <__udivsi3+0x5e>
    2afe:	034b      	lsls	r3, r1, #13
    2b00:	1ac0      	subs	r0, r0, r3
    2b02:	4152      	adcs	r2, r2
    2b04:	0b03      	lsrs	r3, r0, #12
    2b06:	428b      	cmp	r3, r1
    2b08:	d301      	bcc.n	2b0e <__udivsi3+0x6a>
    2b0a:	030b      	lsls	r3, r1, #12
    2b0c:	1ac0      	subs	r0, r0, r3
    2b0e:	4152      	adcs	r2, r2
    2b10:	0ac3      	lsrs	r3, r0, #11
    2b12:	428b      	cmp	r3, r1
    2b14:	d301      	bcc.n	2b1a <__udivsi3+0x76>
    2b16:	02cb      	lsls	r3, r1, #11
    2b18:	1ac0      	subs	r0, r0, r3
    2b1a:	4152      	adcs	r2, r2
    2b1c:	0a83      	lsrs	r3, r0, #10
    2b1e:	428b      	cmp	r3, r1
    2b20:	d301      	bcc.n	2b26 <__udivsi3+0x82>
    2b22:	028b      	lsls	r3, r1, #10
    2b24:	1ac0      	subs	r0, r0, r3
    2b26:	4152      	adcs	r2, r2
    2b28:	0a43      	lsrs	r3, r0, #9
    2b2a:	428b      	cmp	r3, r1
    2b2c:	d301      	bcc.n	2b32 <__udivsi3+0x8e>
    2b2e:	024b      	lsls	r3, r1, #9
    2b30:	1ac0      	subs	r0, r0, r3
    2b32:	4152      	adcs	r2, r2
    2b34:	0a03      	lsrs	r3, r0, #8
    2b36:	428b      	cmp	r3, r1
    2b38:	d301      	bcc.n	2b3e <__udivsi3+0x9a>
    2b3a:	020b      	lsls	r3, r1, #8
    2b3c:	1ac0      	subs	r0, r0, r3
    2b3e:	4152      	adcs	r2, r2
    2b40:	d2cd      	bcs.n	2ade <__udivsi3+0x3a>
    2b42:	09c3      	lsrs	r3, r0, #7
    2b44:	428b      	cmp	r3, r1
    2b46:	d301      	bcc.n	2b4c <__udivsi3+0xa8>
    2b48:	01cb      	lsls	r3, r1, #7
    2b4a:	1ac0      	subs	r0, r0, r3
    2b4c:	4152      	adcs	r2, r2
    2b4e:	0983      	lsrs	r3, r0, #6
    2b50:	428b      	cmp	r3, r1
    2b52:	d301      	bcc.n	2b58 <__udivsi3+0xb4>
    2b54:	018b      	lsls	r3, r1, #6
    2b56:	1ac0      	subs	r0, r0, r3
    2b58:	4152      	adcs	r2, r2
    2b5a:	0943      	lsrs	r3, r0, #5
    2b5c:	428b      	cmp	r3, r1
    2b5e:	d301      	bcc.n	2b64 <__udivsi3+0xc0>
    2b60:	014b      	lsls	r3, r1, #5
    2b62:	1ac0      	subs	r0, r0, r3
    2b64:	4152      	adcs	r2, r2
    2b66:	0903      	lsrs	r3, r0, #4
    2b68:	428b      	cmp	r3, r1
    2b6a:	d301      	bcc.n	2b70 <__udivsi3+0xcc>
    2b6c:	010b      	lsls	r3, r1, #4
    2b6e:	1ac0      	subs	r0, r0, r3
    2b70:	4152      	adcs	r2, r2
    2b72:	08c3      	lsrs	r3, r0, #3
    2b74:	428b      	cmp	r3, r1
    2b76:	d301      	bcc.n	2b7c <__udivsi3+0xd8>
    2b78:	00cb      	lsls	r3, r1, #3
    2b7a:	1ac0      	subs	r0, r0, r3
    2b7c:	4152      	adcs	r2, r2
    2b7e:	0883      	lsrs	r3, r0, #2
    2b80:	428b      	cmp	r3, r1
    2b82:	d301      	bcc.n	2b88 <__udivsi3+0xe4>
    2b84:	008b      	lsls	r3, r1, #2
    2b86:	1ac0      	subs	r0, r0, r3
    2b88:	4152      	adcs	r2, r2
    2b8a:	0843      	lsrs	r3, r0, #1
    2b8c:	428b      	cmp	r3, r1
    2b8e:	d301      	bcc.n	2b94 <__udivsi3+0xf0>
    2b90:	004b      	lsls	r3, r1, #1
    2b92:	1ac0      	subs	r0, r0, r3
    2b94:	4152      	adcs	r2, r2
    2b96:	1a41      	subs	r1, r0, r1
    2b98:	d200      	bcs.n	2b9c <__udivsi3+0xf8>
    2b9a:	4601      	mov	r1, r0
    2b9c:	4152      	adcs	r2, r2
    2b9e:	4610      	mov	r0, r2
    2ba0:	4770      	bx	lr
    2ba2:	e7ff      	b.n	2ba4 <__udivsi3+0x100>
    2ba4:	b501      	push	{r0, lr}
    2ba6:	2000      	movs	r0, #0
    2ba8:	f000 f806 	bl	2bb8 <__aeabi_idiv0>
    2bac:	bd02      	pop	{r1, pc}
    2bae:	46c0      	nop			; (mov r8, r8)

00002bb0 <__aeabi_uidivmod>:
    2bb0:	2900      	cmp	r1, #0
    2bb2:	d0f7      	beq.n	2ba4 <__udivsi3+0x100>
    2bb4:	e776      	b.n	2aa4 <__udivsi3>
    2bb6:	4770      	bx	lr

00002bb8 <__aeabi_idiv0>:
    2bb8:	4770      	bx	lr
    2bba:	46c0      	nop			; (mov r8, r8)

00002bbc <__ffssi2>:
    2bbc:	b510      	push	{r4, lr}
    2bbe:	2300      	movs	r3, #0
    2bc0:	2800      	cmp	r0, #0
    2bc2:	d002      	beq.n	2bca <__ffssi2+0xe>
    2bc4:	f000 f804 	bl	2bd0 <__ctzsi2>
    2bc8:	1c43      	adds	r3, r0, #1
    2bca:	0018      	movs	r0, r3
    2bcc:	bd10      	pop	{r4, pc}
    2bce:	46c0      	nop			; (mov r8, r8)

00002bd0 <__ctzsi2>:
    2bd0:	4241      	negs	r1, r0
    2bd2:	4008      	ands	r0, r1
    2bd4:	211c      	movs	r1, #28
    2bd6:	2301      	movs	r3, #1
    2bd8:	041b      	lsls	r3, r3, #16
    2bda:	4298      	cmp	r0, r3
    2bdc:	d301      	bcc.n	2be2 <__ctzsi2+0x12>
    2bde:	0c00      	lsrs	r0, r0, #16
    2be0:	3910      	subs	r1, #16
    2be2:	0a1b      	lsrs	r3, r3, #8
    2be4:	4298      	cmp	r0, r3
    2be6:	d301      	bcc.n	2bec <__ctzsi2+0x1c>
    2be8:	0a00      	lsrs	r0, r0, #8
    2bea:	3908      	subs	r1, #8
    2bec:	091b      	lsrs	r3, r3, #4
    2bee:	4298      	cmp	r0, r3
    2bf0:	d301      	bcc.n	2bf6 <__ctzsi2+0x26>
    2bf2:	0900      	lsrs	r0, r0, #4
    2bf4:	3904      	subs	r1, #4
    2bf6:	a202      	add	r2, pc, #8	; (adr r2, 2c00 <__ctzsi2+0x30>)
    2bf8:	5c10      	ldrb	r0, [r2, r0]
    2bfa:	1a40      	subs	r0, r0, r1
    2bfc:	4770      	bx	lr
    2bfe:	46c0      	nop			; (mov r8, r8)
    2c00:	1d1d1c1b 	.word	0x1d1d1c1b
    2c04:	1e1e1e1e 	.word	0x1e1e1e1e
    2c08:	1f1f1f1f 	.word	0x1f1f1f1f
    2c0c:	1f1f1f1f 	.word	0x1f1f1f1f

00002c10 <__libc_init_array>:
    2c10:	b570      	push	{r4, r5, r6, lr}
    2c12:	2600      	movs	r6, #0
    2c14:	4d0c      	ldr	r5, [pc, #48]	; (2c48 <__libc_init_array+0x38>)
    2c16:	4c0d      	ldr	r4, [pc, #52]	; (2c4c <__libc_init_array+0x3c>)
    2c18:	1b64      	subs	r4, r4, r5
    2c1a:	10a4      	asrs	r4, r4, #2
    2c1c:	42a6      	cmp	r6, r4
    2c1e:	d109      	bne.n	2c34 <__libc_init_array+0x24>
    2c20:	2600      	movs	r6, #0
    2c22:	f001 fa0d 	bl	4040 <_init>
    2c26:	4d0a      	ldr	r5, [pc, #40]	; (2c50 <__libc_init_array+0x40>)
    2c28:	4c0a      	ldr	r4, [pc, #40]	; (2c54 <__libc_init_array+0x44>)
    2c2a:	1b64      	subs	r4, r4, r5
    2c2c:	10a4      	asrs	r4, r4, #2
    2c2e:	42a6      	cmp	r6, r4
    2c30:	d105      	bne.n	2c3e <__libc_init_array+0x2e>
    2c32:	bd70      	pop	{r4, r5, r6, pc}
    2c34:	00b3      	lsls	r3, r6, #2
    2c36:	58eb      	ldr	r3, [r5, r3]
    2c38:	4798      	blx	r3
    2c3a:	3601      	adds	r6, #1
    2c3c:	e7ee      	b.n	2c1c <__libc_init_array+0xc>
    2c3e:	00b3      	lsls	r3, r6, #2
    2c40:	58eb      	ldr	r3, [r5, r3]
    2c42:	4798      	blx	r3
    2c44:	3601      	adds	r6, #1
    2c46:	e7f2      	b.n	2c2e <__libc_init_array+0x1e>
    2c48:	0000404c 	.word	0x0000404c
    2c4c:	0000404c 	.word	0x0000404c
    2c50:	0000404c 	.word	0x0000404c
    2c54:	00004050 	.word	0x00004050

00002c58 <memset>:
    2c58:	0003      	movs	r3, r0
    2c5a:	1882      	adds	r2, r0, r2
    2c5c:	4293      	cmp	r3, r2
    2c5e:	d100      	bne.n	2c62 <memset+0xa>
    2c60:	4770      	bx	lr
    2c62:	7019      	strb	r1, [r3, #0]
    2c64:	3301      	adds	r3, #1
    2c66:	e7f9      	b.n	2c5c <memset+0x4>
    2c68:	682f2e2e 	.word	0x682f2e2e
    2c6c:	732f6c61 	.word	0x732f6c61
    2c70:	682f6372 	.word	0x682f6372
    2c74:	695f6c61 	.word	0x695f6c61
    2c78:	6d5f6332 	.word	0x6d5f6332
    2c7c:	6e79735f 	.word	0x6e79735f
    2c80:	00632e63 	.word	0x00632e63
    2c84:	682f2e2e 	.word	0x682f2e2e
    2c88:	732f6c61 	.word	0x732f6c61
    2c8c:	682f6372 	.word	0x682f6372
    2c90:	695f6c61 	.word	0x695f6c61
    2c94:	00632e6f 	.word	0x00632e6f
    2c98:	682f2e2e 	.word	0x682f2e2e
    2c9c:	732f6c61 	.word	0x732f6c61
    2ca0:	682f6372 	.word	0x682f6372
    2ca4:	735f6c61 	.word	0x735f6c61
    2ca8:	6d5f6970 	.word	0x6d5f6970
    2cac:	6e79735f 	.word	0x6e79735f
    2cb0:	00632e63 	.word	0x00632e63
    2cb4:	682f2e2e 	.word	0x682f2e2e
    2cb8:	652f6c70 	.word	0x652f6c70
    2cbc:	682f6369 	.word	0x682f6369
    2cc0:	655f6c70 	.word	0x655f6c70
    2cc4:	632e6369 	.word	0x632e6369
    2cc8:	00000000 	.word	0x00000000

00002ccc <_map>:
    2ccc:	00000007 00000007 0000000d 00000019     ................
    2cdc:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    2cec:	65735f6c 6d6f6372 0000632e              l_sercom.c..

00002cf8 <_i2cms>:
    2cf8:	00000003 00200014 00000100 000000ea     ...... .........
    2d08:	000000d7 02dc6c00                       .....l..

00002d10 <sercomspi_regs>:
    2d10:	0020000c 00020000 00000000 000000ef     .. .............
    2d20:	00001680 00001656 00001656 00001674     ....V...V...t...
    2d30:	00001698 000016a2 00001656 00001656     ........V...V...
    2d40:	00001656 00001656 00001656 00001656     V...V...V...V...
    2d50:	0000168a 00001656 00001656 00001656     ....V...V...V...
    2d60:	00001656 00001656 00001656 00001656     V...V...V...V...
    2d70:	000016b2 0000166a 00001656 00001656     ....j...V...V...
    2d80:	00001656 00001656 00001656 00001656     V...V...V...V...
    2d90:	00001656 00001656 00001656 00001656     V...V...V...V...
    2da0:	00001656 00001656 00001656 00001656     V...V...V...V...
    2db0:	00001656 00001656 00001656 00001656     V...V...V...V...
    2dc0:	00001656 00001656 00001656 00001656     V...V...V...V...
    2dd0:	00001656 00001656 00001656 00001656     V...V...V...V...
    2de0:	00001656 00001656 00001656 00001656     V...V...V...V...
    2df0:	00001656 00001656 00001656 0000165a     V...V...V...Z...

00002e00 <u8g2_font_5x8_tf>:
    2e00:	020200bf 04030403 00080504 06ff06ff     ................
    2e10:	021a0100 20960631 037e0005 63310721     ....1.. ..~.!.1c
    2e20:	22005233 936e9b07 0d2300ac a657623d     3R."..n...#.=bW.
    2e30:	54355434 24001299 9b623d0a da53bd57     4T5T...$.=b.W.S.
    2e40:	ab082511 67531366 3c0a2600 b3531762     .%..f.Sg.&.<b.S.
    2e50:	2700a66a 336f1905 62b20728 29019aa7     j..'..o3(..b...)
    2e60:	1362b208 2a00a553 13622c0a c5491a93     ..b.S..*.,b...I.
    2e70:	2d0a2b00 1c519b62 2c08a332 a75e9b07     .+.-b.Q.2..,..^.
    2e80:	062d004a 02336a0c 5e9b072e 2f025697     J.-..j3....^.V./
    2e90:	5f623408 300033b6 5762b308 31002ab9     .4b_.3.0..bW.*.1
    2ea0:	9762b307 0a326b64 62a76234 008f2a4e     ..b.dk2.4b.bN*..
    2eb0:	62340a33 48d46233 0a340526 551b6234     3.4b3b.H&.4.4b.U
    2ec0:	004e6235 62340a35 3246f433 0a360029     5bN.5.4b3.F2).6.
    2ed0:	f2a76234 0029328a 62340a37 31cc7233     4b...2).7.4b3r.1
    2ee0:	0a380047 62a76234 05265152 62340a39     G.8.4b.bRQ&.9.4b
    2ef0:	3b4ca2a7 073a0029 e23362aa b3083b08     ..L;).:..b3..;..
    2f00:	5523675e b3073c02 5cca9b62 661c083d     ^g#U.<..b..\=..f
    2f10:	011a3233 62b3083e 0254cb93 62b3093f     32..>..b..T.?..b
    2f20:	26194cd7 450c4000 5ca32b5e 43592549     .L.&.@.E^+.\I%YC
    2f30:	34094105 1ca2a762 0a420653 e2b36234     .A.4b...S.B.4b..
    2f40:	048e5148 62340943 932ea2a7 34094402     HQ..C.4b.....D.4
    2f50:	73a2b362 09450024 f4336234 460479ca     b..s$.E.4b3..y.F
    2f60:	33623409 0035caf4 62340a47 334ea2a7     .4b3..5.G.4b..N3
    2f70:	09480029 e5136234 49006698 b362b307     ).H.4b...f.I..b.
    2f80:	094a6b62 73376234 4b004655 13623409     bkJ.4b7sUF.K.4b.
    2f90:	33a99255 6234084c 0047bb93 6234094d     U..3L.4b..G.M.4b
    2fa0:	cd11c713 34094e00 58d71362 094f0067     .....N.4b..Xg.O.
    2fb0:	a2a76234 50002933 b362340a 67291ca2     4b..3).P.4b...)g
    2fc0:	3c095100 5ca2a75e 0a52146e a2b36234     .Q.<^..\n.R.4b..
    2fd0:	00ca291c 62340a53 a8ca62a7 08540a4c     .)..S.4b.b..L.T.
    2fe0:	62b362b3 08550017 3d136234 09560293     .b.b..U.4b.=..V.
    2ff0:	9d136234 57002a49 13623409 00c471cd     4b..I*.W.4b..q..
    3000:	62340a58 2a926513 0b5900ca 75936235     X.4b.e.*..Y.5b.u
    3010:	28ca33aa 34095a02 6c723362 075b008f     .3.(.Z.4b3rl..[.
    3020:	623362b3 340a5c73 ca339362 5d1ca328     .b3bs\.4b.3.(..]
    3030:	3362b307 065e239b 00d77293 5e0c065f     ..b3.#^..r.._..^
    3040:	06600233 03137292 62240861 034ca237     3.`..r..a.$b7.L.
    3050:	62340a62 728af393 07630024 b33762a3     b.4b...r$.c..b7.
    3060:	34096400 288d5f62 086500d3 d2a76224     .d.4b_.(..e.$b..
    3070:	09660ac8 955b6234 67004733 a75e2c09     ..f.4b[.3G.g.,^.
    3080:	0149da62 62340968 668af393 b3086900     b.I.h.4b...f.i..
    3090:	ac919762 bb096a06 a9619b5e 096b002a     b....j..^.a.*.k.
    30a0:	cb936234 6c0ca291 2362b307 096d06bb     4b.....l..b#..m.
    30b0:	5aa36225 6e02a92a b3622407 086f19a2     %b.Z*..n.$b...o.
    30c0:	a2a76224 09700a4c e2b35e2c 71033948     $b..L.p.,^..H9.q
    30d0:	375e2c08 7205da62 93622408 73019d92     .,^7b..r.$b....s
    30e0:	3762a307 0a7402f2 e3976234 002629cc     ..b7..t.4b...)&.
    30f0:	62240775 7634cd13 9362a307 09770aac     u.$b..4v..b...w.
    3100:	55936225 78005d52 13622408 79315493     %b.UR].x.$b..T1y
    3110:	135e2c0a 29311a65 24087a00 39623362     .,^.e.1).z.$b3b9
    3120:	3c0b7b02 4a32ab62 048cc51a 6331057c     .{.<b.2J....|.1c
    3130:	3c0c7d73 cc51a362 24946548 14077e00     s}.<b.Q.He.$.~..
    3140:	02549772 7e0005a0 3107a103 00469363     r.T....~...1c.F.
    3150:	5e3409a2 ce6a471b 340aa304 988d5b62     ..4^.Gj....4b[..
    3160:	a4004a93 93622d0a e5714cd3 350ba500     .J...-b..Lq....5
    3170:	35539362 02321c64 633906a6 0aa706b3     b.S5d.2...9c....
    3180:	f237623c 048f698a 768b06a8 0aa90293     <b7..i.....v....
    3190:	aab76235 00b55539 6aab07aa ab1e92b7     5b..9U.....j....
    31a0:	97661c08 ac014c54 33629b06 8b05ad0b     ..f.TL....b3....
    31b0:	09ae336a a1f76235 af005a96 33768b05     j3..5b...Z....v3
    31c0:	6e9b06b0 08b105d7 569762ab 07b20346     ...n.....b.VF...
    31d0:	4cd76aab ab07b369 002fa36a 729206b4     .j.Li...j./....r
    31e0:	09b500a7 cd135e2c b6003291 3762350c     ....,^...2...5b7
    31f0:	a9291a46 b70a6298 136b0905 5e9206b8     F.)..b....k....^
    3200:	07b900a7 64976aab ab07ba35 068dd76a     .....j.d5...j...
    3210:	661c08bb 09526293 623c0abc 8d515b93     ...f.bR...<b.[Q.
    3220:	0abd0098 ab93623c 038c72a4 623c0cbe     ....<b...r....<b
    3230:	48cc5193 00262355 62b309bf a98a6197     .Q.HU#&....b.a..
    3240:	3c0ac002 54519762 c1194c71 5b623c09     ...<b.QTqL...<b[
    3250:	0ca638ab 623c0ac2 715262a7 0ac3194c     .8....<b.bRqL...
    3260:	5497623c 194c7154 623c0ac4 71543313     <b.TTqL...<b.3Tq
    3270:	0ac5194c 62a7623c 194c7152 623409c6     L...<b.bRqL...4b
    3280:	a86b5237 3c0ac74a 2ea2a75e c8008c93     7Rk.J..<^.......
    3290:	97623c0a e57a1a51 3c09c911 bd0e5b62     .<b.Q.z....<b[..
    32a0:	0aca08f2 e2a7623c 008f2bd8 623c0acb     ....<b...+....<b
    32b0:	7a1a3313 09cc11e5 d39362bb cd00d58a     .3.z.....b......
    32c0:	9b62bb09 00d58ad2 62bb09ce ab148d57     ..b........bW...
    32d0:	bb09cf01 8af29362 0bd000d5 e3376235     ....b.......5b7.
    32e0:	698a6548 3c0ad101 b9549762 d20194d4     He.i...<b.T.....
    32f0:	97623c0a 4cd15451 3c09d30a 68ab5b62     .<b.QT.L...<b[.h
    3300:	0ad40526 62a7623c 0a4cd152 623c0ad5     &...<b.bR.L...<b
    3310:	d1545497 0ad60a4c 3313623c 0a4cd154     .TT.L...<b.3T.L.
    3320:	629b06d7 09d83a93 d2376234 d9048e91     ...b.:..4b7.....
    3330:	97623c09 0a4ce951 623c08da 052674db     .<b.Q.L...<b.t&.
    3340:	623c09db 5267a2a7 3c0adc00 8a331362     ..<b..gR...<b.3.
    3350:	dd00a4ce 5f623d0b 946754e6 0ade0451     .....=b_.Tg.Q...
    3360:	57936234 00652394 623409df 54eaa2a7     4b.W.#e...4b...T
    3370:	3c0ae009 c6519762 e134ca23 5b623c09     ...<b.Q.#.4..<b[
    3380:	34ca2353 623c0ae2 a238655b 0ae3034c     S#.4..<b[e8.L...
    3390:	5497623c 34ca23c6 623409e4 6511c357     <b.T.#.4..4bW..e
    33a0:	3c0ae51a 9262a762 e634ca23 33622509     ...<b.b.#.4..%b3
    33b0:	004732a2 5eab08e7 004ab337 623c0be8     .2G....^7.J...<b
    33c0:	2ac65197 e900ac8d 5b623c0a ac8d2a53     .Q.*.....<b[S*..
    33d0:	3c0bea00 8662a762 00ac8d2a 62340aeb     ...<b.b.*.....4b
    33e0:	46954357 09ec0056 339362bb ed00d592     WC.FV....b.3....
    33f0:	9b62bb09 00d59232 62bb08ee 00d596d7     ..b.2......b....
    3400:	62b308ef 06acb293 623c0cf0 51956293     ...b......<b.b.Q
    3410:	0029311a 623c0af1 2b865497 0bf2019a     .1)...<b.T.+....
    3420:	5197623c a4ca2ac6 3c0af300 2a535b62     <b.Q.*.....<b[S*
    3430:	f400a4ca a7623c0b ca2a8662 0bf500a4     .....<b.b.*.....
    3440:	5497623c a4ca2ac6 340af600 54331362     <b.T.*.....4b.3T
    3450:	f7052651 9762ab08 f80946d1 37622409     Q&....b..F...$b7
    3460:	012348d2 623c0af9 d1865197 09fa034c     .H#...<b.Q..L...
    3470:	e35b623c fb01a668 a7623c0a 4cd14662     <b[.h....<b.bF.L
    3480:	3409fc03 8a331362 0bfd1a66 e35b5e44     ...4b.3.f...D^[.
    3490:	4988d328 3c0afe01 8af3935e ff0ce523     (..I...<^...#...
    34a0:	135e3c0c 8d328a33 00001498 ff040000     .<^.3.2.........
    34b0:	000000ff                                ....

000034b4 <u8g2_font_ncenB14_tr>:
    34b4:	0303005f 05040505 fd141606 0efc0efc     _...............
    34c4:	056d02fe 200b08ba 2c600006 c40f2101     ..m.... ..`,.!..
    34d4:	39233425 65222c1c 012221c9 64a50922     %4#9.,"e.!"."..d
    34e4:	45e12146 8b1b2300 11296461 d912c44b     F!.E.#..ad).K...
    34f4:	49987261 61d912c4 c4499872 0844b112     ar.I...ar.I...D.
    3504:	a6492124 8487195b 2948926b 82550a52     $!I.[...k.H)R.U.
    3514:	10e843b6 a14a4633 9112a84a 2090e395     .C..3FJ.J...... 
    3524:	ee292500 93357be1 5941268a 450b2848     .%)..{5..&AYH(.E
    3534:	28a91165 c687247d 345122c6 648a0b24     e..(}$..."Q4$..d
    3544:	a62c98c1 e34e8c14 24260030 4b8c25d0     ..,...N.0.&$.%.K
    3554:	20e48a07 93241c99 58722683 d9ab3a1d     ... ..$..&rX.:..
    3564:	70521384 a7521d56 7421dab4 0727011b     ..RpV.R...!t..'.
    3574:	712e64a2 05112818 122733a2 9923448d     .d.q.(...3'..D#.
    3584:	99b266de 10290050 2133a205 3364cd94     .f..P.)...3!..d3
    3594:	46891a7d 102a006a 3545e0e7 44449a4a     }..Fj.*...E5J.DD
    35a4:	94644923 152b0234 295c214a 7221c887     #Id.4.+.J!\)..!r
    35b4:	3070f088 887221ca 2c04221c 2b60e40b     ..p0.!r..".,..`+
    35c4:	46443923 072d00d9 f134e065 840a2e10     #9DF..-.e.4.....
    35d4:	39232c20 2f002444 3c21c60f 0c5418a9      ,#9D$./..!<..T.
    35e4:	8315062a 1330008a 375c25c9 92648c9c     *.....0..%\7..d.
    35f4:	c89b7f99 0ce19344 c70b3100 1c275c29     ....D....1..)\'.
    3604:	0e9ff715 25c91532 4d13475c 6c89b666     ....2..%\G.Mf..l
    3614:	a74f1d3c a1c3d562 c9173300 13475c25     <.O.b....3..%\G.
    3624:	89b6664d 839c2c6c db9913e4 012b3444     Mf..l,......D4+.
    3634:	25c91634 4f171f5c d0b32319 4d8a3628     4..%\..O.#..(6.M
    3644:	74839382 18352d3c 735c25c9 90e29c88     ...t<-5..%\s....
    3654:	b10e2438 89e3e6c5 9a226dcc 16360095     8$.......m"...6.
    3664:	575c25c9 24d9915a b288c9e3 9b226de6     .%\WZ..$.....m".
    3674:	0033848c 25c91137 9e50f15c b962e58a     ..3.7..%\.P...b.
    3684:	11bc7578 c9153800 94375c25 e2d4a449     xu...8..%\7.I...
    3694:	85346445 4d6a558e 17390346 375c25c9     Ed4..UjMF.9..%\7
    36a4:	92664d14 84c9b799 644f1934 5468c936     .Mf.....4.Od6.hT
    36b4:	240d3a03 39233425 4392c444 0f3b0244     .:.$%4#9D..CD.;.
    36c4:	23336584 92c44439 0d946443 4a113c00     .e3#9D..Cd...<.J
    36d4:	110f5c21 21d33913 421d0874 0b3d0887     !\...9.!t..B..=.
    36e4:	f15ca4c9 1c3c4740 4a123e08 87215c21     ..\.@G<..>.J!\!.
    36f4:	087421d0 7226421d 3f004396 5421c912     .!t..B&r.C.?..!T
    3704:	6cdd1257 7758d913 2c953124 cf274004     W..l..Xw$1.,.@'.
    3714:	1e7b8421 90a0e4cb 291124ac 92226491     !.{......$.).d".
    3724:	8991444c 89226a24 9a2444d2 d8a0e510     LD..$j"..D$.....
    3734:	02087c58 1dce2041 cb071f74 1d207381     X|..A ..t....s .
    3744:	42839914 1e6c4872 07a7471b 1f187861     ...BrHl..G..ax..
    3754:	02d427c9 21cc1e42 cd987174 70d1c348     .'..B..!tq..H..p
    3764:	66cd1c34 74d2e087 274c9d32 7270c9d3     4..f...t2.L'..pr
    3774:	1d430190 597421cc 258cb10a 0e843ae3     ..C..!tY...%.:..
    3784:	a0e683a1 890e6839 18e323cc 44035a4d     ....9h...#..MZ.D
    3794:	8421ce1f 690e9871 3478d1e3 f327cc9f     ..!.q..i..x4..'.
    37a4:	9f327cc9 d1e327cc 1d243478 1f450086     .|2..'..x4$...E.
    37b4:	716c21cb 53270ca0 99142cc9 e1232285     .!lq..'S.,..."#.
    37c4:	059c2471 38c8a167 0f0c9532 cb1e4607     q$..g..82....F..
    37d4:	a0716c21 c953270c 8599142c 71e12322     !lq..'S.,..."#.q
    37e4:	67059c24 0e6439c1 47015b99 7c21cd21     $..g.9d..[.G!.!|
    37f4:	48918a59 3258d163 90e64487 87361cc8     Y..Hc.X2.D....6.
    3804:	d1e10f4d 919d3474 0008a5a8 21ce1e48     M...t4......H..!
    3814:	8cac5184 78d1e347 478d1e34 3478d287     .Q..G..x4..G..x4
    3824:	e3478d1e 9e3478d1 0a490b14 514c25c5     ..G..x4...I..%LQ
    3834:	297fed19 1dca134a ef9e5b64 9a426c93     ...)J...d[...lB.
    3844:	91c22690 4b044868 8421ce1e 854d2b51     .&..hH.K..!.Q+M.
    3854:	3c4ce943 10e44f92 213ee43b e233a88f     C.L<.O..;.>!..3.
    3864:	d4a53690 ca104c0c 9e516421 6991afef     .6...L..!dQ....i
    3874:	1d992864 d12d4d0c 2e619c21 5a556991     d(...M-.!.a..iUZ
    3884:	85991864 68599166 46859916 126c59a1     d...f.Yh...F.Yl.
    3894:	a126c59a 0b368c59 d9c166ce d49c1868     ..&.Y.6..f..h...
    38a4:	214e0562 418421ce d46750ad 4c583520     b.N!.!.A.Pg. 5XL
    38b4:	a44305a1 0c128c60 28c4a316 8b1b3c31     ..C.`......(1<..
    38c4:	4f0021ca 8421ce1d c6d12669 0e64f1a3     .!.O..!.i&....d.
    38d4:	10ec43b1 b10ec43b e3479643 046c8919     .C..;...C.G...l.
    38e4:	21cc1e50 ce107174 90ca4348 290ca432     P..!tq..HC..2..)
    38f4:	3821d233 7341cd07 87341cd0 285101d4     3.!8..As..4...Q(
    3904:	6983224e a3c6d126 b10e64f1 3b10ec43     N".i&....d..C..;
    3914:	d0b10ec4 6891a326 ca519926 3a1ca876     ....&..h&.Q.v..:
    3924:	b0ea8389 1f520011 718421cd d3490da0     ......R..!.q..I.
    3934:	1d3474d1 e887670d ce1b386c 70d9c368     .t4..g..l8..h..p
    3944:	27189c36 ca165300 09476421 d3250cad     6..'.S..!dG...%.
    3954:	357ad908 d3d5cb5b 54025424 6c21cb1c     ..z5[...$T.T..!l
    3964:	cdad3071 2cd93364 21cc8738 321cc873     q0..d3.,8..!s..2
    3974:	7321cc87 5506bcc8 8421ce1e 478cac51     ..!s...U..!.Q..G
    3984:	363cd8f3 f363cd8f 8f363cd8 d8f363cd     ..<6..c..<6..c..
    3994:	1b94383c cf225601 ac61741d 20f36790     <8...V"..ta..g. 
    39a4:	4f0d3c35 6438b3e3 e24d0716 381c49b0     5<.O..8d..M..I.8
    39b4:	71c1ce87 57001c78 9c1dd430 68553161     ...qx..W0...a1Uh
    39c4:	1a70d9c4 33c2d1a4 0b46785a 38942253     ..p....3ZxF.S".8
    39d4:	c49a1264 24d09321 61d1a10e 386c39c3     d...!..$...a.9l8
    39e4:	d0e38607 58001870 8c21cf1f a711aa63     ....p..X..!.c...
    39f4:	0e48f934 50e8c3b1 b30eac3a e1644443     4.H....P:...CDd.
    3a04:	531b4874 1f59068a 617c21cd d36550a3     tH.S..Y..!|a.Pe.
    3a14:	0b3a4d20 3a90e253 c39b0e68 6c39b0e6      M:.S..:h.....9l
    3a24:	6e439b0e cc195a00 10f16c21 94c24f2e     ..Cn.Z..!l...O..
    3a34:	990e9d28 11ace843 3e5c6472 0a5b021c     (...C...rd\>..[.
    3a44:	6133a604 0113ffd2 21c8125c 8b96214c     ..3a....\..!L!..
    3a54:	58b962e5 e58b962e 0a5d0162 4133a204     .b.X....b.]...3A
    3a64:	0193ffd2 a1080e5e 1296274d 422d2269     ....^...M'..i"-B
    3a74:	075f00a2 f14b6049 85086040 5b213ea4     .._.I`K.@`...>![
    3a84:	2a126114 9a735c21 da63844d 9b326d64     .a.*!\s.M.c.dm2.
    3a94:	6206988c 641dcc1f 41cd0741 341cd073     ...b...dA..As..4
    3aa4:	b4884d07 9d3274d1 c9d3274c 491b4274     .M...t2.L'..tB.I
    3ab4:	0f63006a 57542129 5bcb191a 09193323     j.c.)!TW...[#3..
    3ac4:	cc1d6400 074f6c21 d07341cd 8ca4341c     .d..!lO..As..4..
    3ad4:	64e99466 a64e993a 4668e993 126510a4     f..d:.N...hF..e.
    3ae4:	475c212a c6864d1c 8e3e41c3 0025650c     *!\G.M...A>..e%.
    3af4:	21c80e66 ec93473c f74db43a 1e6706b1     f..!<G..:.M...g.
    3b04:	0f5b21eb c6464392 13284cd1 a34346ca     .![..CF..L(..FC.
    3b14:	1e08741c 5889d222 00dd9432 21cc1e68     .t.."..X2...h..!
    3b24:	cd07416c 1cd07341 6a4d0734 3470d224     lA..As..4.Mj$.p4
    3b34:	c3470d1c 9c3470d1 0c690a94 333421c5     ..G..p4...i..!43
    3b44:	f692075a 0f6a014b b9331647 3fb88d1d     Z...K.j.G.3....?
    3b54:	12222c5a cc1d6b00 07416c21 d07341cd     Z,"..k..!lA..As.
    3b64:	8d07341c 28e1334a 275f113c 466d11c4     .4..J3.(<._'..mF
    3b74:	0a6c18a9 413421c5 00a5ffda 2133186d     ..l..!4A....m.3!
    3b84:	d8a941a4 70d22548 5c34b869 970d2e1a     .A..H%.pi.4\....
    3b94:	06a52b86 212c156e 91a9416c 70d1c348     .+..n.,!lA..H..p
    3ba4:	470d1c34 5270d1c3 2b0f6f2a 9c576421     4..G..pR*o.+!dW.
    3bb4:	4ebea64d 001ac366 1dac1c70 d2223163     M..Nf...p...c1".
    3bc4:	74c9d346 274c9d32 346d09d3 7341ce21     F..t2.L'..m4!.As
    3bd4:	07521cd0 21ac1c71 cd124763 74c9d328     ..R.q..!cG..(..t
    3be4:	274c9d32 488cd1d3 a0e68399 290e6839     2.L'...H....9h.)
    3bf4:	21280f72 5111414c 74c92324 73001ac7     r.(!LA.Q$#.t...s
    3c04:	54212912 24c90945 6af188c3 25224a2d     .)!TE..$...j-J"%
    3c14:	a7117400 8e174421 e1a6670a 10a3229e     .t..!D...g..."..
    3c24:	15750005 516c212c c3470d22 1c3470d1     ..u.,!lQ".G..p4.
    3c34:	11c3470d 7600855b 4c1d2a14 430c9a51     .G..[..v.*.LQ..C
    3c44:	3828d8c3 72e9928a 77001088 7c1d301b     ..(8...r...w.0.|
    3c54:	664d2951 186cd0c3 2382911b 26449452     Q)Mf..l....#R.D&
    3c64:	887285d1 12780850 6164212b a4519361     ..r.P.x.+!daa.Q.
    3c74:	425579f5 06285193 21ab1b79 4c9b5163     .yUB.Q(.y..!cQ.L
    3c84:	2cd8d343 c24e8b38 321cf893 d1654507     C..,8.N....2.Ee.
    3c94:	7a0e7c49 5421290e 88d5a071 03c48adc     I|.z.)!Tq.......
    3ca4:	050e7b01 122733a2 1b28a4ed 7c1426ed     .{...3'...(..&.|
    3cb4:	5c31c207 0f7d03f1 2133a205 09b68d94     ..1\..}...3!....
    3cc4:	a93da245 6a0b7e01 72b56524 00468c88     E.=..~.j$e.r..F.
    3cd4:	04000000 0000ffff                       ........

00003cdc <u8g2_font_open_iconic_weather_6x_t>:
    3cdc:	06060006 04020606 00303007 30003000     .........00..0.0
    3cec:	003f0000 40360200 c3a9303f 10d9442f     ..?...6@?0../D..
    3cfc:	b3651e21 732b9864 c54daa69 e7933a99     !.e.d.+si.M..:..
    3d0c:	a5a43109 139298a4 06543a82 2e09688b     .1.......:T..h..
    3d1c:	82bc15e1 2403f01f 45a13bc1 81d50ab0     .......$.;.E....
    3d2c:	c84d4c4a 5f410000 17c22c30 2110d944     JLM...A_0,..D..!
    3d3c:	64b3651e 45c26c18 10e8083c 82c6469b     .e.d.l.E<....F..
    3d4c:	e3491688 26902451 c4965081 07105161     ..I.Q$.&.P..aQ..
    3d5c:	191c3926 12689085 38a9b281 3cf26753     &9....h....8Sg.<
    3d6c:	94b48621 42725314 60ca8750 25c12d11     !....SrBP..`.-.%
    3d7c:	f05782bc 24807e03 08b42778 503aa156     ..W..~.$x'..V.:P
    3d8c:	1909a989 ee514200 c09fc26b 680b483a     .....BQ.k...:H.h
    3d9c:	88983ce1 8d2a4132 6c29910b e9ef8e84     .<..2A*...)l....
    3dac:	4e907883 c9b849c2 5a28d936 9760b325     .x.N.I..6.(Z%.`.
    3dbc:	2c65630b 3e91c50d 0820c890 a84541ac     .ce,...>.. ..AE.
    3dcc:	3a81940a 1169094c 23c7a035 460c2a69     ...:L.i.5..#i*.F
    3ddc:	61a41ce9 7e430002 2fc22c30 2108e944     ...a..C~0,./D..!
    3dec:	64b3651e 69732b98 99c50e2a 09e7933a     .e.d.+si*...:...
    3dfc:	a4a5a431 82139298 8b06543a e12e0968     1.......:T..h...
    3e0c:	8902bc15 4c4a5281 94386825 024d0180     .....RJL%h8...M.
    3e1c:	08113406 1059a10d 24e0c701 a073c326     .4....Y....$&.s.
    3e2c:	32a1500c f0cb0344 41c30e11 91860c98     .P.2D......A....
    3e3c:	248c3064 19246183 60c9230c c3064918     d0.$.a$..#.`.I..
    3e4c:	46183248 9230c192 6491860c 02268c30     H2.F..0....d0.&.
    3e5c:	0000d442 7b6e5944 2b012dc2 a25412b4     B...DYn{.-.+..T.
    3e6c:	9d1a80d4 54a91308 23234a90 41ac0572     .......T.J##r..A
    3e7c:	d210a055 8f406a22 9854d247 365192cb     U..."j@.G.T...Q6
    3e8c:	28d92709 c166551a 4b028214 612b8910     .'.(.Uf....K..+a
    3e9c:	82042c24 a18c0cb0 aa063832 82281500     $,......28....(.
    3eac:	d6069844 02601240 1205a029 306e4500     D...@.`.)....En0
    3ebc:	c22dc22c ad8d506a 11a08e84 6066031a     ,.-.jP........f`
    3ecc:	3181980c 80c60660 46821a19 63270ce0     ...1`......F..'c
    3edc:	4f908474 8b3651d2 0e10e566 0c0841cc     t..O.Q6.f....A..
    3eec:	1860c606 60618318 3181860c c0e1010c     ..`...a`...1....
    3efc:	a2c7041c 4e946d59 c74241f2 1c0d38c8     ....Ym.N.AB..8..
    3f0c:	06342341 3018c0cc 0cc06303 3433018c     A#4....0.c....34
    3f1c:	11d08d04 6c6a8356 00005825 ff040000     ....V.jl%X......
    3f2c:	000000ff                                ....

00003f30 <u8g2_cb_r0>:
    3f30:	000021a9 0000222d 00002259 00002434     .!..-"..Y"..4$..
    3f40:	0000240a 0000241c 0000242e 00002434     .$...$...$..4$..
    3f50:	00002434 00002672 0000267e 000026ba     4$..r&..~&...&..
    3f60:	0000266e 000026ba 0000266e 000026a0     n&...&..n&...&..
    3f70:	000026ae                                .&..

00003f74 <u8x8_d_gdey0154_152x304_init_seq>:
    3f74:	16061518 16171617 16011517 16001603     ................
    3f84:	162b162b 153c1509 1514fe04 150f1600     +.+...<.........
    3f94:	153a1630 16981661 15ff1631 15121682     0.:.a...1.......
    3fa4:	19871650 000000ff                       P.......

00003fac <u8x8_d_ssd1607_to_display_seq>:
    3fac:	19121518 000000ff                       ........

00003fb4 <u8x8_ssd1607_200x200_display_info>:
    3fb4:	3c780100 64326464 003d0900 96280400     ..x<dd2d..=...(.
    3fc4:	00001326 00980130 c233312b 000043b0     &...0...+13..C..
    3fd4:	50343337 00000000 c236312b 000043b0     734P....+16..C..
    3fe4:	50363337 00000000 c234312b 000043b0     736P....+14..C..
    3ff4:	50373337 00000000 c230312b 000043b0     737P....+10..C..
    4004:	72756854 79616473 2d353220 322d3430     Thursday 25-04-2
    4014:	00343230 20776f4e 362e3331 202c2043     024.Now 13.6C , 
    4024:	6d353337 36202c6d 00002533 372d4652     735mm, 63%..RF-7
    4034:	00426439 2e332042 00563439              9dB.B 3.94V.

00004040 <_init>:
    4040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4042:	46c0      	nop			; (mov r8, r8)
    4044:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4046:	bc08      	pop	{r3}
    4048:	469e      	mov	lr, r3
    404a:	4770      	bx	lr

0000404c <__init_array_start>:
    404c:	000000cd 	.word	0x000000cd

00004050 <_fini>:
    4050:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4052:	46c0      	nop			; (mov r8, r8)
    4054:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4056:	bc08      	pop	{r3}
    4058:	469e      	mov	lr, r3
    405a:	4770      	bx	lr

0000405c <__fini_array_start>:
    405c:	000000a5 	.word	0x000000a5
